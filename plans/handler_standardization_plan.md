# План стандартизации обработчиков Telegram-бота

## Текущее состояние

В проекте обнаружены следующие проблемы:
1. Дублирование callback data структур
2. Несколько способов обработки одних и тех же действий
3. Непоследовательное использование структур данных
4. Смешение старого и нового подходов к организации обработчиков

## Цель

Создать унифицированную структуру обработчиков, следуя принципам модульности иерархии, как рекомендовано в документации aiogram.

## Этапы реализации

### 1. Унификация callback data структур

#### 1.1. Исправление дублирования в `keyboards/callback_data.py`
- Удалить дублирующийся класс `GiveawaysAction`
- Объединить поля в одну универсальную структуру
- Добавить типизацию с использованием `Literal` для полей action

#### 1.2. Создание иерархической структуры callback data
- Разделить на общие и специфические структуры
- Использовать префиксы для логической группировки
- Обеспечить возможность расширения

### 2. Создание иерархической структуры обработчиков

#### 2.1. Новая структура директорий
```
handlers/
├── common/              # Общие обработчики (start, помощь и т.д.)
├── user/                # Обработчики для обычных пользователей
│   ├── __init__.py
│   ├── dashboard.py     # Панель управления пользователя
│   ├── my_giveaways.py # Мои розыгрыши
│   └── participation.py # Участие в розыгрышах
├── admin/               # Обработчики для администраторов
│   ├── __init__.py
│   ├── base.py          # Базовое меню администратора
│   ├── stats.py         # Статистика
│   ├── users.py         # Управление пользователями
│   ├── giveaways/       # Управление розыгрышами
│   │   ├── __init__.py
│   │   ├── list.py      # Список розыгрышей
│   │   └── detail.py    # Детали розыгрыша
│   ├── broadcast.py     # Рассылка
│   ├── security.py      # Безопасность
│   └── settings.py      # Настройки
└── creator/             # Обработчики для создателей розыгрышей
    ├── __init__.py
    └── constructor.py   # Конструктор розыгрышей
```

#### 2.2. Модульная организация
- Каждый модуль должен содержать только связанные функциональности
- Использовать единый стиль именования роутеров
- Обеспечить легкость подключения/отключения модулей

### 3. Стандартизация обработчиков

#### 3.1. Общий шаблон обработчика
```python
from aiogram import Router
from aiogram.types import CallbackQuery
from sqlalchemy.ext.asyncio import AsyncSession

from filters.is_admin import IsAdmin
from keyboards.inline.some_keyboard import some_keyboard
from keyboards.callback_data import SomeAction

router = Router()

@router.callback_query(IsAdmin(), SomeAction.filter())
async def handle_some_action(
    call: CallbackQuery, 
    callback_data: SomeAction,
    session: AsyncSession
):
    """
    Описание функции
    
    Args:
        call: Объект CallbackQuery
        callback_data: Распакованные данные из callback
        session: Асинхронная сессия SQLAlchemy
    """
    # Логика обработки
    pass
```

#### 3.2. Стандарты именования
- Функции: `handle_` + `[действие]` + `_` + `[объект]`
- Роутеры: `router` (для основного роутера в модуле)
- Callback data: `[префикс]Action`

### 4. Централизованное управление состояниями

#### 4.1. Единый файл для состояний
- Все FSM состояния в одном файле `handlers/states.py`
- Группировка по модулям с использованием namespace
- Четкая документация для каждого состояния

### 5. Унификация логики навигации

#### 5.1. Создание базового класса навигации
- Единый интерфейс для навигации между разделами
- Использование callback данных для переходов
- Поддержка возврата на предыдущие экраны

### 6. Обновление точек входа

#### 6.1. Модификация `main.py`
- Удаление дублирующихся импортов
- Подключение только новых унифицированных роутеров
- Обновление логики включения роутеров

## Порядок внедрения

1. Создать новую структуру, параллельно с существующей
2. Постепенно переносить функциональность в новые модули
3. Тестировать каждый перенесенный компонент
4. После полного переноса удалить старые модули
5. Обновить документацию

## Ожидаемые результаты

- Упрощенное обслуживание кода
- Устранение дублирования
- Повышенная читаемость и понятность архитектуры
- Легкость добавления новых функций
- Снижение вероятности ошибок при разработке
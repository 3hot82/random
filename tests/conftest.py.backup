import pytest
from unittest.mock import AsyncMock, MagicMock
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker
from database.base import Base
from config import config
from datetime import datetime, timedelta
from database.models.giveaway import Giveaway
import os


@pytest.fixture(scope="session")
def event_loop():
    """Create an instance of the default event loop for the session."""
    import asyncio
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()


@pytest.fixture(scope="session")
async def async_session():
    """Асинхронная сессия для интеграционных тестов."""
    # Создаем отдельную тестовую базу данных
    # Проверяем, есть ли TEST_DATABASE_URL в конфигурации, иначе используем тестовую SQLite
    database_url = getattr(config, 'TEST_DATABASE_URL', None)
    if not database_url:
        # Если TEST_DATABASE_URL не определен, используем тестовую SQLite базу
        database_url = "sqlite+aiosqlite:///./test_temp.db"
    
    engine = create_async_engine(database_url)
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    
    async_session_local = sessionmaker(engine, expire_on_commit=False, class_=AsyncSession)
    
    async with async_session_local() as session:
        yield session
    
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)
    
    await engine.dispose()


@pytest.fixture
def mock_session():
    """Фикстура для мокирования сессии базы данных с правильной асинхронной логикой"""
    session = AsyncMock(spec=AsyncSession)
    
    # Мокаем часто используемые методы сессии
    session.add = MagicMock()
    session.commit = AsyncMock()
    session.rollback = AsyncMock()
    session.refresh = AsyncMock()
    
    # Мокаем метод execute для корректной работы с асинхронными результатами
    async def mock_execute(stmt):
        result = MagicMock()
        # Мокаем скалярные методы - используем AsyncMock для асинхронных вызовов
        result.scalar_one_or_none = AsyncMock(return_value=None)
        result.scalar = AsyncMock(return_value=None)
        
        # Мокаем scalars().all() для корректной работы с коллекциями
        scalars_mock = MagicMock()
        scalars_mock.all = AsyncMock(return_value=[])
        result.scalars = MagicMock(return_value=scalars_mock)
        
        return result
        
    session.execute = mock_execute
    
    # Мокаем метод get
    async def mock_get(model_class, identifier):
        return None
    
    session.get = mock_get
    
    return session


@pytest.fixture
def sample_giveaway_data():
    """Образец данных розыгрыша для тестов"""
    return {
        "owner_id": 123456789,
        "channel_id": -1001234567890,
        "message_id": 123,
        "prize_text": "Тестовый приз",
        "winners_count": 1,
        "finish_time": datetime.now() + timedelta(days=7),
        "status": "active",
        "is_referral_enabled": False,
        "is_captcha_enabled": False,
        "is_paid": False,
        "is_participants_hidden": False,
        "is_story_boost_enabled": False,
        "is_channel_boost_enabled": False,
        "is_referral_boost_enabled": False
    }


@pytest.fixture
def unique_user_id_counter():
    """Фикстура для генерации уникальных ID пользователей"""
    counter = 100000000  # начальное значение для уникальных ID

    def _counter():
        nonlocal counter
        counter += 1
        return counter

    return _counter
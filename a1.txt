=== ./keyboards/inline/calendar_kb.py ===
import calendar
from datetime import datetime
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from core.tools.timezone import get_now_msk

MONTHS = ["", "–Ø–Ω–≤–∞—Ä—å", "–§–µ–≤—Ä–∞–ª—å", "–ú–∞—Ä—Ç", "–ê–ø—Ä–µ–ª—å", "–ú–∞–π", "–ò—é–Ω—å", "–ò—é–ª—å", "–ê–≤–≥—É—Å—Ç", "–°–µ–Ω—Ç—è–±—Ä—å", "–û–∫—Ç—è–±—Ä—å", "–ù–æ—è–±—Ä—å", "–î–µ–∫–∞–±—Ä—å"]

def generate_calendar(year: int, month: int) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    now = get_now_msk()

    builder.button(text=f"{MONTHS[month]} {year}", callback_data="ignore")
    days = ["–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±", "–í—Å"]
    for d in days:
        builder.button(text=d, callback_data="ignore")

    cal = calendar.monthcalendar(year, month)
    for week in cal:
        for day in week:
            if day == 0:
                builder.button(text=" ", callback_data="ignore")
                continue
            
            # –õ–æ–≥–∏–∫–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –ø—Ä–æ—à–ª–æ–≥–æ
            is_past = False
            if year < now.year: is_past = True
            elif year == now.year and month < now.month: is_past = True
            elif year == now.year and month == now.month and day < now.day: is_past = True
            
            if is_past:
                # –í–º–µ—Å—Ç–æ —Ü–∏—Ñ—Ä—ã —Å—Ç–∞–≤–∏–º –ø—Ä–æ—á–µ—Ä–∫ –∏–ª–∏ –∫—Ä–µ—Å—Ç–∏–∫
                builder.button(text="‚úñÔ∏è", callback_data="ignore")
            else:
                builder.button(text=str(day), callback_data=f"date_set:{year}:{month}:{day}")

    builder.adjust(1, 7, 7, 7, 7, 7, 7)
    
    # –ù–∞–≤–∏–≥–∞—Ü–∏—è (–Ω–µ –¥–∞–µ–º —É–π—Ç–∏ –¥–∞–ª–µ–∫–æ –≤ –ø—Ä–æ—à–ª–æ–µ)
    prev_m = month - 1 if month > 1 else 12
    prev_y = year if month > 1 else year - 1
    next_m = month + 1 if month < 12 else 1
    next_y = year if month < 12 else year + 1
    
    can_go_back = not (prev_y < now.year or (prev_y == now.year and prev_m < now.month))
    
    nav_row = []
    if can_go_back:
        builder.button(text="‚¨ÖÔ∏è", callback_data=f"cal_nav:{prev_y}:{prev_m}")
    else:
        builder.button(text=" ", callback_data="ignore") # –ü—É—Å—Ç—ã—à–∫–∞ –¥–ª—è –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è
        
    builder.button(text="‚û°Ô∏è", callback_data=f"cal_nav:{next_y}:{next_m}")
    
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="constr_back_main")
    
    # –ü–æ—Å–ª–µ–¥–Ω–∏–π —Ä—è–¥: –ù–∞–≤–∏–≥–∞—Ü–∏—è + –ù–∞–∑–∞–¥
    builder.adjust(1, 7, 7, 7, 7, 7, 7, 2, 1)
    return builder.as_markup()

def time_picker_kb(year, month, day) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    now = get_now_msk()
    
    # –ï—Å–ª–∏ –≤—ã–±—Ä–∞–Ω "—Å–µ–≥–æ–¥–Ω—è", –±–ª–æ–∫–∏—Ä—É–µ–º –ø—Ä–æ—à–µ–¥—à–∏–µ —á–∞—Å—ã
    is_today = (year == now.year and month == now.month and day == now.day)
    current_hour = now.hour
    
    for h in range(0, 24):
        if is_today and h <= current_hour:
            # –ü—Ä–æ—à–µ–¥—à–∏–µ —á–∞—Å—ã –ø–æ–º–µ—á–∞–µ–º —Ç–æ—á–∫–æ–π –∏–ª–∏ —É–¥–∞–ª—è–µ–º
            builder.button(text="‚Ä¢", callback_data="ignore")
        else:
            builder.button(text=f"{h:02d}:00", callback_data=f"time_set:{year}:{month}:{day}:{h}:00")
        
    builder.adjust(4)
    builder.row(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥ –∫ –¥–∞—Ç–µ", callback_data=f"cal_nav:{year}:{month}"))
    return builder.as_markup()=== ./keyboards/inline/user_panel.py ===
from aiogram.utils.keyboard import InlineKeyboardBuilder
from database.models.giveaway import Giveaway

def giveaways_hub_kb(has_created: bool) -> InlineKeyboardBuilder:
    builder = InlineKeyboardBuilder()
    
    # –†–∞–∑–¥–µ–ª —É—á–∞—Å—Ç–Ω–∏–∫–∞
    builder.button(text="‚è≥ –í –∫–æ—Ç–æ—Ä—ã—Ö —É—á–∞—Å—Ç–≤—É—é", callback_data="part_list:active:0")
    builder.button(text="üèÅ –ó–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ (–£—á–∞—Å—Ç–∏–µ)", callback_data="part_list:finished:0")
    
    # –†–∞–∑–¥–µ–ª —Å–æ–∑–¥–∞—Ç–µ–ª—è
    if has_created:
        builder.button(text="üìÇ –ú–æ–∏ —Ä–æ–∑—ã–≥—Ä—ã—à–∏ (–°–æ–∑–¥–∞–Ω–Ω—ã–µ)", callback_data="created_list:0")
        
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="dashboard_home")
    builder.adjust(1)
    return builder.as_markup()

def universal_list_kb(
    giveaways: list[Giveaway], 
    page: int, 
    total_pages: int, 
    prefix: str, 
    won_ids: set[int] = None
) -> InlineKeyboardBuilder:
    """
    –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫.
    prefix –º–æ–∂–µ—Ç –±—ã—Ç—å: 'part_list:active', 'part_list:finished', 'created_list'
    won_ids: –Ω–∞–±–æ—Ä ID —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π, –≤ –∫–æ—Ç–æ—Ä—ã—Ö —é–∑–µ—Ä –ø–æ–±–µ–¥–∏–ª (–Ω—É–∂–Ω–æ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∫—É–±–∫–∞)
    """
    builder = InlineKeyboardBuilder()
    won_ids = won_ids or set()
    
    for gw in giveaways:
        # –í—ã–±–∏—Ä–∞–µ–º –∏–∫–æ–Ω–∫—É
        if "created" in prefix:
            icon = "üì¢"
        elif gw.status == 'active':
            icon = "‚è≥"
        else:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –ø–æ–±–µ–¥—É —á–µ—Ä–µ–∑ –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–π set ID
            if gw.id in won_ids:
                icon = "üèÜ"
            else:
                icon = "‚ùå"
        
        btn_text = f"{icon} {gw.prize_text[:20]}..."
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –¥–µ–π—Å—Ç–≤–∏–µ –ø—Ä–∏ –∫–ª–∏–∫–µ
        action = "view_created" if "created" in prefix else "part_view"
        builder.button(text=btn_text, callback_data=f"{action}:{gw.id}")

    # –ü–∞–≥–∏–Ω–∞—Ü–∏—è
    nav_buttons = []
    if page > 0:
        nav_buttons.append(("‚¨ÖÔ∏è", f"{prefix}:{page-1}"))
    
    nav_buttons.append((f"{page+1}/{total_pages}", "ignore"))
    
    if page < total_pages - 1:
        nav_buttons.append(("‚û°Ô∏è", f"{prefix}:{page+1}"))
    
    for text, data in nav_buttons:
        builder.button(text=text, callback_data=data)
    
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="giveaways_hub")
    
    # –°–µ—Ç–∫–∞
    sizes = [1] * len(giveaways) + [len(nav_buttons)] + [1]
    builder.adjust(*sizes)
    return builder.as_markup()

def participation_details_kb(channel_link: str) -> InlineKeyboardBuilder:
    builder = InlineKeyboardBuilder()
    if channel_link:
        builder.button(text="‚ÜóÔ∏è –ü–µ—Ä–µ–π—Ç–∏ –∫ –ø–æ—Å—Ç—É", url=channel_link)
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="giveaways_hub")
    builder.adjust(1)
    return builder.as_markup()

def detail_back_kb() -> InlineKeyboardBuilder:
    builder = InlineKeyboardBuilder()
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="giveaways_hub")
    return builder.as_markup()=== ./keyboards/inline/participation.py ===
# keyboards/inline/participation.py
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder

def join_keyboard(bot_username: str, giveaway_id: int) -> InlineKeyboardMarkup:
    """–ö–Ω–æ–ø–∫–∞ –ø–æ–¥ –ø–æ—Å—Ç–æ–º –≤ –∫–∞–Ω–∞–ª–µ"""
    url = f"https://t.me/{bot_username}?start=gw_{giveaway_id}"
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="–£—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å üéÅ", url=url)]
    ])

def check_subscription_kb(gw_id: int, channels: list) -> InlineKeyboardMarkup:
    """
    –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞, –∫–æ—Ç–æ—Ä—É—é –≤–∏–¥–∏—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –õ–°, –µ—Å–ª–∏ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω.
    channels: —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤–∞—Ä–µ–π {'title': str, 'link': str}
    """
    builder = InlineKeyboardBuilder()
    
    # –ö–Ω–æ–ø–∫–∏ –∫–∞–Ω–∞–ª–æ–≤
    for ch in channels:
        builder.button(text=f"üì¢ {ch['title']}", url=ch['link'])
    
    # –ö–Ω–æ–ø–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ (Callback!)
    builder.button(text="üîÑ –Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è", callback_data=f"check_sub:{gw_id}")
    
    builder.adjust(1)
    return builder.as_markup()

def results_keyboard(bot_username: str, giveaway_id: int) -> InlineKeyboardMarkup:
    url = f"https://t.me/{bot_username}?start=res_{giveaway_id}"
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üìã –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã", url=url)]
    ])=== ./keyboards/inline/dashboard.py ===
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from database.models.channel import Channel
from database.models.giveaway import Giveaway

# --- –ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ (/start) ---
def start_menu_kb() -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    builder.button(text="üé´ –ú–æ–∏ —É—á–∞—Å—Ç–∏—è", callback_data="my_participations")
    builder.button(text="‚ú® –°–æ–∑–¥–∞—Ç—å —Ä–æ–∑—ã–≥—Ä—ã—à", callback_data="create_gw_init")
    builder.button(text="üë§ –õ–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç", callback_data="cabinet_hub")
    builder.adjust(1)
    return builder.as_markup()

# --- –õ–ò–ß–ù–´–ô –ö–ê–ë–ò–ù–ï–¢ ---
def cabinet_kb() -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    builder.button(text="‚öôÔ∏è –ú–æ–∏ –∫–∞–Ω–∞–ª—ã", callback_data="my_channels")
    builder.button(text="üìÇ –ò—Å—Ç–æ—Ä–∏—è —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π", callback_data="my_giveaways_hub")
    builder.button(text="üß© –ü–ª–∞—Ç–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏", callback_data="premium_shop")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="dashboard_home")
    builder.adjust(1)
    return builder.as_markup()

# --- –ú–ï–ù–Æ –†–û–ó–´–ì–†–´–®–ï–ô (HUB) ---
def my_giveaways_hub_kb(active_count: int, finished_count: int) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    # –¶–∏—Ñ—Ä—ã –≤ —Å–∫–æ–±–∫–∞—Ö, –±–µ–∑ –ª–∏—à–Ω–∏—Ö —ç–º–æ–¥–∑–∏
    builder.button(text=f"–ê–∫—Ç—É–∞–ª—å–Ω—ã–µ ({active_count})", callback_data="gw_list:active")
    builder.button(text=f"–ó–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ ({finished_count})", callback_data="gw_list:finished")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="cabinet_hub")
    builder.adjust(1)
    return builder.as_markup()

# --- –°–ü–ò–°–û–ö –†–û–ó–´–ì–†–´–®–ï–ô ---
def giveaways_list_kb(giveaways: list[Giveaway], status: str) -> InlineKeyboardBuilder:
    builder = InlineKeyboardBuilder()
    
    for gw in giveaways:
        # –ò–Ω–¥–∏–∫–∞—Ü–∏—è —Å—Ç–∞—Ç—É—Å–∞ —Ç–æ—á–∫–æ–π
        icon = "üü¢" if status == "active" else "‚ö´Ô∏è"
        # –û–±—Ä–µ–∑–∞–µ–º —Ç–µ–∫—Å—Ç –ø—Ä–∏–∑–∞
        name = gw.prize_text[:25].replace("\n", " ")
        builder.button(text=f"{icon} {name}...", callback_data=f"gw_manage:{gw.id}")
    
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="my_giveaways_hub")
    builder.adjust(1)
    return builder.as_markup()

# --- –£–ü–†–ê–í–õ–ï–ù–ò–ï –ê–ö–¢–ò–í–ù–´–ú ---
def active_gw_manage_kb(gw_id: int) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    builder.button(text="üîÑ –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø—É–±–ª–∏–∫–∞—Ü–∏—è", callback_data=f"gw_act:repost:{gw_id}")
    builder.button(text="üõë –ó–∞–≤–µ—Ä—à–∏—Ç—å –¥–æ—Å—Ä–æ—á–Ω–æ", callback_data=f"gw_act:finish:{gw_id}")
    builder.button(text="üóë –£–¥–∞–ª–∏—Ç—å", callback_data=f"gw_act:delete:{gw_id}")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="gw_list:active")
    builder.adjust(1)
    return builder.as_markup()

# --- –£–ü–†–ê–í–õ–ï–ù–ò–ï –ó–ê–í–ï–†–®–ï–ù–ù–´–ú ---
def finished_gw_manage_kb(gw_id: int, results_link: str = None) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    if results_link:
        builder.button(text="üîó –ü–µ—Ä–µ–π—Ç–∏ –∫ –ø–æ—Å—Ç—É", url=results_link)
    builder.button(text="üóë –£–¥–∞–ª–∏—Ç—å –∏–∑ –±–∞–∑—ã", callback_data=f"gw_act:delete:{gw_id}")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="gw_list:finished")
    builder.adjust(1)
    return builder.as_markup()

# --- –ú–ê–ì–ê–ó–ò–ù (PREMIUM) ---
def premium_shop_kb() -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    builder.button(text="üõ° –ö—É–ø–∏—Ç—å –ö–∞–ø—á—É (50 ‚≠êÔ∏è)", callback_data="buy_captcha")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="cabinet_hub")
    builder.adjust(1)
    return builder.as_markup()

# --- –ö–ê–ù–ê–õ–´ ---
def channels_list_kb(channels: list[Channel]) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    for ch in channels:
        builder.button(text=f"üóë {ch.title}", callback_data=f"del_ch_{ch.id}")
    builder.button(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–∞–Ω–∞–ª", callback_data="add_new_channel")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="cabinet_hub")
    builder.adjust(1)
    return builder.as_markup()

def back_to_dash() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="cabinet_hub")]
    ])

def skip_link_kb(mode="settings") -> InlineKeyboardMarkup:
    callback = "skip_link_settings" if mode == "settings" else "skip_link_constr"
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚è© –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data=callback)]
    ])=== ./keyboards/inline/constructor.py ===
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from database.models.channel import Channel

def constructor_main_kb(
    time_str: str, winners: int, 
    ref_req: int, # –ï—Å–ª–∏ 0 - –≤—ã–∫–ª, –∏–Ω–∞—á–µ –∫–æ–ª-–≤–æ –¥—Ä—É–∑–µ–π
    is_captcha: bool, has_main_channel: bool, sponsors_count: int
) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    
    main_text = "üì¢ –ö–∞–Ω–∞–ª: –í—ã–±—Ä–∞—Ç—å" if not has_main_channel else "üì¢ –ö–∞–Ω–∞–ª: ‚úÖ –í—ã–±—Ä–∞–Ω"
    sponsor_text = f"ü§ù –°–ø–æ–Ω—Å–æ—Ä—ã: {sponsors_count}" if sponsors_count > 0 else "ü§ù –°–ø–æ–Ω—Å–æ—Ä—ã: –ù–µ—Ç"
    builder.button(text=main_text, callback_data="constr_select_main")
    builder.button(text=sponsor_text, callback_data="constr_select_sponsors")
    
    builder.button(text=f"‚è≥ –ò—Ç–æ–≥–∏: {time_str}", callback_data="constr_time_menu")
    builder.button(text=f"üèÜ –ü–æ–±–µ–¥–∏—Ç–µ–ª–∏: {winners}", callback_data="constr_winners_menu")
    
    ref_text = f"üîó –†–µ—Ñ: {ref_req} –¥—Ä—É–∑–µ(–π)" if ref_req > 0 else "üîó –†–µ—Ñ: –í—ã–∫–ª"
    builder.button(text=ref_text, callback_data="constr_ref_menu")
    
    cap_status = "–í–ö–õ" if is_captcha else "–í—ã–∫–ª"
    builder.button(text=f"üõ° –ö–∞–ø—á–∞: {cap_status}", callback_data="constr_toggle_cap")
    
    builder.button(text="‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å –¢–µ–∫—Å—Ç/–ú–µ–¥–∏–∞", callback_data="constr_edit_content")
    builder.button(text="‚úÖ –û–ü–£–ë–õ–ò–ö–û–í–ê–¢–¨", callback_data="constr_publish")
    
    # –ù–û–í–ê–Ø –ö–ù–û–ü–ö–ê –û–¢–ú–ï–ù–´
    builder.button(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_creation")
    
    # –°–µ—Ç–∫–∞ –∫–Ω–æ–ø–æ–∫: 2, 2, 2, 1, 1, 1
    builder.adjust(2, 2, 2, 1, 1, 1)
    return builder.as_markup()

def winners_selector_kb() -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    
    # –ö–Ω–æ–ø–∫–∏ —Å –ø–æ–ø—É–ª—è—Ä–Ω—ã–º–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞–º–∏
    popular_values = [1, 2, 3, 5, 10, 20, 50]
    for w in popular_values:
        builder.button(text=f"üèÜ {w}", callback_data=f"constr_set_winners:{w}")
    
    # –ö–Ω–æ–ø–∫–∞ –¥–ª—è –≤–≤–æ–¥–∞ –≤—Ä—É—á–Ω—É—é
    builder.button(text="‚úèÔ∏è –í–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ", callback_data="constr_set_winners_input")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="constr_back_main")
    
    # –°–µ—Ç–∫–∞: 4 –≤ —Ä—è–¥—É, –∑–∞—Ç–µ–º 1
    builder.adjust(4, 4, 1)
    return builder.as_markup()

def referral_selector_kb() -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    options = [(0, "–í—ã–∫–ª"), (1, "1 –¥—Ä—É–≥"), (3, "3 –¥—Ä—É–≥–∞"), (5, "5 –¥—Ä—É–∑–µ–π")]
    for val, label in options:
        builder.button(text=label, callback_data=f"constr_set_ref:{val}")
    
    # –î–æ–±–∞–≤–∏–º –∫–Ω–æ–ø–∫—É –¥–ª—è –≤–≤–æ–¥–∞ –≤—Ä—É—á–Ω—É—é
    builder.button(text="‚úèÔ∏è –í–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ", callback_data="constr_set_ref_input")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="constr_back_main")
    
    builder.adjust(2, 2, 1)
    return builder.as_markup()

def channel_selection_kb(channels: list[Channel], mode: str, selected_ids: list[int]) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    
    # –ö–Ω–æ–ø–∫–∏ –∫–∞–Ω–∞–ª–æ–≤
    for ch in channels:
        icon = "‚úÖ" if mode == "main" and ch.channel_id in selected_ids else ("‚òëÔ∏è" if ch.channel_id in selected_ids else "‚¨ú")
        cb = f"constr_set_ch:{mode}:{ch.channel_id}"
        builder.button(text=f"{icon} {ch.title}", callback_data=cb)
    
    # –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
    builder.button(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π –∫–∞–Ω–∞–ª", callback_data="add_new_channel_constr")
    builder.button(text="üíæ –ì–æ—Ç–æ–≤–æ (–°–æ—Ö—Ä–∞–Ω–∏—Ç—å)", callback_data="constr_back_main")
    
    builder.adjust(1)
    return builder.as_markup()=== ./keyboards/inline/admin_panel.py ===
# keyboards/inline/admin_panel.py
from aiogram.utils.keyboard import InlineKeyboardBuilder
from database.models.giveaway import Giveaway
from keyboards.callback_data import AdminAction
from core.security.hmac_signer import sign_data

def build_giveaway_list(giveaways: list[Giveaway], admin_id: int):
    """–°—Ç—Ä–æ–∏—Ç —Å–ø–∏—Å–æ–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π. –ö–Ω–æ–ø–∫–∏ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∞–¥–º–∏–Ω–∞."""
    builder = InlineKeyboardBuilder()
    
    for gw in giveaways:
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø–æ–¥–ø–∏—Å–∏ –¥–ª—è –¥–µ–π—Å—Ç–≤–∏–π
        sig_manage = sign_data("manage", gw.id, admin_id)
        
        btn_text = f"üéÅ #{gw.id} | {gw.winners_count} winners"
        callback = AdminAction(action="manage", id=gw.id, sig=sig_manage)
        
        builder.button(text=btn_text, callback_data=callback)
    
    builder.adjust(1) # –í –æ–¥–∏–Ω —Å—Ç–æ–ª–±–∏–∫
    return builder.as_markup()

def build_manage_menu(gw_id: int, admin_id: int):
    """–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º —Ä–æ–∑—ã–≥—Ä—ã—à–µ–º"""
    builder = InlineKeyboardBuilder()
    
    # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–æ–¥–ø–∏—Å–µ–π
    sig_del = sign_data("delete", gw_id, admin_id)
    sig_rig = sign_data("rig", gw_id, admin_id) # –ö–Ω–æ–ø–∫–∞ –ø–æ–¥–∫—Ä—É—Ç–∫–∏
    sig_finish = sign_data("finish", gw_id, admin_id)

    builder.button(text="üõë –ó–∞–≤–µ—Ä—à–∏—Ç—å", callback_data=AdminAction(action="finish", id=gw_id, sig=sig_finish))
    builder.button(text="üóë –£–¥–∞–ª–∏—Ç—å", callback_data=AdminAction(action="delete", id=gw_id, sig=sig_del))
    builder.button(text="üéØ –ù–∞–∑–Ω–∞—á–∏—Ç—å –ø–æ–±–µ–¥–∏—Ç–µ–ª—è", callback_data=AdminAction(action="rig", id=gw_id, sig=sig_rig))
    
    builder.adjust(1)
    return builder.as_markup()=== ./keyboards/__init__.py ===
=== ./keyboards/builders.py ===
# keyboards/builders.py
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.types import InlineKeyboardButton

def simple_menu(text: str, callback_data: str) -> InlineKeyboardBuilder:
    builder = InlineKeyboardBuilder()
    builder.add(InlineKeyboardButton(text=text, callback_data=callback_data))
    return builder=== ./keyboards/callback_data.py ===
# keyboards/callback_data.py
from aiogram.filters.callback_data import CallbackData

class AdminAction(CallbackData, prefix="adm"):
    """
    –î–∞–Ω–Ω—ã–µ –¥–ª—è –∞–¥–º–∏–Ω—Å–∫–∏—Ö –∫–Ω–æ–ø–æ–∫.
    sig - —ç—Ç–æ HMAC –ø–æ–¥–ø–∏—Å—å.
    """
    action: str
    id: int
    sig: str

class JoinAction(CallbackData, prefix="join"):
    """
    –î–∞–Ω–Ω—ã–µ –¥–ª—è –∫–Ω–æ–ø–∫–∏ —É—á–∞—Å—Ç–∏—è.
    """
    giveaway_id: int=== ./Dockerfile ===
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π (–µ—Å–ª–∏ –Ω—É–∂–Ω—ã –¥–ª—è —Å–±–æ—Ä–∫–∏ pg driver)
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

# –°–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –±–µ–∑ –ø—Ä–∞–≤ root
RUN useradd -m appuser
USER appuser

CMD ["python", "main.py"]=== ./.gitignore ===
# –í–∏—Ä—Ç—É–∞–ª—å–Ω–æ–µ –æ–∫—Ä—É–∂–µ–Ω–∏–µ
venv/
.venv/
env/

# –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è (–°–ê–ú–û–ï –í–ê–ñ–ù–û–ï)
.env

# –ë–∞–π—Ç-–∫–æ–¥ Python
__pycache__/
*.pyc

# –õ–æ–≥–∏
*.log

# –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö (–µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—à—å SQLite —Ñ–∞–π–ª, –¥–ª—è Postgres –Ω–µ –Ω—É–∂–Ω–æ)
*.db
*.sqlite3

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ IDE
.idea/
.vscode/=== ./reset_db.py ===
import asyncio
from redis.asyncio import Redis
from database import engine, Base
from config import config

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –í–°–ï –º–æ–¥–µ–ª–∏, —á—Ç–æ–±—ã SQLAlchemy –∑–Ω–∞–ª–∞, —á—Ç–æ —Å–æ–∑–¥–∞–≤–∞—Ç—å
from database.models.user import User
from database.models.giveaway import Giveaway
from database.models.participant import Participant
from database.models.channel import Channel
from database.models.required_channel import GiveawayRequiredChannel
from database.models.winner import Winner # <--- –í–∞–∂–Ω–æ! –ù–æ–≤–∞—è —Ç–∞–±–ª–∏—Ü–∞

async def reset_database():
    print("üóë –£–¥–∞–ª—è—é —Å—Ç–∞—Ä—ã–µ —Ç–∞–±–ª–∏—Ü—ã PostgreSQL...")
    async with engine.begin() as conn:
        # –£–¥–∞–ª—è–µ–º –≤—Å–µ —Ç–∞–±–ª–∏—Ü—ã
        await conn.run_sync(Base.metadata.drop_all)
        # –°–æ–∑–¥–∞–µ–º –≤—Å–µ —Ç–∞–±–ª–∏—Ü—ã –∑–∞–Ω–æ–≤–æ —Å –Ω–æ–≤—ã–º–∏ –ø–æ–ª—è–º–∏
        await conn.run_sync(Base.metadata.create_all)
    
    print("üóë –û—á–∏—â–∞—é Redis...")
    redis = Redis.from_url(config.REDIS_URL)
    await redis.flushdb()
    await redis.aclose()
    
    print("‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ–±–Ω–æ–≤–ª–µ–Ω–∞!")

if __name__ == "__main__":
    asyncio.run(reset_database())=== ./requirements.txt ===
aiofiles==25.1.0
aiogram==3.23.0
aiohappyeyeballs==2.6.1
aiohttp==3.13.2
aiosignal==1.4.0
aiounittest==1.5.0
alembic==1.17.2
annotated-types==0.7.0
APScheduler==3.11.2
asyncpg==0.31.0
attrs==25.4.0
babel==2.17.0
beautifulsoup4==4.14.3
black==25.12.0
bleach==6.3.0
certifi==2025.11.12
charset-normalizer==3.4.4
click==8.3.1
cloudscraper==1.2.71
colorlog==6.10.1
cryptg==0.5.2
fake-useragent==2.2.0
fluent-compiler==1.1
fluent.runtime==0.4.0
fluent.syntax==0.19.0
fluentogram==1.2.1
frozenlist==1.8.0
greenlet==3.3.0
hashids==1.3.1
howlongtobeatpy==1.0.19
idna==3.11
iniconfig==2.3.0
isort==7.0.0
kagglehub==0.3.13
librt==0.7.5
loguru==0.7.3
lxml==6.0.2
magic-filter==1.0.12
Mako==1.3.10
MarkupSafe==3.0.3
multidict==6.7.0
mypy==1.19.1
mypy_extensions==1.1.0
numpy==2.4.0
packaging==25.0
pandas==2.3.3
pathspec==0.12.1
pillow==12.0.0
platformdirs==4.5.1
playwright==1.57.0
pluggy==1.6.0
propcache==0.4.1
pyaes==1.6.1
pyasn1==0.6.1
pydantic==2.12.5
pydantic-settings==2.12.0
pydantic_core==2.41.5
pyee==13.0.0
Pygments==2.19.2
pyparsing==3.3.1
Pyrogram==2.0.106
PySocks==1.7.1
pytest==9.0.2
pytest-asyncio==1.3.0
python-dateutil==2.9.0.post0
python-dotenv==1.2.1
pytokens==0.3.0
pytz==2025.2
PyYAML==6.0.3
redis==7.1.0
requests==2.32.5
requests-toolbelt==1.0.0
rsa==4.9.1
six==1.17.0
soupsieve==2.8.1
SQLAlchemy==2.0.45
Telethon==1.42.0
TgCrypto==1.2.5
tqdm==4.67.1
typing-inspection==0.4.2
typing_extensions==4.15.0
tzdata==2025.3
tzlocal==5.3.1
urllib3==2.6.2
webencodings==0.5.1
wrapt==2.0.1
yarl==1.22.0
yt-dlp==2025.12.8
=== ./docker-compose.yml ===
# docker-compose.yml
version: '3.8'

services:
  bot:
    build: .
    env_file: .env
    depends_on:
      - db
      - redis
    restart: always

  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: pass
      POSTGRES_DB: giveaway_bot
    volumes:
      - pg_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data

volumes:
  pg_data:
  redis_data:=== ./core/tools/timezone.py ===
from datetime import datetime, timezone
from zoneinfo import ZoneInfo

# –ß–∞—Å–æ–≤—ã–µ –ø–æ—è—Å–∞
MSK = ZoneInfo("Europe/Moscow")
UTC = timezone.utc

def get_now_msk() -> datetime:
    return datetime.now(MSK)

def to_msk(dt: datetime) -> datetime:
    """–ü–µ—Ä–µ–≤–æ–¥–∏—Ç –¥–∞—Ç—É –≤ –ú–°–ö (–µ—Å–ª–∏ –æ–Ω–∞ naive, —Å—á–∏—Ç–∞–µ–º —á—Ç–æ —ç—Ç–æ UTC)"""
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=UTC)
    return dt.astimezone(MSK)

def to_utc(dt: datetime) -> datetime:
    """–ü–µ—Ä–µ–≤–æ–¥–∏—Ç –ú–°–ö –≤ UTC"""
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=MSK)
    return dt.astimezone(UTC)

def strip_tz(dt: datetime) -> datetime:
    """–£–¥–∞–ª—è–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–∞–π–º–∑–æ–Ω–µ –¥–ª—è –∑–∞–ø–∏—Å–∏ –≤ –ë–î (naive UTC)"""
    return dt.replace(tzinfo=None)=== ./core/tools/scheduler.py ===
# core/tools/scheduler.py
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.jobstores.redis import RedisJobStore
from redis import ConnectionPool
from config import config

# APScheduler 3.x –Ω–µ —É–º–µ–µ—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å —Å—Ç—Ä–æ–∫—É URL –Ω–∞–ø—Ä—è–º—É—é.
# –ú—ã —Å–æ–∑–¥–∞–µ–º –ø—É–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π —á–µ—Ä–µ–∑ redis-py, –∫–æ—Ç–æ—Ä—ã–π —É–º–µ–µ—Ç –ø–∞—Ä—Å–∏—Ç—å URL.
pool = ConnectionPool.from_url(config.REDIS_URL)

job_stores = {
    "default": RedisJobStore(
        jobs_key="giveaway_jobs", 
        run_times_key="giveaway_run_times", 
        connection_pool=pool  # <-- –ü–µ—Ä–µ–¥–∞–µ–º –≥–æ—Ç–æ–≤—ã–π –ø—É–ª –≤–º–µ—Å—Ç–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    )
}

scheduler = AsyncIOScheduler(jobstores=job_stores, timezone="UTC")

async def start_scheduler():
    scheduler.start()

async def shutdown_scheduler():
    scheduler.shutdown()=== ./core/tools/formatters.py ===
from datetime import datetime
from core.tools.timezone import to_msk

def format_giveaway_caption(prize_text: str, winners_count: int, finish_time: datetime, participants_count: int) -> str:
    # –ü–µ—Ä–µ–≤–æ–¥–∏–º –≤—Ä–µ–º—è –≤ –ú–°–ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
    finish_msk = to_msk(finish_time)
    
    # –°—á–∏—Ç–∞–µ–º –æ—Å—Ç–∞—Ç–æ–∫ –≤—Ä–µ–º–µ–Ω–∏
    now_msk = to_msk(datetime.utcnow())
    delta = finish_msk - now_msk
    
    if delta.total_seconds() < 0:
        time_left = "–ó–∞–≤–µ—Ä—à–µ–Ω"
    elif delta.days > 0:
        time_left = f"{delta.days} –¥–Ω."
    elif delta.seconds > 3600:
        time_left = f"{delta.seconds // 3600} —á."
    else:
        time_left = "–°–∫–æ—Ä–æ"

    date_str = finish_msk.strftime("%d.%m.%Y %H:%M MSK")

    return (
        f"{prize_text}\n\n"
        f"‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n"
        f"üë• <b>–£—á–∞—Å—Ç–Ω–∏–∫–æ–≤:</b> {participants_count}\n"
        f"üèÜ <b>–ü—Ä–∏–∑–æ–≤—ã—Ö –º–µ—Å—Ç:</b> {winners_count}\n"
        f"‚è≥ <b>–ò—Ç–æ–≥–∏:</b> {date_str} ({time_left})"
    )=== ./core/services/checker_service.py ===
from aiogram import Bot
from redis.asyncio import Redis
from config import config

redis = Redis.from_url(config.REDIS_URL)

async def is_user_subscribed(bot: Bot, channel_id: int, user_id: int) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ–¥–ø–∏—Å–∫—É —Å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º –Ω–∞ 5 –º–∏–Ω—É—Ç.
    –ó–∞—â–∏—â–∞–µ—Ç –æ—Ç –æ—à–∏–±–∫–∏ 429 Too Many Requests.
    """
    cache_key = f"sub_status:{channel_id}:{user_id}"
    
    # 1. –ü—Ä–æ–±—É–µ–º –¥–æ—Å—Ç–∞—Ç—å –∏–∑ –∫–µ—à–∞
    cached = await redis.get(cache_key)
    if cached:
        return cached.decode() == "1"

    # 2. –ï—Å–ª–∏ –Ω–µ—Ç –≤ –∫–µ—à–µ ‚Äî —Å–ø—Ä–∞—à–∏–≤–∞–µ–º Telegram
    try:
        member = await bot.get_chat_member(channel_id, user_id)
        if member.status in ('creator', 'administrator', 'member', 'restricted'):
            # –ó–∞–ø–æ–º–∏–Ω–∞–µ–º "–ü–æ–¥–ø–∏—Å–∞–Ω" –Ω–∞ 5 –º–∏–Ω—É—Ç
            await redis.set(cache_key, "1", ex=300)
            return True
        else:
            # –ó–∞–ø–æ–º–∏–Ω–∞–µ–º "–ù–µ –ø–æ–¥–ø–∏—Å–∞–Ω" –Ω–∞ 1 –º–∏–Ω—É—Ç—É (–º–µ–Ω—å—à–µ, —á—Ç–æ–±—ã –±—ã—Å—Ç—Ä–µ–µ –æ–±–Ω–æ–≤–∏—Ç—å –µ—Å–ª–∏ –ø–æ–¥–ø–∏—à–µ—Ç—Å—è)
            await redis.set(cache_key, "0", ex=60)
            return False
    except Exception:
        # –ï—Å–ª–∏ –æ—à–∏–±–∫–∞ (–±–æ—Ç –Ω–µ –∞–¥–º–∏–Ω –∏–ª–∏ –±–∞–Ω API) - —Å—á–∏—Ç–∞–µ–º —á—Ç–æ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω, –Ω–µ –∫–µ—à–∏—Ä—É–µ–º –æ—à–∏–±–∫—É –Ω–∞–¥–æ–ª–≥–æ
        return False=== ./core/services/ref_service.py ===
import uuid
from redis.asyncio import Redis
from config import config

# –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ Redis (–∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—Ç –∂–µ URL, —á—Ç–æ –≤ –∫–æ–Ω—Ñ–∏–≥–µ)
redis = Redis.from_url(config.REDIS_URL)

async def create_ref_link(user_id: int) -> str:
    """
    –°–æ–∑–¥–∞–µ—Ç –∫–æ—Ä–æ—Ç–∫–∏–π UUID-—Ç–æ–∫–µ–Ω, –∫–æ—Ç–æ—Ä—ã–π —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π user_id.
    –¢–æ–∫–µ–Ω –∂–∏–≤–µ—Ç 30 –¥–Ω–µ–π.
    """
    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω (–±–µ–∑ —Ç–∏—Ä–µ, —á—Ç–æ–±—ã –±—ã–ª –∫–æ—Ä–æ—á–µ)
    token = uuid.uuid4().hex[:12] 
    key = f"ref_map:{token}"
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–µ—Ç —É —é–∑–µ—Ä–∞ —É–∂–µ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–π —Ç–æ–∫–µ–Ω (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ), 
    # –Ω–æ –ø—Ä–æ—â–µ –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤—ã–π –∏–ª–∏ —Ö—Ä–∞–Ω–∏—Ç—å –æ–±—Ä–∞—Ç–Ω—ã–π –∏–Ω–¥–µ–∫—Å.
    # –î–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏ –ø—Ä–æ—Å—Ç–æ –ø–∏—à–µ–º:
    await redis.set(key, user_id, ex=2592000) # 30 –¥–Ω–µ–π
    return token

async def resolve_ref_link(token: str) -> int | None:
    """–ü–æ–ª—É—á–∞–µ—Ç —Ä–µ–∞–ª—å–Ω—ã–π ID –ø–æ —Ç–æ–∫–µ–Ω—É"""
    key = f"ref_map:{token}"
    user_id = await redis.get(key)
    if user_id:
        return int(user_id)
    return None=== ./core/services/__init__.py ===
=== ./core/security/sanitizer.py ===
import bleach
from aiogram.types import Message

# –†–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–µ —Ç–µ–≥–∏ (Telegram API –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —ç—Ç–æ—Ç —Å–ø–∏—Å–æ–∫)
ALLOWED_TAGS = ['b', 'strong', 'i', 'em', 'u', 'ins', 's', 'strike', 'del', 'a', 'code', 'pre', 'blockquote', 'tg-spoiler']
ALLOWED_ATTRS = {'a': ['href']}

def sanitize_text(text: str) -> str:
    """–û—á–∏—â–∞–µ—Ç HTML –æ—Ç –º—É—Å–æ—Ä–∞, –æ—Å—Ç–∞–≤–ª—è—è –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ —Ç–µ–≥–∏ Telegram"""
    if not text:
        return ""
    return bleach.clean(text, tags=ALLOWED_TAGS, attributes=ALLOWED_ATTRS, strip=True)

def get_message_html(message: Message) -> str:
    """
    –ü—Ä–µ–≤—Ä–∞—â–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å entities (—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º Telegram) –≤ HTML-—Å—Ç—Ä–æ–∫—É.
    –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å—Å—ã–ª–∫–∏, –∂–∏—Ä–Ω—ã–π —Ç–µ–∫—Å—Ç –∏ —Ç.–¥.
    """
    text = message.text or message.caption
    if not text:
        return ""

    entities = message.entities or message.caption_entities
    if not entities:
        return text

    # Telegram –∏—Å–ø–æ–ª—å–∑—É–µ—Ç UTF-16 offsets
    utf16_text = text.encode("utf-16-le")
    html_text = ""
    last_offset = 0

    # –°–æ—Ä—Ç–∏—Ä—É–µ–º entities –ø–æ offset
    entities = sorted(entities, key=lambda e: e.offset)

    for entity in entities:
        if entity.offset < last_offset:
            continue
            
        start = entity.offset * 2
        end = (entity.offset + entity.length) * 2
        
        # –¢–µ–∫—Å—Ç –¥–æ —ç–Ω—Ç–∏—Ç–∏
        chunk = utf16_text[last_offset*2 : start].decode("utf-16-le")
        html_text += _escape(chunk)
        
        # –¢–µ–∫—Å—Ç –≤–Ω—É—Ç—Ä–∏ —ç–Ω—Ç–∏—Ç–∏
        inner_raw = utf16_text[start:end].decode("utf-16-le")
        inner = _escape(inner_raw)
        
        if entity.type == "bold":
            html_text += f"<b>{inner}</b>"
        elif entity.type == "italic":
            html_text += f"<i>{inner}</i>"
        elif entity.type == "underline":
            html_text += f"<u>{inner}</u>"
        elif entity.type == "strikethrough":
            html_text += f"<s>{inner}</s>"
        elif entity.type == "code":
            html_text += f"<code>{inner}</code>"
        elif entity.type == "pre":
            html_text += f"<pre>{inner}</pre>"
        elif entity.type == "text_link":
            html_text += f'<a href="{entity.url}">{inner}</a>'
        elif entity.type == "text_mention":
            html_text += f'<a href="tg://user?id={entity.user.id}">{inner}</a>'
        elif entity.type == "spoiler":
            html_text += f'<tg-spoiler>{inner}</tg-spoiler>'
        elif entity.type == "blockquote":
            html_text += f'<blockquote>{inner}</blockquote>'
        else:
            html_text += inner
            
        last_offset = entity.offset + entity.length

    # –û—Å—Ç–∞–≤—à–∏–π—Å—è —Ö–≤–æ—Å—Ç
    tail = utf16_text[last_offset*2:].decode("utf-16-le")
    html_text += _escape(tail)
    
    return html_text

def _escape(text: str) -> str:
    """–≠–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–ø–µ—Ü—Å–∏–º–≤–æ–ª–æ–≤ HTML"""
    return text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")=== ./core/security/hmac_signer.py ===
# core/security/hmac_signer.py
import hashlib
import hmac
from config import config

def _generate_hash(data_string: str) -> str:
    """–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ñ—É–Ω–∫—Ü–∏—è —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è"""
    return hmac.new(
        config.SECRET_KEY.encode(),
        data_string.encode(),
        hashlib.sha256
    ).hexdigest()[:12]  # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—ã–µ 12 —Å–∏–º–≤–æ–ª–æ–≤ –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞

def sign_data(action: str, entity_id: int, admin_id: int) -> str:
    """–°–æ–∑–¥–∞–µ—Ç –ø–æ–¥–ø–∏—Å—å: action + id + admin_id"""
    data = f"{action}:{entity_id}:{admin_id}"
    return _generate_hash(data)

def verify_signature(action: str, entity_id: int, admin_id: int, received_sig: str) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ–¥–ø–∏—Å—å. –ó–∞—â–∏—â–∞–µ—Ç –æ—Ç –ø–æ–¥–º–µ–Ω—ã ID –∏ User ID"""
    expected_sig = sign_data(action, entity_id, admin_id)
    return hmac.compare_digest(expected_sig, received_sig)=== ./core/__init__.py ===
=== ./core/logic/game_actions.py ===
# core/logic/game_actions.py
import asyncio
import secrets
from aiogram import Bot
from aiogram.client.default import DefaultBotProperties
from config import config
from database import async_session_maker
from database.requests.giveaway_repo import get_giveaway_by_id, get_active_giveaways, get_required_channels
from database.requests.participant_repo import get_participant_ids, get_participants_count
from database.models.winner import Winner  # <--- –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—É—é –º–æ–¥–µ–ª—å
from core.tools.formatters import format_giveaway_caption
from keyboards.inline.participation import join_keyboard, results_keyboard
from core.services.checker_service import is_user_subscribed  # <--- –ö–µ—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —á–µ–∫–µ—Ä

async def check_subscription_all(bot: Bot, user_id: int, main_channel_id: int, required_channels: list) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ–¥–ø–∏—Å–∫—É –Ω–∞ –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª –∏ –≤—Å–µ—Ö —Å–ø–æ–Ω—Å–æ—Ä–æ–≤.
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç Redis-–∫–µ—à, —á—Ç–æ–±—ã –Ω–µ –ø–æ–ª—É—á–∏—Ç—å –±–∞–Ω –æ—Ç Telegram API (429).
    """
    # 1. –û—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª
    if not await is_user_subscribed(bot, main_channel_id, user_id):
        return False

    # 2. –°–ø–æ–Ω—Å–æ—Ä—ã
    for req in required_channels:
        if not await is_user_subscribed(bot, req.channel_id, user_id):
            return False
    
    return True

async def finish_giveaway_task(giveaway_id: int):
    """
    –§–∏–Ω–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–æ–∑—ã–≥—Ä—ã—à–∞.
    """
    # –°–æ–∑–¥–∞–µ–º –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã–π –∏–Ω—Å—Ç–∞–Ω—Å –±–æ—Ç–∞ –¥–ª—è —ç—Ç–æ–π –∑–∞–¥–∞—á–∏
    bot = Bot(
        token=config.BOT_TOKEN.get_secret_value(),
        default=DefaultBotProperties(parse_mode="HTML")
    )
    
    try:
        bot_info = await bot.get_me()

        async with async_session_maker() as session:
            gw = await get_giveaway_by_id(session, giveaway_id)
            if not gw or gw.status != 'active':
                return

            all_participants = await get_participant_ids(session, giveaway_id)
            req_channels = await get_required_channels(session, giveaway_id)
            
            final_winner_ids = []
            
            # --- –≠–¢–ê–ü 1: –û–±—Ä–∞–±–æ—Ç–∫–∞ "–ø–æ–¥–∫—Ä—É—Ç–∫–∏" (Rigging) ---
            if gw.predetermined_winner_id and gw.predetermined_winner_id in all_participants:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–ø–∏—Å–∫—É —á–µ—Ä–µ–∑ –∫–µ—à
                if await check_subscription_all(bot, gw.predetermined_winner_id, gw.channel_id, req_channels):
                    final_winner_ids.append(gw.predetermined_winner_id)
                    # –£–¥–∞–ª—è–µ–º –∏–∑ –ø—É–ª–∞, —á—Ç–æ–±—ã –Ω–µ –≤—ã–∏–≥—Ä–∞–ª –¥–≤–∞–∂–¥—ã
                    if gw.predetermined_winner_id in all_participants:
                        all_participants.remove(gw.predetermined_winner_id)

            # --- –≠–¢–ê–ü 2: –ß–µ—Å—Ç–Ω—ã–π –≤—ã–±–æ—Ä –æ—Å—Ç–∞–ª—å–Ω—ã—Ö ---
            needed = gw.winners_count - len(final_winner_ids)
            
            # –£–¥–∞–ª—è–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–∏—Å—Ç–µ–º–Ω—ã–π —Ä–∞–Ω–¥–æ–º
            pool = list(set(all_participants))
            secrets.SystemRandom().shuffle(pool)

            while needed > 0 and pool:
                candidate = pool.pop() # –ë–µ—Ä–µ–º —Å–ª–µ–¥—É—é—â–µ–≥–æ
                
                # –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–æ–¥–ø–∏—Å–∫–∏
                if await check_subscription_all(bot, candidate, gw.channel_id, req_channels):
                    final_winner_ids.append(candidate)
                    needed -= 1
            
            # --- –≠–¢–ê–ü 3: –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏ –ü—É–±–ª–∏–∫–∞—Ü–∏—è ---
            
            gw.status = "finished"
            
            # –í–ê–ñ–ù–û: –ü–∏—à–µ–º –≤ —Ç–∞–±–ª–∏—Ü—É Winners, –∞ –Ω–µ –≤ —Å—Ç—Ä–æ–∫—É
            for uid in final_winner_ids:
                session.add(Winner(giveaway_id=gw.id, user_id=uid))
            
            await session.commit()
            
            # –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞
            if not final_winner_ids:
                result_text = (
                    "üòî <b>–†–æ–∑—ã–≥—Ä—ã—à –∑–∞–≤–µ—Ä—à–µ–Ω –±–µ–∑ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π.</b>\n\n"
                    "–í—Å–µ —É—á–∞—Å—Ç–Ω–∏–∫–∏ –æ—Ç–ø–∏—Å–∞–ª–∏—Å—å –æ—Ç –∫–∞–Ω–∞–ª–æ–≤."
                )
            else:
                mentions = []
                for idx, uid in enumerate(final_winner_ids, 1):
                    try:
                        chat = await bot.get_chat(uid)
                        
                        # -- –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ –õ–° (—Ç–∏—Ö–æ–µ, –µ—Å–ª–∏ –±–æ—Ç –≤ –±–∞–Ω–µ —É —é–∑–µ—Ä–∞, –Ω–µ —Å—Ç—Ä–∞—à–Ω–æ) --
                        try:
                            await bot.send_message(
                                uid, 
                                f"üéâ <b>–ü–û–ó–î–†–ê–í–õ–Ø–ï–ú!</b>\n\n"
                                f"–í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ –ø—Ä–∏–∑: <b>{gw.prize_text[:50]}...</b>\n"
                                f"–°–≤—è–∂–∏—Ç–µ—Å—å —Å –æ—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä–∞–º–∏!"
                            )
                        except: pass
                        # ---------------------------------

                        if chat.username:
                            user_link = f"@{chat.username}"
                        else:
                            user_link = f"<a href='tg://user?id={uid}'>{chat.full_name}</a>"
                        
                        mentions.append(f"{idx}. {user_link}")

                    except Exception:
                        mentions.append(f"{idx}. ID {uid}")

                winners_list_str = "\n".join(mentions)
                
                result_text = (
                    f"üéÅ <b>–†–û–ó–´–ì–†–´–® –ó–ê–í–ï–†–®–ï–ù!</b>\n\n"
                    f"üèÜ <b>–ü–æ–±–µ–¥–∏—Ç–µ–ª–∏:</b>\n"
                    f"{winners_list_str}\n\n"
                    f"üéâ <i>–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º —Å—á–∞—Å—Ç–ª–∏–≤—á–∏–∫–æ–≤!</i>"
                )

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ—Å—Ç —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –≤ –∫–∞–Ω–∞–ª
            try:
                await bot.send_message(
                    chat_id=gw.channel_id,
                    text=result_text,
                    reply_to_message_id=gw.message_id,
                    disable_web_page_preview=True
                )
                
                # –û–±–Ω–æ–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É –ø–æ–¥ –ø–æ—Å—Ç–æ–º –Ω–∞ "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã"
                await bot.edit_message_reply_markup(
                    chat_id=gw.channel_id,
                    message_id=gw.message_id,
                    reply_markup=results_keyboard(bot_info.username, giveaway_id)
                )
            except Exception as e:
                print(f"Error finishing GW {giveaway_id}: {e}")

    finally:
        await bot.session.close()


async def update_active_giveaways_task():
    """
    –§–æ–Ω–æ–≤–∞—è –∑–∞–¥–∞—á–∞: –æ–±–Ω–æ–≤–ª—è–µ—Ç —Å—á–µ—Ç—á–∏–∫–∏ (–£—á–∞—Å—Ç–Ω–∏–∫–æ–≤: X).
    """
    bot = Bot(
        token=config.BOT_TOKEN.get_secret_value(), 
        default=DefaultBotProperties(parse_mode="HTML")
    )
    
    try:
        bot_info = await bot.get_me()
        
        async with async_session_maker() as session:
            active_gws = await get_active_giveaways(session)
            
            for gw in active_gws:
                try:
                    count = await get_participants_count(session, gw.id)
                    
                    new_caption = format_giveaway_caption(
                        gw.prize_text, 
                        gw.winners_count, 
                        gw.finish_time, 
                        count
                    )
                    
                    kb = join_keyboard(bot_info.username, gw.id)

                    if gw.media_file_id:
                        await bot.edit_message_caption(
                            chat_id=gw.channel_id,
                            message_id=gw.message_id,
                            caption=new_caption,
                            reply_markup=kb
                        )
                    else:
                        await bot.edit_message_text(
                            chat_id=gw.channel_id,
                            message_id=gw.message_id,
                            text=new_caption,
                            reply_markup=kb,
                            disable_web_page_preview=True
                        )

                except Exception as e:
                    if "message is not modified" not in str(e).lower():
                        print(f"Skip update GW {gw.id}: {e}")
    finally:
        await bot.session.close()=== ./core/logic/ticket_gen.py ===
# core/logic/ticket_gen.py
import secrets
import string
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from database.models.participant import Participant

def generate_ticket_string(length=5) -> str:
    """–ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ —Å—Ç–æ–π–∫–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è"""
    chars = string.ascii_uppercase + string.digits
    # secrets.choice –±–µ–∑–æ–ø–∞—Å–Ω–µ–µ random.choice
    return ''.join(secrets.choice(chars) for _ in range(length))

async def get_unique_ticket(session: AsyncSession, giveaway_id: int) -> str:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –±–∏–ª–µ—Ç"""
    for _ in range(100):
        code = generate_ticket_string()
        stmt = select(Participant).where(
            Participant.giveaway_id == giveaway_id,
            Participant.ticket_code == code
        )
        existing = await session.scalar(stmt)
        if not existing:
            return code
    return "ERROR"=== ./core/logic/randomizer.py ===
# core/logic/randomizer.py
import secrets
from database.models.giveaway import Giveaway

def select_winners(giveaway: Giveaway, participant_ids: list[int]) -> list[int]:
    """
    –í—ã–±–∏—Ä–∞–µ—Ç –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π.
    1. –ï—Å–ª–∏ –µ—Å—Ç—å predetermined_winner_id - –æ–Ω –ø–æ–±–µ–∂–¥–∞–µ—Ç –ø–µ—Ä–≤—ã–º.
    2. –û—Å—Ç–∞–ª—å–Ω—ã–µ –≤—ã–±–∏—Ä–∞—é—Ç—Å—è —á–µ—Å—Ç–Ω—ã–º —Ä–∞–Ω–¥–æ–º–æ–º (SystemRandom).
    """
    winners = []
    pool = set(participant_ids) # –ò—Å–ø–æ–ª—å–∑—É–µ–º set –¥–ª—è —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏ –∏ O(1) —É–¥–∞–ª–µ–Ω–∏—è

    # 1. –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥–∫—Ä—É—Ç–∫–∏ (Rigging)
    if giveaway.predetermined_winner_id:
        if giveaway.predetermined_winner_id in pool:
            winners.append(giveaway.predetermined_winner_id)
            pool.remove(giveaway.predetermined_winner_id)
        # –ï—Å–ª–∏ "–±–ª–∞—Ç–Ω–æ–≥–æ" –Ω–µ—Ç –≤ —É—á–∞—Å—Ç–Ω–∏–∫–∞—Ö, –ø–æ–¥–∫—Ä—É—Ç–∫–∞ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç (–∑–∞—â–∏—Ç–∞ –æ—Ç –¥—É—Ä–∞–∫–∞)

    # 2. –°–∫–æ–ª—å–∫–æ –µ—â–µ –Ω—É–∂–Ω–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π?
    needed = giveaway.winners_count - len(winners)

    if needed > 0:
        pool_list = list(pool)
        if len(pool_list) <= needed:
            # –£—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –º–µ–Ω—å—à–µ, —á–µ–º –ø—Ä–∏–∑–æ–≤ -> –≤—Å–µ –ø–æ–±–µ–∂–¥–∞—é—Ç
            winners.extend(pool_list)
        else:
            # –ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ —Å—Ç–æ–π–∫–∏–π –≤—ã–±–æ—Ä
            random_winners = secrets.SystemRandom().sample(pool_list, k=needed)
            winners.extend(random_winners)

    return winners=== ./core/logic/exceptions.py ===
# core/logic/exceptions.py

class BotError(Exception):
    """–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –æ—à–∏–±–æ–∫ –±–æ—Ç–∞"""
    pass

class SecurityError(BotError):
    """–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∏ –∏–ª–∏ –ø—Ä–∞–≤"""
    pass

class GiveawayInvalidError(BotError):
    """–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–∞"""
    pass=== ./config.py ===
from typing import List
from pydantic_settings import BaseSettings
from pydantic import SecretStr, field_validator

class Settings(BaseSettings):
    BOT_TOKEN: SecretStr
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä, —á—Ç–æ–±—ã –ø—Ä–µ–≤—Ä–∞—â–∞—Ç—å —Å—Ç—Ä–æ–∫—É "123,456" –≤ —Å–ø–∏—Å–æ–∫ [123, 456]
    ADMIN_IDS: List[int]
    DB_DNS: str
    REDIS_URL: str
    SECRET_KEY: str

    @field_validator("ADMIN_IDS", mode="before")
    @classmethod
    def parse_admin_ids(cls, v):
        # –ï—Å–ª–∏ –ø—Ä–∏—à–ª–∞ —Å—Ç—Ä–æ–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä "123,456"), —Å–ø–ª–∏—Ç–∏–º –µ—ë
        if isinstance(v, str):
            # –£–¥–∞–ª—è–µ–º –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã–µ —Å–∫–æ–±–∫–∏ –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏—Ö –≤—Å–µ-—Ç–∞–∫–∏ –Ω–∞–ø–∏—Å–∞–ª
            v = v.replace("[", "").replace("]", "")
            if not v:
                return []
            return [int(x.strip()) for x in v.split(",")]
        # –ï—Å–ª–∏ –ø—Ä–∏—à–ª–æ —á–∏—Å–ª–æ (–æ–¥–∏–Ω –∞–¥–º–∏–Ω –±–µ–∑ –∫–∞–≤—ã—á–µ–∫ –∏ –∑–∞–ø—è—Ç—ã—Ö)
        if isinstance(v, int):
            return [v]
        return v

    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"

config = Settings()=== ./middlewares/throttling.py ===
# middlewares/throttling.py
import time
from typing import Callable, Awaitable, Dict, Any
from aiogram import BaseMiddleware
from aiogram.types import CallbackQuery
from redis.asyncio import Redis

class ThrottlingMiddleware(BaseMiddleware):
    def __init__(self, redis: Redis, rate_limit: float = 1.0):
        self.redis = redis
        self.rate_limit = rate_limit

    async def __call__(
        self,
        handler: Callable[[CallbackQuery, Dict[str, Any]], Awaitable[Any]],
        event: CallbackQuery,
        data: Dict[str, Any]
    ) -> Any:
        if not isinstance(event, CallbackQuery):
            return await handler(event, data)
            
        user_id = event.from_user.id
        key = f"throttle:{user_id}"
        
        # –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å–ª–∏ –∫–ª—é—á –µ—Å—Ç—å, –∑–Ω–∞—á–∏—Ç —Å–ø–∞–º
        if await self.redis.get(key):
            await event.answer("‚è≥ –ù–µ —Ç–∞–∫ –±—ã—Å—Ç—Ä–æ!", show_alert=True)
            return
            
        # –°—Ç–∞–≤–∏–º –∫–ª—é—á –Ω–∞ 1 —Å–µ–∫—É–Ω–¥—É
        await self.redis.set(key, "1", ex=int(self.rate_limit))
        
        return await handler(event, data)=== ./middlewares/role_check.py ===
=== ./middlewares/__init__.py ===
=== ./middlewares/db_session.py ===
# middlewares/db_session.py
from typing import Callable, Awaitable, Dict, Any
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject
from database import async_session_maker

class DbSessionMiddleware(BaseMiddleware):
    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any]
    ) -> Any:
        async with async_session_maker() as session:
            data["session"] = session
            return await handler(event, data)=== ./middlewares/admin_hmac.py ===
# middlewares/admin_hmac.py
from typing import Callable, Awaitable, Dict, Any
from aiogram import BaseMiddleware
from aiogram.types import CallbackQuery
from core.security.hmac_signer import verify_signature

class AdminSecurityMiddleware(BaseMiddleware):
    async def __call__(
        self,
        handler: Callable[[CallbackQuery, Dict[str, Any]], Awaitable[Any]],
        event: CallbackQuery,
        data: Dict[str, Any]
    ) -> Any:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ callback data
        if not isinstance(event, CallbackQuery) or not event.data:
            return await handler(event, data)

        # –ï—Å–ª–∏ –ø—Ä–µ—Ñ–∏–∫—Å 'adm', –∑–Ω–∞—á–∏—Ç —ç—Ç–æ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å
        # –§–æ—Ä–º–∞—Ç: adm:action:id:sig
        if event.data.startswith("adm:"):
            parts = event.data.split(":")
            if len(parts) != 4:
                await event.answer("‚ùå Broken data", show_alert=True)
                return
            
            _, action, entity_id, sig = parts
            admin_id = event.from_user.id
            
            # –ü–†–û–í–ï–†–ö–ê –ü–û–î–ü–ò–°–ò
            if not verify_signature(action, int(entity_id), admin_id, sig):
                print(f"[SECURITY ALERT] Bad Signature from user {admin_id}")
                await event.answer("‚õî Security Alert: Invalid Signature!", show_alert=True)
                return

        return await handler(event, data)=== ./main.py ===
import asyncio
import logging
from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from aiogram.fsm.storage.redis import RedisStorage
from redis.asyncio import Redis

from config import config
from database import engine, Base
from core.tools.scheduler import start_scheduler, scheduler
from core.logic.game_actions import update_active_giveaways_task

from middlewares.db_session import DbSessionMiddleware
from middlewares.admin_hmac import AdminSecurityMiddleware

# –ò–º–ø–æ—Ä—Ç—ã –†–æ—É—Ç–µ—Ä–æ–≤
from handlers.common import start
from handlers.participant import join
from handlers.super_admin import menu_main, list_view, manage_item, rig_winner
# –Æ–∑–µ—Ä –ü–∞–Ω–µ–ª—å
from handlers.user import dashboard, my_channels, my_participations, my_giveaways, premium
# –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä
from handlers.creator import constructor # –≠—Ç–æ —Ç–µ–ø–µ—Ä—å —Å—Å—ã–ª–∫–∞ –Ω–∞ –ø–∞–∫–µ—Ç (–ø–∞–ø–∫—É), –∫–æ—Ç–æ—Ä—ã–π –≤–µ—Ä–Ω–µ—Ç –æ–±—â–∏–π router
from handlers.creator import time_picker

async def main():
    logging.basicConfig(level=logging.INFO)
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ë–î
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    redis = Redis.from_url(config.REDIS_URL)
    bot = Bot(token=config.BOT_TOKEN.get_secret_value(), default=DefaultBotProperties(parse_mode="HTML"))
    dp = Dispatcher(storage=RedisStorage(redis=redis))

    # Middleware
    dp.update.middleware(DbSessionMiddleware())
    dp.callback_query.middleware(AdminSecurityMiddleware())

    # --- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –†–æ—É—Ç–µ—Ä–æ–≤ ---
    # 1. –ê–¥–º–∏–Ω–∫–∞
    dp.include_routers(menu_main.router, list_view.router, manage_item.router, rig_winner.router)

    # 2. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∞—è –ø–∞–Ω–µ–ª—å (–î–∞—à–±–æ—Ä–¥, –ö–∞–Ω–∞–ª—ã, –ú–æ–∏ –†–æ–∑—ã–≥—Ä—ã—à–∏, –ü—Ä–µ–º–∏—É–º, –£—á–∞—Å—Ç–∏—è)
    dp.include_router(dashboard.router)
    dp.include_router(my_channels.router)
    dp.include_router(my_giveaways.router) # –ù–æ–≤—ã–π
    dp.include_router(premium.router)      # –ù–æ–≤—ã–π
    dp.include_router(my_participations.router)
    
    # 3. –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä
    dp.include_router(time_picker.router)
    dp.include_router(constructor.router)

    # 4. –£—á–∞—Å—Ç–∏–µ –∏ –°—Ç–∞—Ä—Ç (–≤–∞–∂–µ–Ω –ø–æ—Ä—è–¥–æ–∫, start –ª–æ–≤–∏—Ç –¥–∏–ø–ª–∏–Ω–∫–∏)
    dp.include_router(join.router)
    dp.include_router(start.router)

    # –ó–∞–ø—É—Å–∫ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞
    scheduler.add_job(update_active_giveaways_task, "interval", minutes=30, id="global_updater", replace_existing=True)
    await start_scheduler()

    try:
        await dp.start_polling(bot)
    finally:
        await bot.session.close()
        await redis.aclose()

if __name__ == "__main__":
    asyncio.run(main())=== ./filters/is_admin.py ===
# filters/is_admin.py
from aiogram.filters import BaseFilter
from aiogram.types import Message, CallbackQuery
from config import config

class IsAdmin(BaseFilter):
    async def __call__(self, obj: Message | CallbackQuery) -> bool:
        # –†–∞–±–æ—Ç–∞–µ—Ç –∏ –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏–π, –∏ –¥–ª—è –∫–æ–ª–±—ç–∫–æ–≤
        user_id = obj.from_user.id
        return user_id in config.ADMIN_IDS=== ./filters/is_chat_member.py ===
# filters/is_chat_member.py
from aiogram.filters import BaseFilter
from aiogram.types import Message
from aiogram import Bot

class IsBotAdminInChat(BaseFilter):
    async def __call__(self, message: Message, bot: Bot) -> bool:
        if not message.forward_from_chat:
            return False
        
        chat_id = message.forward_from_chat.id
        try:
            member = await bot.get_chat_member(chat_id, bot.id)
            return member.status in ("administrator", "creator")
        except Exception:
            return False=== ./filters/__init__.py ===
=== ./database/models/channel.py ===
from sqlalchemy import BigInteger, String, ForeignKey
from sqlalchemy.orm import Mapped, mapped_column
from database.base import Base

class Channel(Base):
    __tablename__ = "channels"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.user_id"))
    channel_id: Mapped[int] = mapped_column(BigInteger)
    title: Mapped[str] = mapped_column(String)
    username: Mapped[str | None] = mapped_column(String, nullable=True)
    # –ù–û–í–û–ï –ü–û–õ–ï:
    invite_link: Mapped[str | None] = mapped_column(String, nullable=True)=== ./database/models/winner.py ===
from datetime import datetime
from sqlalchemy import BigInteger, ForeignKey, DateTime
from sqlalchemy.orm import Mapped, mapped_column
from database.base import Base

class Winner(Base):
    __tablename__ = "winners"

    giveaway_id: Mapped[int] = mapped_column(ForeignKey("giveaways.id"), primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.user_id"), primary_key=True)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)=== ./database/models/user.py ===
from datetime import datetime
from sqlalchemy import BigInteger, String, Boolean, DateTime
from sqlalchemy.orm import Mapped, mapped_column
from database.base import Base

class User(Base):
    __tablename__ = "users"

    user_id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=False)
    username: Mapped[str | None] = mapped_column(String, nullable=True)
    full_name: Mapped[str] = mapped_column(String)
    
    # --- Monetization ---
    is_premium: Mapped[bool] = mapped_column(Boolean, default=False)
    premium_until: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)

    def __repr__(self):
        return f"<User {self.user_id}>"=== ./database/models/giveaway.py ===
from datetime import datetime
from sqlalchemy import BigInteger, String, DateTime, Integer, Text, ForeignKey, Boolean
from sqlalchemy.orm import Mapped, mapped_column
from database.base import Base

class Giveaway(Base):
    __tablename__ = "giveaways"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    owner_id: Mapped[int] = mapped_column(ForeignKey("users.user_id"))
    channel_id: Mapped[int] = mapped_column(BigInteger)
    message_id: Mapped[int] = mapped_column(BigInteger)
    
    prize_text: Mapped[str] = mapped_column(Text)
    winners_count: Mapped[int] = mapped_column(Integer, default=1)
    finish_time: Mapped[datetime] = mapped_column(DateTime)
    
    status: Mapped[str] = mapped_column(String, default="active")
    predetermined_winner_id: Mapped[int | None] = mapped_column(BigInteger, nullable=True)

    media_file_id: Mapped[str | None] = mapped_column(String, nullable=True)
    media_type: Mapped[str | None] = mapped_column(String, nullable=True)
    
    # winner_ids –£–î–ê–õ–ï–ù–û. –¢–µ–ø–µ—Ä—å –¥–∞–Ω–Ω—ã–µ –≤ —Ç–∞–±–ª–∏—Ü–µ winners.

    is_referral_enabled: Mapped[bool] = mapped_column(Boolean, default=False)
    is_captcha_enabled: Mapped[bool] = mapped_column(Boolean, default=False)
    is_paid: Mapped[bool] = mapped_column(Boolean, default=False)=== ./database/models/participant.py ===
# database/models/participant.py
from datetime import datetime
from sqlalchemy import BigInteger, ForeignKey, DateTime, Integer, String
from sqlalchemy.orm import Mapped, mapped_column
from database.base import Base

class Participant(Base):
    __tablename__ = "participants"

    user_id: Mapped[int] = mapped_column(ForeignKey("users.user_id"), primary_key=True)
    giveaway_id: Mapped[int] = mapped_column(ForeignKey("giveaways.id"), primary_key=True)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

    # –ö–æ–ª-–≤–æ —à–∞–Ω—Å–æ–≤ (–±–∏–ª–µ—Ç–æ–≤)
    tickets_count: Mapped[int] = mapped_column(Integer, default=1) 
    
    # ID —Ç–æ–≥–æ, –∫—Ç–æ –ø—Ä–∏–≥–ª–∞—Å–∏–ª (—Ö—Ä–∞–Ω–∏–º —Ä–µ–∞–ª—å–Ω—ã–π ID, –∞ –Ω–µ —Ö–µ—à)
    referrer_id: Mapped[int | None] = mapped_column(BigInteger, nullable=True) 
    
    # –¢–µ–∫—Å—Ç–æ–≤—ã–π –∫–æ–¥ –±–∏–ª–µ—Ç–∞
    ticket_code: Mapped[str | None] = mapped_column(String(10), nullable=True)=== ./database/models/required_channel.py ===
from sqlalchemy import BigInteger, String, ForeignKey
from sqlalchemy.orm import Mapped, mapped_column
from database.base import Base

class GiveawayRequiredChannel(Base):
    __tablename__ = "giveaway_required_channels"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    giveaway_id: Mapped[int] = mapped_column(ForeignKey("giveaways.id"))
    
    channel_id: Mapped[int] = mapped_column(BigInteger) # ID –∫–∞–Ω–∞–ª–∞ —Å–ø–æ–Ω—Å–æ—Ä–∞
    channel_title: Mapped[str] = mapped_column(String)  # –ù–∞–∑–≤–∞–Ω–∏–µ (–¥–ª—è —Å–ø–∏—Å–∫–∞)
    channel_link: Mapped[str] = mapped_column(String)   # –°—Å—ã–ª–∫–∞ (username –∏–ª–∏ invite link)=== ./database/models/__init__.py ===
=== ./database/requests/user_repo.py ===
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func
from sqlalchemy.dialects.postgresql import insert
from database.models.user import User
from database.models.giveaway import Giveaway

async def register_user(session: AsyncSession, user_id: int, username: str, full_name: str):
    stmt = insert(User).values(
        user_id=user_id, username=username, full_name=full_name
    ).on_conflict_do_update(
        index_elements=['user_id'],
        set_=dict(username=username, full_name=full_name)
    )
    await session.execute(stmt)
    await session.commit()

async def get_user_stats(session: AsyncSession, user_id: int) -> dict:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–æ–∑–¥–∞—Ç–µ–ª—è"""
    # –°—á–∏—Ç–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∏
    active_stmt = select(func.count(Giveaway.id)).where(Giveaway.owner_id == user_id, Giveaway.status == "active")
    active = await session.scalar(active_stmt)
    
    # –°—á–∏—Ç–∞–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ
    finished_stmt = select(func.count(Giveaway.id)).where(Giveaway.owner_id == user_id, Giveaway.status == "finished")
    finished = await session.scalar(finished_stmt)
    
    return {"active": active or 0, "finished": finished or 0}=== ./database/requests/giveaway_repo.py ===
from datetime import datetime
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, desc, func
from database.models.giveaway import Giveaway
from database.models.required_channel import GiveawayRequiredChannel

async def create_giveaway(
    session: AsyncSession, owner_id: int, channel_id: int, 
    message_id: int, prize: str, winners: int, end_time: datetime,
    media_file_id: str = None, media_type: str = None,
    sponsors: list = None,
    is_referral: bool = False,
    is_captcha: bool = False
) -> int:
    new_gw = Giveaway(
        owner_id=owner_id, channel_id=channel_id, message_id=message_id,
        prize_text=prize, winners_count=winners, finish_time=end_time,
        media_file_id=media_file_id, media_type=media_type,
        is_referral_enabled=is_referral,
        is_captcha_enabled=is_captcha
    )
    session.add(new_gw)
    await session.flush()

    if sponsors:
        for sp in sponsors:
            req_ch = GiveawayRequiredChannel(
                giveaway_id=new_gw.id,
                channel_id=sp['id'],
                channel_title=sp['title'],
                channel_link=sp['link']
            )
            session.add(req_ch)

    await session.commit()
    return new_gw.id

async def get_giveaway_by_id(session: AsyncSession, gw_id: int) -> Giveaway | None:
    return await session.get(Giveaway, gw_id)

async def get_active_giveaways(session: AsyncSession):
    stmt = select(Giveaway).where(Giveaway.status == "active")
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_required_channels(session: AsyncSession, gw_id: int):
    stmt = select(GiveawayRequiredChannel).where(GiveawayRequiredChannel.giveaway_id == gw_id)
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_giveaways_by_owner(session: AsyncSession, owner_id: int, limit: int = 50):
    stmt = select(Giveaway).where(Giveaway.owner_id == owner_id)\
        .order_by(desc(Giveaway.id)).limit(limit)
    result = await session.execute(stmt)
    return result.scalars().all()

async def set_predetermined_winner(session: AsyncSession, gw_id: int, winner_id: int):
    stmt = update(Giveaway).where(Giveaway.id == gw_id).values(predetermined_winner_id=winner_id)
    await session.execute(stmt)
    await session.commit()

async def count_giveaways_by_owner(session: AsyncSession, owner_id: int) -> int:
    stmt = select(func.count(Giveaway.id)).where(Giveaway.owner_id == owner_id)
    return await session.scalar(stmt)

# --- –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø ---
async def count_giveaways_by_status(session: AsyncSession, owner_id: int, status: str) -> int:
    """–°—á–∏—Ç–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ —Å—Ç–∞—Ç—É—Å–∞ —É –≤–ª–∞–¥–µ–ª—å—Ü–∞"""
    stmt = select(func.count(Giveaway.id)).where(
        Giveaway.owner_id == owner_id,
        Giveaway.status == status
    )
    return await session.scalar(stmt)=== ./database/requests/channel_repo.py ===
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, delete
from sqlalchemy.dialects.postgresql import insert
from database.models.channel import Channel

async def add_channel(session: AsyncSession, user_id: int, channel_id: int, title: str, username: str | None, invite_link: str | None):
    """–î–æ–±–∞–≤–ª—è–µ—Ç –∫–∞–Ω–∞–ª —Å –∏–Ω–≤–∞–π—Ç-—Å—Å—ã–ª–∫–æ–π"""
    stmt = insert(Channel).values(
        user_id=user_id,
        channel_id=channel_id,
        title=title,
        username=username,
        invite_link=invite_link
    ).on_conflict_do_update(
        index_elements=['id'], # –ò–ª–∏ –ø–æ user_id+channel_id –µ—Å–ª–∏ –µ—Å—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–Ω–¥–µ–∫—Å
        set_=dict(title=title, username=username, invite_link=invite_link)
    )
    # –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º do_nothing –∏–ª–∏ update, –µ—Å–ª–∏ —Ö–æ—Ç–∏–º –æ–±–Ω–æ–≤–ª—è—Ç—å –Ω–∞–∑–≤–∞–Ω–∏—è
    # –ù–æ —Ç–∞–∫ –∫–∞–∫ —É –Ω–∞—Å –Ω–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω–æ–≥–æ –∫–æ–Ω—Å—Ç—Ä–µ–π–Ω—Ç–∞ –≤ –º–æ–¥–µ–ª–∏ (–∫—Ä–æ–º–µ id), –ª—É—á—à–µ —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å
    # –í —Ä–∞–º–∫–∞—Ö —ç—Ç–æ–≥–æ –∫–æ–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Å—Ç—É—é –≤—Å—Ç–∞–≤–∫—É —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –Ω–∞ –¥—É–±–ª–∏ –≤ –ª–æ–≥–∏–∫–µ –∏–ª–∏ —Ç—É—Ç:
    
    # –ü—Ä–æ–≤–µ—Ä–∏–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ —Ç–∞–∫–æ–π –∫–∞–Ω–∞–ª —É —é–∑–µ—Ä–∞
    check_stmt = select(Channel).where(Channel.user_id == user_id, Channel.channel_id == channel_id)
    existing = await session.scalar(check_stmt)
    
    if existing:
        existing.title = title
        existing.username = username
        existing.invite_link = invite_link
    else:
        session.add(Channel(
            user_id=user_id, 
            channel_id=channel_id, 
            title=title, 
            username=username, 
            invite_link=invite_link
        ))
    
    await session.commit()

async def get_user_channels(session: AsyncSession, user_id: int):
    stmt = select(Channel).where(Channel.user_id == user_id)
    result = await session.execute(stmt)
    return result.scalars().all()

async def delete_channel_by_id(session: AsyncSession, db_id: int, user_id: int):
    stmt = delete(Channel).where(Channel.id == db_id, Channel.user_id == user_id)
    await session.execute(stmt)
    await session.commit()=== ./database/requests/participant_repo.py ===
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, desc
from sqlalchemy.dialects.postgresql import insert
from database.models.participant import Participant
from database.models.giveaway import Giveaway
from database.models.winner import Winner # <---

async def add_participant(session: AsyncSession, user_id: int, giveaway_id: int) -> bool:
    stmt = insert(Participant).values(user_id=user_id, giveaway_id=giveaway_id).on_conflict_do_nothing()
    result = await session.execute(stmt)
    await session.commit()
    return result.rowcount > 0

async def get_participant_ids(session: AsyncSession, giveaway_id: int) -> list[int]:
    stmt = select(Participant.user_id).where(Participant.giveaway_id == giveaway_id)
    result = await session.execute(stmt)
    return list(result.scalars().all())

async def get_participants_count(session: AsyncSession, giveaway_id: int) -> int:
    stmt = select(func.count(Participant.user_id)).where(Participant.giveaway_id == giveaway_id)
    return await session.scalar(stmt)

async def get_user_participation_stats(session: AsyncSession, user_id: int) -> dict:
    # 1. –ê–∫—Ç–∏–≤–Ω—ã–µ
    active_q = select(func.count(Participant.giveaway_id)).join(Giveaway).where(
        Participant.user_id == user_id,
        Giveaway.status == "active"
    )
    active = await session.scalar(active_q)
    
    # 2. –ü–æ–±–µ–¥—ã (–¢–µ–ø–µ—Ä—å —á–µ—Ä–µ–∑ —Ç–∞–±–ª–∏—Ü—É Winner - –±—ã—Å—Ç—Ä–æ –∏ –Ω–∞–¥–µ–∂–Ω–æ)
    wins_q = select(func.count(Winner.giveaway_id)).where(Winner.user_id == user_id)
    wins = await session.scalar(wins_q)

    return {"active": active or 0, "wins": wins or 0}

async def get_user_participations_detailed(session: AsyncSession, user_id: int, status: str = None, limit: int = 5, offset: int = 0):
    stmt = select(Giveaway).join(Participant).where(Participant.user_id == user_id)
    if status:
        stmt = stmt.where(Giveaway.status == status)
    stmt = stmt.order_by(desc(Giveaway.finish_time)).limit(limit).offset(offset)
    result = await session.execute(stmt)
    return result.scalars().all()

async def count_user_participations(session: AsyncSession, user_id: int, status: str = None) -> int:
    stmt = select(func.count(Giveaway.id)).join(Participant).where(Participant.user_id == user_id)
    if status:
        stmt = stmt.where(Giveaway.status == status)
    return await session.scalar(stmt)=== ./database/requests/__init__.py ===
=== ./database/__init__.py ===
# database/__init__.py
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from config import config
from .base import Base
# –ò–º–ø–æ—Ä—Ç –º–æ–¥–µ–ª–µ–π
from .models.user import User
from .models.giveaway import Giveaway
from .models.participant import Participant
from .models.channel import Channel
from .models.required_channel import GiveawayRequiredChannel
from .models.winner import Winner # <--- –ù–û–í–û–ï

engine = create_async_engine(
    url=config.DB_DNS,
    echo=False,
    pool_pre_ping=True
)

async_session_maker = async_sessionmaker(
    engine, 
    class_=AsyncSession, 
    expire_on_commit=False
)=== ./database/base.py ===
from sqlalchemy.orm import DeclarativeBase

class Base(DeclarativeBase):
    pass=== ./handlers/creator/constructor/publication.py ===
from datetime import datetime
from aiogram import Router, types, F, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
import logging

from database.requests.giveaway_repo import create_giveaway
from keyboards.inline.constructor import constructor_main_kb
from keyboards.inline.participation import join_keyboard
from core.tools.scheduler import scheduler
from core.logic.game_actions import finish_giveaway_task
from core.tools.formatters import format_giveaway_caption
from core.tools.timezone import to_utc, strip_tz
from handlers.creator.constructor.control_message import get_control_hint, update_control_message
from handlers.creator.constructor.message_manager import get_message_manager, update_message_manager

logger = logging.getLogger(__name__)

router = Router()

async def send_preview(message: types.Message, state: FSMContext, is_edit: bool = False):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –ë–ï–ó –∫–Ω–æ–ø–æ–∫"""
    data = await state.get_data()
    
    finish_dt = datetime.fromisoformat(data['finish_time_str'])
    date_str = finish_dt.strftime('%d.%m %H:%M –ú–°–ö')
    
    caption = f"{data['text']}\n\n<i>(–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä. –ò—Ç–æ–≥–∏: {date_str})</i>"
    
    if is_edit:
        try:
            if data['media_type']: 
                await message.edit_caption(caption=caption)  # –ë–µ–∑ reply_markup
            else: 
                await message.edit_text(text=caption)  # –ë–µ–∑ reply_markup
            return
        except: 
            await message.delete()

    if data['media_type'] == 'photo': 
        msg = await message.answer_photo(data['media_file_id'], caption=caption)  # –ë–µ–∑ reply_markup
        logger.info(f"PREVIEW: Created photo preview")
    elif data['media_type'] == 'video': 
        msg = await message.answer_video(data['media_file_id'], caption=caption)  # –ë–µ–∑ reply_markup
        logger.info(f"PREVIEW: Created video preview")
    elif data['media_type'] == 'animation': 
        msg = await message.answer_animation(data['media_file_id'], caption=caption)  # –ë–µ–∑ reply_markup
        logger.info(f"PREVIEW: Created animation preview")
    else: 
        msg = await message.answer(text=caption)  # –ë–µ–∑ reply_markup
        logger.info(f"PREVIEW: Created text preview")
    
    return msg

@router.callback_query(F.data == "constr_publish")
async def publish_giveaway(call: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    logger.info("PUBLISH: Publishing giveaway")
    
    data = await state.get_data()
    
    # –í–∞–ª–∏–¥–∞—Ü–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
    errors = []
    
    if not data.get('text'):
        errors.append("‚Ä¢ –ù–µ —É–∫–∞–∑–∞–Ω —Ç–µ–∫—Å—Ç —Ä–æ–∑—ã–≥—Ä—ã—à–∞")
    
    if not data.get('main_channel'):
        errors.append("‚Ä¢ –ù–µ –≤—ã–±—Ä–∞–Ω –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª")
    
    if not data.get('winners') or data['winners'] < 1 or data['winners'] > 50:
        errors.append("‚Ä¢ –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π (1-50)")
    
    if data.get('ref_req') and data['ref_req'] > 10:
        errors.append("‚Ä¢ –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –¥—Ä—É–∑–µ–π –¥–ª—è —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã (–º–∞–∫—Å. 10)")
    
    if errors:
        error_text = "‚ùå –ü–µ—Ä–µ–¥ –ø—É–±–ª–∏–∫–∞—Ü–∏–µ–π –Ω—É–∂–Ω–æ –∏—Å–ø—Ä–∞–≤–∏—Ç—å:\n" + "\n".join(errors)
        return await call.answer(error_text, show_alert=True)
    
    if not data.get('main_channel'): return await call.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–Ω–∞–ª!", show_alert=True)
    
    main_ch = data['main_channel']
    finish_dt_msk = datetime.fromisoformat(data['finish_time_str'])
    finish_dt_utc = to_utc(finish_dt_msk)
    finish_dt_db = strip_tz(finish_dt_utc) 
    
    bot_info = await bot.get_me()
    caption = format_giveaway_caption(data['text'], data['winners'], finish_dt_utc, 0)
    keyboard = join_keyboard(bot_info.username, 0)
    
    try:
        if data['media_type'] == 'photo':
            msg = await bot.send_photo(main_ch['id'], data['media_file_id'], caption=caption, reply_markup=keyboard)
            logger.info(f"PUBLISH: Sent photo to channel {main_ch['id']}")
        elif data['media_type'] == 'video':
            msg = await bot.send_video(main_ch['id'], data['media_file_id'], caption=caption, reply_markup=keyboard)
            logger.info(f"PUBLISH: Sent video to channel {main_ch['id']}")
        else:
            msg = await bot.send_message(main_ch['id'], text=caption, reply_markup=keyboard)
            logger.info(f"PUBLISH: Sent message to channel {main_ch['id']}")
    except Exception as e:
        return await call.answer(f"–û—à–∏–±–∫–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –≤ –æ—Å–Ω–æ–≤–Ω–æ–π: {e}", show_alert=True)

    gw_id = await create_giveaway(
        session, call.from_user.id, main_ch['id'], msg.message_id, 
        data['text'], data['winners'], finish_dt_db,
        data['media_file_id'], data['media_type'], 
        data['sponsors'], 
        is_referral=(data['ref_req'] > 0), 
        is_captcha=data['is_captcha']
    )

    await bot.edit_message_reply_markup(chat_id=main_ch['id'], message_id=msg.message_id, reply_markup=join_keyboard(bot_info.username, gw_id))
    
    for sp in data['sponsors']:
        try:
            await bot.forward_message(chat_id=sp['id'], from_chat_id=main_ch['id'], message_id=msg.message_id)
            logger.info(f"FORWARD: Forwarded to sponsor {sp['id']}")
        except: pass

    scheduler.add_job(finish_giveaway_task, "date", run_date=finish_dt_utc, kwargs={"giveaway_id": gw_id}, id=f"gw_{gw_id}", replace_existing=True)
    
    # –ü–æ–ª—É—á–∞–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä —Å–æ–æ–±—â–µ–Ω–∏–π
    manager = await get_message_manager(state)
    
    # –£–¥–∞–ª—è–µ–º –æ–±–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞ (Preview + Control)
    message_ids = manager.get_all_messages_to_delete()
    for msg_id in message_ids:
        try:
            logger.info(f"DELETE: Constructor message {msg_id} (publish)")
            await bot.delete_message(call.message.chat.id, msg_id)
        except Exception as e:
            logger.warning(f"WARNING: Failed to delete message {msg_id}: {e}")
    
    link = main_ch['link'] if main_ch['link'] != 'private' else "–∫–∞–Ω–∞–ª"
    success_msg = await call.message.answer(
        f"‚úÖ <b>–û–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–æ!</b>\n<a href='{link}'>–ü–µ—Ä–µ–π—Ç–∏ –∫ –ø–æ—Å—Ç—É</a>\n\nüèÜ –ü–æ–±–µ–¥–∏—Ç–µ–ª–µ–π: {data['winners']}", 
        disable_web_page_preview=True
    )
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º ID —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± —É—Å–ø–µ—Ö–µ –∫–∞–∫ –≤—Ä–µ–º–µ–Ω–Ω–æ–µ
    manager.add_temp_message(success_msg)
    await update_message_manager(state, manager)
    
    # –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    await state.clear()=== ./handlers/creator/constructor/referral_selector.py ===
from aiogram import Router, types, F
from aiogram.fsm.context import FSMContext
from keyboards.inline.constructor import referral_selector_kb
from handlers.creator.constructor.publication import send_preview
from handlers.creator.constructor.structure import ConstructorState

router = Router()

@router.callback_query(F.data == "constr_ref_menu")
async def ref_menu(call: types.CallbackQuery):
    await call.message.edit_reply_markup(reply_markup=referral_selector_kb())

@router.callback_query(F.data.startswith("constr_set_ref:"))
async def set_ref(call: types.CallbackQuery, state: FSMContext):
    try:
        ref_count = int(call.data.split(":")[-1])
        await state.update_data(ref_req=ref_count)
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–µ–≤—å—é
        await send_preview(call.message, state, is_edit=True)
        
        ref_text = "–í—ã–∫–ª—é—á–µ–Ω–æ" if ref_count == 0 else f"{ref_count} –¥—Ä—É–∑–µ–π"
        await call.answer(f"‚úÖ –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞: {ref_text}")
        
    except ValueError:
        await call.answer("‚ùå –û—à–∏–±–∫–∞ –≤—ã–±–æ—Ä–∞", show_alert=True)
    except Exception as e:
        await call.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞", show_alert=True)
        print(f"Error in set_ref: {e}")

@router.message(ConstructorState.editing_referral)
async def process_referral_input(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤ –≤—Ä—É—á–Ω—É—é"""
    try:
        text = message.text.strip()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤–≤–µ–¥–µ–Ω–æ —á–∏—Å–ª–æ
        if not text.isdigit():
            return await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ –æ—Ç 0 –¥–æ 10")
        
        ref_count = int(text)
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω
        if ref_count < 0 or ref_count > 10:
            return await message.answer("‚ùå –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥—Ä—É–∑–µ–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 0 –¥–æ 10")
        
        await state.update_data(ref_req=ref_count)
        
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ –ø—Ä–µ–≤—å—é
        await state.set_state(ConstructorState.init)
        await send_preview(message, state)
        
        await message.answer(f"‚úÖ –¢—Ä–µ–±—É–µ—Ç—Å—è –¥—Ä—É–∑–µ–π: {ref_count}")
        
    except Exception as e:
        print(f"Error in process_referral_input: {e}")
        await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")

@router.callback_query(F.data == "constr_set_ref_input")
async def ask_referral_input(call: types.CallbackQuery, state: FSMContext):
    """–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –≤–≤–µ—Å—Ç–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤ –≤—Ä—É—á–Ω—É—é"""
    await state.set_state(ConstructorState.editing_referral)
    await call.message.edit_text("üîó <b>–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥—Ä—É–∑–µ–π</b> (0-10):")=== ./handlers/creator/constructor/channels_add.py ===
from aiogram import Router, types, F, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder

from database.requests.channel_repo import add_channel
from keyboards.inline.dashboard import skip_link_kb
from handlers.creator.constructor.structure import ConstructorState
from handlers.creator.constructor.channels_select import show_channels_selection
from handlers.creator.constructor.message_manager import get_message_manager, update_message_manager
import logging

logger = logging.getLogger(__name__)

router = Router()

@router.callback_query(F.data == "add_new_channel_constr")
async def ask_channel_constr(call: types.CallbackQuery, state: FSMContext):
    logger.info("ADD_CHANNEL: Started adding new channel")
    
    await state.set_state(ConstructorState.adding_channel)
    
    # –ü–æ–ª—É—á–∞–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä —Å–æ–æ–±—â–µ–Ω–∏–π
    manager = await get_message_manager(state)
    manager.add_temp_message(call.message)
    await update_message_manager(state, manager)
    
    await call.message.delete()
    
    kb = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_to_selector")]])
    new_msg = await call.message.answer("üì¢ –ü–µ—Ä–µ—à–ª–∏—Ç–µ –ø–æ—Å—Ç –∏–∑ –∫–∞–Ω–∞–ª–∞ (–∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ @username):", reply_markup=kb)
    logger.info(f"ADD_CHANNEL: Created temp message {new_msg.message_id}")
    manager.add_temp_message(new_msg)
    await update_message_manager(state, manager)

# --- –õ–û–ì–ò–ö–ê –û–¢–ú–ï–ù–´ ---
@router.callback_query(F.data == "cancel_to_selector")
async def cancel_to_selector(call: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    logger.info("ADD_CHANNEL: Cancelled adding channel")
    
    # –ü–æ–ª—É—á–∞–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä —Å–æ–æ–±—â–µ–Ω–∏–π
    manager = await get_message_manager(state)
    
    # –û—á–∏—â–∞–µ–º –í–°–ï –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    await state.update_data(
        temp_channel=None, 
        generated_link=None,
        channel_selector_mode=None
    )
    
    # –£–¥–∞–ª—è–µ–º –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è
    message_ids = manager.get_all_messages_to_delete()
    for msg_id in message_ids:
        try:
            logger.info(f"ADD_CHANNEL: Deleting message {msg_id}")
            await bot.delete_message(call.message.chat.id, msg_id)
        except Exception as e:
            logger.warning(f"ADD_CHANNEL: Failed to delete message {msg_id}: {e}")
    
    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ –º–µ–Ω—é –≤—ã–±–æ—Ä–∞
    await state.set_state(ConstructorState.init)
    
    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–ø–∏—Å–æ–∫ —Å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ–º
    data = await state.get_data()
    mode = data.get('channel_selector_mode', 'main')
    
    if mode == 'main':
        await show_channels_selection(call.message, state, session, call.from_user.id, "main", "‚ùå –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ. –í—ã–±–µ—Ä–∏—Ç–µ –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª:")
    else:
        await show_channels_selection(call.message, state, session, call.from_user.id, "sponsor", "‚ùå –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ. –í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ–Ω—Å–æ—Ä–æ–≤:")

@router.message(ConstructorState.adding_channel)
async def process_new_channel_step1_constr(message: types.Message, state: FSMContext, bot: Bot):
    logger.info("ADD_CHANNEL: Processing new channel step 1")
    
    # –ü–æ–ª—É—á–∞–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä —Å–æ–æ–±—â–µ–Ω–∏–π
    manager = await get_message_manager(state)
    manager.add_temp_message(message)
    await update_message_manager(state, manager)
    
    chat_id, title, username = None, "Title", None
    kb_cancel = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_to_selector")]])

    if message.forward_from_chat:
        chat_id = message.forward_from_chat.id
        title = message.forward_from_chat.title
        username = message.forward_from_chat.username
    elif message.text and message.text.startswith("@"):
        try:
            chat = await bot.get_chat(message.text)
            chat_id = chat.id
            title = chat.title
            username = chat.username
        except: 
            return await message.answer("‚ùå –ö–∞–Ω–∞–ª –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ @username.", reply_markup=kb_cancel)
    
    if not chat_id: 
        return await message.answer("‚ùå –û—à–∏–±–∫–∞. –ü–µ—Ä–µ—à–ª–∏—Ç–µ –ø–æ—Å—Ç –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ @username.", reply_markup=kb_cancel)

    try:
        member = await bot.get_chat_member(chat_id, bot.id)
        if member.status not in ("administrator", "creator"): 
            raise Exception("Bot is not admin")
    except: 
        return await message.answer("‚ùå –°–¥–µ–ª–∞–π—Ç–µ –±–æ—Ç–∞ –∞–¥–º–∏–Ω–æ–º –≤ –∫–∞–Ω–∞–ª–µ!", reply_markup=kb_cancel)

    # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Å—ã–ª–∫–∏
    generated_link = None
    try:
        invite = await bot.create_chat_invite_link(chat_id, name="RozPlay Bot")
        generated_link = invite.invite_link
    except Exception as e:
        logger.warning(f"ADD_CHANNEL: Failed to generate invite link: {e}")
        generated_link = f"https://t.me/{username}" if username else None

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤–æ –≤—Ä–µ–º–µ–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ (–ï–©–ï –ù–ï –í –ë–î)
    await state.update_data(
        temp_channel={"id": chat_id, "title": title, "username": username},
        generated_link=generated_link
    )
    await state.set_state(ConstructorState.adding_channel_link)
    
    text = f"‚úÖ –ö–∞–Ω–∞–ª <b>{title}</b> –Ω–∞–π–¥–µ–Ω.\n"
    kb_builder = InlineKeyboardBuilder()
    if generated_link:
        text += f"\nüîó –Ø —Å–æ–∑–¥–∞–ª —Å—Å—ã–ª–∫—É: {generated_link}\n–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ—ë?"
        kb_builder.button(text="‚úÖ –î–∞, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å", callback_data="use_generated_link")
    else:
        text += "\nüîó –ü—Ä–∏—à–ª–∏—Ç–µ –∏–Ω–≤–∞–π—Ç-—Å—Å—ã–ª–∫—É –≤—Ä—É—á–Ω—É—é:"
        
    kb_builder.button(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_to_selector")
    kb_builder.adjust(1)
    
    new_msg = await message.answer(text, reply_markup=kb_builder.as_markup())
    logger.info(f"ADD_CHANNEL: Created temp message {new_msg.message_id}")
    manager.add_temp_message(new_msg)
    await update_message_manager(state, manager)

@router.callback_query(ConstructorState.adding_channel_link, F.data == "use_generated_link")
async def use_gen_link_callback(call: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    logger.info("ADD_CHANNEL: Using generated link")
    
    try:
        data = await state.get_data()
        ch_data = data['temp_channel']
        link = data.get('generated_link')
        
        if not ch_data or not link:
            await call.answer("‚ùå –û—à–∏–±–∫–∞ –¥–∞–Ω–Ω—ã—Ö. –ù–∞—á–Ω–∏—Ç–µ —Å–Ω–∞—á–∞–ª–∞.", show_alert=True)
            await state.set_state(ConstructorState.init)
            return

        # –í–û–¢ –ó–î–ï–°–¨ –ü–†–û–ò–°–•–û–î–ò–¢ –°–û–•–†–ê–ù–ï–ù–ò–ï –í –ë–î
        await add_channel(session, call.from_user.id, ch_data['id'], ch_data['title'], ch_data['username'], link)
        
        await state.set_state(ConstructorState.init)
        await call.message.delete()
        
        # –ü–æ–ª—É—á–∞–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä —Å–æ–æ–±—â–µ–Ω–∏–π
        manager = await get_message_manager(state)
        
        # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
        message_ids = manager.get_all_messages_to_delete()
        for msg_id in message_ids:
            try:
                logger.info(f"ADD_CHANNEL: Deleting message {msg_id}")
                await bot.delete_message(call.message.chat.id, msg_id)
            except Exception as e:
                logger.warning(f"ADD_CHANNEL: Failed to delete message {msg_id}: {e}")
        
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤
        data = await state.get_data()
        mode = data.get('channel_selector_mode', 'main')
        
        if mode == 'main':
            await show_channels_selection(call.message, state, session, call.from_user.id, "main", f"‚úÖ –ö–∞–Ω–∞–ª <b>{ch_data['title']}</b> –¥–æ–±–∞–≤–ª–µ–Ω! –í—ã–±–µ—Ä–∏—Ç–µ –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª:")
        else:
            await show_channels_selection(call.message, state, session, call.from_user.id, "sponsor", f"‚úÖ –ö–∞–Ω–∞–ª <b>{ch_data['title']}</b> –¥–æ–±–∞–≤–ª–µ–Ω! –í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ–Ω—Å–æ—Ä–æ–≤:")
        
    except Exception as e:
        logger.error(f"ADD_CHANNEL: Error in use_gen_link_callback: {e}")
        await call.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.", show_alert=True)
        await state.set_state(ConstructorState.init)

@router.message(ConstructorState.adding_channel_link)
async def process_link_text_constr(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    logger.info("ADD_CHANNEL: Processing link text")
    
    # –ü–æ–ª—É—á–∞–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä —Å–æ–æ–±—â–µ–Ω–∏–π
    manager = await get_message_manager(state)
    manager.add_temp_message(message)
    await update_message_manager(state, manager)
    
    link = message.text.strip()
    
    # –í–∞–ª–∏–¥–∞—Ü–∏—è —Å—Å—ã–ª–∫–∏
    if "t.me" not in link and not link.startswith("https://"):
        return await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Å—ã–ª–∫—É (–¥–æ–ª–∂–Ω–∞ —Å–æ–¥–µ—Ä–∂–∞—Ç—å t.me –∏–ª–∏ –±—ã—Ç—å –ø–æ–ª–Ω–æ–π —Å—Å—ã–ª–∫–æ–π).")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Å—ã–ª–∫–∞ –±–æ—Ç–æ–º
    if "bot" in link.lower():
        return await message.answer("‚ùå –°—Å—ã–ª–∫–∞ –Ω–µ –¥–æ–ª–∂–Ω–∞ –≤–µ—Å—Ç–∏ –Ω–∞ –±–æ—Ç–∞!")
        
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–ª–∏–Ω—É —Å—Å—ã–ª–∫–∏
    if len(link) > 255:
        return await message.answer("‚ùå –°—Å—ã–ª–∫–∞ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–∞—è!")
    
    data = await state.get_data()
    ch_data = data.get('temp_channel')
    if not ch_data:
        return await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ù–∞—á–Ω–∏—Ç–µ —Å–Ω–∞—á–∞–ª–∞.")
    
    try:
        # –í–û–¢ –ó–î–ï–°–¨ –ü–†–û–ò–°–•–û–î–ò–¢ –°–û–•–†–ê–ù–ï–ù–ò–ï –í –ë–î
        await add_channel(session, message.from_user.id, ch_data['id'], ch_data['title'], ch_data['username'], link)
        
        try: 
            await message.delete()
        except: 
            pass
        
        await state.set_state(ConstructorState.init)
        
        # –ü–æ–ª—É—á–∞–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä —Å–æ–æ–±—â–µ–Ω–∏–π
        manager = await get_message_manager(state)
        
        # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
        message_ids = manager.get_all_messages_to_delete()
        for msg_id in message_ids:
            try:
                logger.info(f"ADD_CHANNEL: Deleting message {msg_id}")
                await bot.delete_message(message.chat.id, msg_id)
            except Exception as e:
                logger.warning(f"ADD_CHANNEL: Failed to delete message {msg_id}: {e}")
        
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤
        data = await state.get_data()
        mode = data.get('channel_selector_mode', 'main')
        
        if mode == 'main':
            await show_channels_selection(message, state, session, message.from_user.id, "main", f"‚úÖ –ö–∞–Ω–∞–ª <b>{ch_data['title']}</b> –¥–æ–±–∞–≤–ª–µ–Ω! –í—ã–±–µ—Ä–∏—Ç–µ –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª:")
        else:
            await show_channels_selection(message, state, session, message.from_user.id, "sponsor", f"‚úÖ –ö–∞–Ω–∞–ª <b>{ch_data['title']}</b> –¥–æ–±–∞–≤–ª–µ–Ω! –í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ–Ω—Å–æ—Ä–æ–≤:")
        
    except Exception as e:
        logger.error(f"ADD_CHANNEL: Error in process_link_text_constr: {e}")
        await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")=== ./handlers/creator/constructor/start_content.py ===
from datetime import datetime, timedelta
from aiogram import Router, types, F, Bot
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
import logging

from core.security.sanitizer import sanitize_text, get_message_html
from keyboards.inline.dashboard import start_menu_kb
from core.tools.timezone import get_now_msk
from handlers.creator.constructor.structure import ConstructorState, safe_edit_to_text
from handlers.creator.constructor.publication import send_preview
from handlers.creator.constructor.control_message import (
    send_initial_control_message, 
    update_control_message,
    get_control_hint
)
from handlers.creator.constructor.message_manager import get_message_manager, update_message_manager
from keyboards.inline.constructor import constructor_main_kb

logger = logging.getLogger(__name__)

router = Router()

@router.callback_query(F.data == "create_gw_init")
@router.message(Command("new"))
async def start_constructor(event: types.Message | types.CallbackQuery, state: FSMContext):
    logger.info("START: Constructor initialized")
    
    # –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏ —Å–æ–æ–±—â–µ–Ω–∏—è
    await state.clear()
    
    default_finish = get_now_msk() + timedelta(hours=24)
    default_data = {
        "text": None, "media_file_id": None, "media_type": None,
        "main_channel": None, "sponsors": [],
        "finish_time_str": default_finish.isoformat(),
        "winners": 1, 
        "ref_req": 0, 
        "is_captcha": False,
        "message_manager_data": {}  # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—É—Å—Ç—ã–º —Å–ª–æ–≤–∞—Ä–µ–º
    }
    await state.set_data(default_data)
    await state.set_state(ConstructorState.editing_content)
    
    # –¢–µ–∫—Å—Ç –¥–ª—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏
    instruction_text = await get_control_hint('content')
    
    kb = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_creation")]])
    
    if isinstance(event, types.CallbackQuery): 
        await safe_edit_to_text(event.message, instruction_text, kb)
    else: 
        # –ó–∞–ø–æ–º–∏–Ω–∞–µ–º ID —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–µ–π
        instruction_msg = await event.answer(instruction_text, reply_markup=kb)
        logger.info(f"START: Created instruction message {instruction_msg.message_id}")
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º ID —ç—Ç–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è
        await state.update_data(instruction_message_id=instruction_msg.message_id)

@router.callback_query(F.data == "cancel_creation")
async def cancel_creation(call: types.CallbackQuery, state: FSMContext, bot: Bot):
    logger.info("CANCEL: Constructor cancelled")
    
    # –ü–æ–ª—É—á–∞–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä —Å–æ–æ–±—â–µ–Ω–∏–π
    manager = await get_message_manager(state)
    
    # –£–¥–∞–ª—è–µ–º –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è
    message_ids = manager.get_all_messages_to_delete()
    for msg_id in message_ids:
        try:
            logger.info(f"CANCEL: Deleting message {msg_id}")
            await bot.delete_message(call.message.chat.id, msg_id)
        except:
            pass
    
    # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–µ–π (–µ—Å–ª–∏ –µ—Å—Ç—å)
    data = await state.get_data()
    instruction_msg_id = data.get('instruction_message_id')
    if instruction_msg_id:
        try:
            logger.info(f"CANCEL: Deleting instruction message {instruction_msg_id}")
            await bot.delete_message(call.message.chat.id, instruction_msg_id)
        except:
            pass
    
    # –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    await state.clear()
    
    await call.message.answer("‚ùå –°–æ–∑–¥–∞–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=start_menu_kb())

@router.message(ConstructorState.editing_content)
async def receive_content(message: types.Message, state: FSMContext):
    logger.info("RECEIVE: Content received")
    
    # –ü–æ–ª—É—á–∞–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä —Å–æ–æ–±—â–µ–Ω–∏–π
    manager = await get_message_manager(state)
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º ID —Ç–µ–∫—É—â–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –∫–∞–∫ –≤—Ä–µ–º–µ–Ω–Ω–æ–µ
    manager.add_temp_message(message)
    await update_message_manager(state, manager)
    
    media_id, media_type = None, None
    if message.photo: media_id, media_type = message.photo[-1].file_id, "photo"
    elif message.video: media_id, media_type = message.video.file_id, "video"
    elif message.animation: media_id, media_type = message.animation.file_id, "animation"

    html_content = get_message_html(message)
    
    if not media_type and (not html_content or len(html_content) < 5):
        kb = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_creation")]])
        return await message.answer(
            "‚ö†Ô∏è <b>–¢–µ–∫—Å—Ç —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π!</b>\n–≠—Ç–æ —Ç–æ—á–Ω–æ —Ä–µ–∫–ª–∞–º–Ω—ã–π –ø–æ—Å—Ç? –ï—Å–ª–∏ –¥–∞ ‚Äî –Ω–∞–ø–∏—à–∏—Ç–µ –ø–æ–¥—Ä–æ–±–Ω–µ–µ.\n–ï—Å–ª–∏ –æ—à–∏–±–ª–∏—Å—å ‚Äî –ø—Ä–∏—à–ª–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.",
            reply_markup=kb
        )

    if not html_content and not media_type:
        return await message.answer("‚ùå –í –ø–æ—Å—Ç–µ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ç–µ–∫—Å—Ç –∏–ª–∏ –º–µ–¥–∏–∞.")
    
    safe_text = sanitize_text(html_content)
    await state.update_data(text=safe_text, media_file_id=media_id, media_type=media_type)
    
    await state.set_state(ConstructorState.init)
    
    # –°–æ–∑–¥–∞–µ–º –¥–≤–∞ —Å–æ–æ–±—â–µ–Ω–∏—è: Preview –∏ Control
    
    # 1. Preview (–ë–ï–ó –∫–Ω–æ–ø–æ–∫)
    preview_msg = await send_preview(message, state)
    if preview_msg:
        manager.set_preview_message(preview_msg)
    
    # 2. Control (—Å –∫–Ω–æ–ø–∫–∞–º–∏ –∏ –ø–æ–¥—Å–∫–∞–∑–∫–∞–º–∏)
    control_text = await get_control_hint('main_channel')
    kb = constructor_main_kb(
        "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –≤—Ä–µ–º—è", 1, 0, False, False, 0
    )
    control_msg = await send_initial_control_message(
        message.bot, state, message.chat.id, control_text, kb
    )
    
    manager.set_control_message(control_msg)
    await update_message_manager(state, manager)
    
    # –£–¥–∞–ª—è–µ–º –í–†–ï–ú–ï–ù–ù–´–ï —Å–æ–æ–±—â–µ–Ω–∏—è (–æ—Å—Ç–∞–≤–ª—è–µ–º Preview –∏ Control)
    for msg_id in manager.temp_messages:
        try:
            logger.info(f"RECEIVE: Deleting temp message {msg_id}")
            await message.bot.delete_message(message.chat.id, msg_id)
        except:
            pass
    
    # –£–¥–∞–ª—è–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –ø–æ–¥—Å–∫–∞–∑–∫–æ–π
    data = await state.get_data()
    instruction_msg_id = data.get('instruction_message_id')
    if instruction_msg_id:
        try:
            logger.info(f"RECEIVE: Deleting instruction message {instruction_msg_id}")
            await message.bot.delete_message(message.chat.id, instruction_msg_id)
        except Exception as e:
            logger.warning(f"RECEIVE: Failed to delete instruction message {instruction_msg_id}: {e}")
    
    # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –∫–æ–Ω—Ç–µ–Ω—Ç–æ–º
    try:
        logger.info(f"RECEIVE: Deleting user content message {message.message_id}")
        await message.delete()
    except Exception as e:
        logger.warning(f"RECEIVE: Failed to delete user content message: {e}")

@router.callback_query(ConstructorState.confirm_short_text, F.data == "confirm_short_text")
async def confirm_short(call: types.CallbackQuery, state: FSMContext):
    logger.info("CONFIRM: Short text confirmed")
    
    data = await state.get_data()
    await state.update_data(
        text=data['temp_text'], 
        media_file_id=data['temp_media_id'], 
        media_type=data['temp_media_type']
    )
    await state.set_state(ConstructorState.init)
    
    # –ü–æ–ª—É—á–∞–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä —Å–æ–æ–±—â–µ–Ω–∏–π
    manager = await get_message_manager(state)
    
    # –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø—Ä–µ–≤—å—é (–Ω–µ —Ç—Ä–æ–≥–∞–µ–º –∫–æ–Ω—Ç—Ä–æ–ª—å)
    preview_msg = await send_preview(call.message, state)
    if preview_msg:
        manager.set_preview_message(preview_msg)
        await update_message_manager(state, manager)
    
    # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    try:
        logger.info(f"CONFIRM: Deleting old message {call.message.message_id}")
        await call.message.delete()
    except Exception as e:
        logger.warning(f"CONFIRM: Failed to delete old message: {e}")

@router.callback_query(ConstructorState.confirm_short_text, F.data == "retry_content")
async def retry_short(call: types.CallbackQuery, state: FSMContext):
    logger.info("RETRY: Retrying content")
    await state.set_state(ConstructorState.editing_content)
    await call.message.edit_text("‚úèÔ∏è –•–æ—Ä–æ—à–æ, –ø—Ä–∏—à–ª–∏—Ç–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π (–±–æ–ª–µ–µ –¥–ª–∏–Ω–Ω—ã–π) –ø–æ—Å—Ç:")=== ./handlers/creator/constructor/structure.py ===
from aiogram.fsm.state import State, StatesGroup
from aiogram import types
from aiogram.exceptions import TelegramBadRequest

class ConstructorState(StatesGroup):
    init = State()
    editing_content = State()
    confirm_short_text = State() 
    adding_channel = State()
    adding_channel_link = State()
    editing_winners = State()  # –ù–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤–≤–æ–¥–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π –≤—Ä—É—á–Ω—É—é
    editing_referral = State() # –ù–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤–≤–æ–¥–∞ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤ –≤—Ä—É—á–Ω—É—é

async def safe_edit_to_text(message: types.Message, text: str, reply_markup=None):
    """
    –ë–µ–∑–æ–ø–∞—Å–Ω–æ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ä–µ–∂–∏–º.
    """
    try:
        if message.photo or message.video or message.animation or message.document:
            await message.delete()
            await message.answer(text, reply_markup=reply_markup)
        else:
            await message.edit_text(text, reply_markup=reply_markup)
    except TelegramBadRequest:
        try: await message.edit_text(text, reply_markup=reply_markup)
        except: pass
    except Exception:
        await message.answer(text, reply_markup=reply_markup)=== ./handlers/creator/constructor/message_manager.py ===
from aiogram import types
from aiogram.fsm.context import FSMContext
from typing import List, Optional
import logging

logger = logging.getLogger(__name__)

class MessageManager:
    """–ö–ª–∞—Å—Å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏ –≤ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–µ"""
    
    def __init__(self):
        self.preview_message_id = None      # ID —Å–æ–æ–±—â–µ–Ω–∏—è –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞
        self.control_message_id = None      # ID —Å–æ–æ–±—â–µ–Ω–∏—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        self.temp_messages = []            # –í—Ä–µ–º–µ–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è
    
    def set_preview_message(self, message: types.Message):
        """–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º ID —Å–æ–æ–±—â–µ–Ω–∏—è –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞"""
        self.preview_message_id = message.message_id
        logger.info(f"SET: Preview message ID: {message.message_id}")
    
    def set_control_message(self, message: types.Message):
        """–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º ID —Å–æ–æ–±—â–µ–Ω–∏—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è"""
        self.control_message_id = message.message_id
        logger.info(f"SET: Control message ID: {message.message_id}")
    
    def add_temp_message(self, message: types.Message):
        """–î–æ–±–∞–≤–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è"""
        self.temp_messages.append(message.message_id)
        logger.info(f"ADD: Temp message ID: {message.message_id}")
    
    async def delete_temp_messages(self, bot, chat_id: int):
        """–£–¥–∞–ª—è–µ–º –≤—Å–µ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        for msg_id in self.temp_messages[:]:  # –ö–æ–ø–∏—è —Å–ø–∏—Å–∫–∞, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –ø—Ä–æ–±–ª–µ–º –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏
            try:
                logger.info(f"DELETE: Temp message {msg_id}")
                await bot.delete_message(chat_id, msg_id)
                self.temp_messages.remove(msg_id)
            except Exception as e:
                logger.warning(f"WARNING: Failed to delete temp message {msg_id}: {e}")
    
    def get_all_messages_to_delete(self) -> List[int]:
        """–ü–æ–ª—É—á–∞–µ–º –≤—Å–µ ID —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è"""
        result = []
        if self.preview_message_id:
            result.append(self.preview_message_id)
        if self.control_message_id:
            result.append(self.control_message_id)
        result.extend(self.temp_messages)
        logger.info(f"GET: Messages to delete: {result}")
        return result
    
    def clear(self):
        """–û—á–∏—â–∞–µ–º –≤—Å–µ –¥–∞–Ω–Ω—ã–µ"""
        self.preview_message_id = None
        self.control_message_id = None
        self.temp_messages = []
        logger.info("CLEAR: All message IDs cleared")
    
    def to_dict(self) -> dict:
        """–ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ —Å–ª–æ–≤–∞—Ä—å –¥–ª—è —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏"""
        result = {
            'preview_message_id': self.preview_message_id,
            'control_message_id': self.control_message_id,
            'temp_messages': self.temp_messages
        }
        logger.debug(f"SERIALIZE: Message IDs: {result}")
        return result
    
    @classmethod
    def from_dict(cls, data: dict):
        """–°–æ–∑–¥–∞–µ–º –∏–∑ —Å–ª–æ–≤–∞—Ä—è"""
        manager = cls()
        manager.preview_message_id = data.get('preview_message_id')
        manager.control_message_id = data.get('control_message_id')
        manager.temp_messages = data.get('temp_messages', [])
        logger.debug(f"DESERIALIZE: Message IDs: {data}")
        return manager

async def get_message_manager(state: FSMContext) -> MessageManager:
    """–ü–æ–ª—É—á–∞–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä —Å–æ–æ–±—â–µ–Ω–∏–π –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è"""
    data = await state.get_data()
    if 'message_manager_data' not in data:
        manager = MessageManager()
        await state.update_data(message_manager_data=manager.to_dict())
        logger.info("NEW: Created new MessageManager")
        return manager
    
    logger.info("GET: Retrieved existing MessageManager")
    return MessageManager.from_dict(data['message_manager_data'])

async def update_message_manager(state: FSMContext, manager: MessageManager):
    """–û–±–Ω–æ–≤–ª—è–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä —Å–æ–æ–±—â–µ–Ω–∏–π –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏"""
    await state.update_data(message_manager_data=manager.to_dict())
    logger.info("UPDATE: State updated with MessageManager")=== ./handlers/creator/constructor/settings.py ===
from aiogram import Router, types, F, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

from database.models.user import User
from keyboards.inline.constructor import winners_selector_kb, referral_selector_kb, constructor_main_kb
from handlers.creator.constructor.publication import send_preview
from handlers.creator.constructor.control_message import get_control_hint, update_control_message
from handlers.creator.constructor.structure import ConstructorState

router = Router()

@router.callback_query(F.data == "constr_edit_content")
async def ask_new_content(call: types.CallbackQuery, state: FSMContext):
    await state.set_state(ConstructorState.editing_content)
    hint_text = await get_control_hint('content')
    kb = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="constr_back_main")]])
    await call.message.edit_text(hint_text, reply_markup=kb)

@router.callback_query(F.data == "constr_winners_menu")
async def winners_menu(call: types.CallbackQuery):
    await call.message.edit_reply_markup(reply_markup=winners_selector_kb())

@router.callback_query(F.data.startswith("constr_set_winners:"))
async def set_winners(call: types.CallbackQuery, state: FSMContext, bot: Bot):
    winners_count = int(call.data.split(":")[-1])
    await state.update_data(winners=winners_count)
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    hint_text = await get_control_hint('publish')
    kb = constructor_main_kb(
        "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –≤—Ä–µ–º—è", winners_count, 0, False, True, 0
    )
    await update_control_message(bot, state, call.message.chat.id, hint_text, kb)
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä (–ë–ï–ó –∫–Ω–æ–ø–æ–∫)
    from datetime import datetime
    data = await state.get_data()
    finish_dt = datetime.fromisoformat(data['finish_time_str'])
    date_str = finish_dt.strftime('%d.%m %H:%M –ú–°–ö')
    caption = f"{data['text']}\n\n<i>(–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä. –ò—Ç–æ–≥–∏: {date_str})</i>"
    
    from handlers.creator.constructor.message_manager import get_message_manager
    manager = await get_message_manager(state)
    if manager.preview_message_id:
        try:
            if data['media_type'] == 'photo':
                await bot.edit_message_caption(
                    chat_id=call.message.chat.id,
                    message_id=manager.preview_message_id,
                    caption=caption
                )
            else:
                await bot.edit_message_text(
                    chat_id=call.message.chat.id,
                    message_id=manager.preview_message_id,
                    text=caption
                )
        except Exception as e:
            print(f"Error updating preview: {e}")
    
    await call.answer(f"‚úÖ –í—ã–±—Ä–∞–Ω–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π: {winners_count}")

@router.callback_query(F.data == "constr_ref_menu")
async def ref_menu(call: types.CallbackQuery):
    await call.message.edit_reply_markup(reply_markup=referral_selector_kb())

@router.callback_query(F.data.startswith("constr_set_ref:"))
async def set_ref(call: types.CallbackQuery, state: FSMContext, bot: Bot):
    count = int(call.data.split(":")[-1])
    await state.update_data(ref_req=count)
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    hint_text = await get_control_hint('publish')
    kb = constructor_main_kb(
        "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –≤—Ä–µ–º—è", 1, count, False, True, 0
    )
    await update_control_message(bot, state, call.message.chat.id, hint_text, kb)
    
    ref_text = "–í—ã–∫–ª—é—á–µ–Ω–æ" if count == 0 else f"{count} –¥—Ä—É–∑–µ–π"
    await call.answer(f"‚úÖ –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞: {ref_text}")

@router.callback_query(F.data == "constr_toggle_cap")
async def toggle_cap(call: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    if not data['is_captcha']:
        user = await session.get(User, call.from_user.id)
        if not user or not user.is_premium:
            return await call.answer("üîí –§—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ —Å Premium!", show_alert=True)
            
    await state.update_data(is_captcha=not data['is_captcha'])
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    hint_text = await get_control_hint('publish')
    kb = constructor_main_kb(
        "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –≤—Ä–µ–º—è", 1, 0, not data['is_captcha'], True, 0
    )
    await update_control_message(bot, state, call.message.chat.id, hint_text, kb)
    
    status = "–í–ö–õ" if not data['is_captcha'] else "–í—ã–∫–ª"
    await call.answer(f"‚úÖ –ö–∞–ø—á–∞: {status}")

@router.callback_query(F.data == "constr_back_main")
async def back_to_main(call: types.CallbackQuery, state: FSMContext, bot: Bot):
    # –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    hint_text = await get_control_hint('default')
    kb = constructor_main_kb("–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –≤—Ä–µ–º—è", 1, 0, False, False, 0)
    await update_control_message(bot, state, call.message.chat.id, hint_text, kb)=== ./handlers/creator/constructor/winners_selector.py ===
from aiogram import Router, types, F, Bot
from aiogram.fsm.context import FSMContext
from keyboards.inline.constructor import winners_selector_kb, constructor_main_kb
from handlers.creator.constructor.publication import send_preview
from handlers.creator.constructor.structure import ConstructorState
from handlers.creator.constructor.control_message import get_control_hint, update_control_message
from handlers.creator.constructor.message_manager import get_message_manager, update_message_manager

router = Router()

@router.callback_query(F.data == "constr_winners_menu")
async def winners_menu(call: types.CallbackQuery):
    await call.message.edit_reply_markup(reply_markup=winners_selector_kb())

@router.callback_query(F.data.startswith("constr_set_winners:"))
async def set_winners(call: types.CallbackQuery, state: FSMContext, bot: Bot):
    winners_count = int(call.data.split(":")[-1])
    await state.update_data(winners=winners_count)
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    hint_text = await get_control_hint('publish')
    kb = constructor_main_kb(
        "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –≤—Ä–µ–º—è", winners_count, 0, False, True, 0
    )
    await update_control_message(bot, state, call.message.chat.id, hint_text, kb)
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä (–ë–ï–ó –∫–Ω–æ–ø–æ–∫)
    from datetime import datetime
    data = await state.get_data()
    finish_dt = datetime.fromisoformat(data['finish_time_str'])
    date_str = finish_dt.strftime('%d.%m %H:%M –ú–°–ö')
    caption = f"{data['text']}\n\n<i>(–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä. –ò—Ç–æ–≥–∏: {date_str})</i>"
    
    manager = await get_message_manager(state)
    if manager.preview_message_id:
        try:
            if data['media_type'] == 'photo':
                await bot.edit_message_caption(
                    chat_id=call.message.chat.id,
                    message_id=manager.preview_message_id,
                    caption=caption
                )
            else:
                await bot.edit_message_text(
                    chat_id=call.message.chat.id,
                    message_id=manager.preview_message_id,
                    text=caption
                )
        except Exception as e:
            print(f"Error updating preview: {e}")
    
    await call.answer(f"‚úÖ –í—ã–±—Ä–∞–Ω–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π: {winners_count}")

@router.message(ConstructorState.editing_winners)
async def process_winners_input(message: types.Message, state: FSMContext, bot: Bot):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π –≤—Ä—É—á–Ω—É—é"""
    try:
        # –ü–æ–ª—É—á–∞–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä —Å–æ–æ–±—â–µ–Ω–∏–π
        manager = await get_message_manager(state)
        manager.add_temp_message(message)
        await update_message_manager(state, manager)
        
        text = message.text.strip()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤–≤–µ–¥–µ–Ω–æ —á–∏—Å–ª–æ
        if not text.isdigit():
            return await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 50")
        
        winners_count = int(text)
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω
        if winners_count < 1 or winners_count > 50:
            return await message.answer("‚ùå –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 1 –¥–æ 50")
        
        await state.update_data(winners=winners_count)
        
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ –ø—Ä–µ–≤—å—é
        await state.set_state(ConstructorState.init)
        
        # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
        message_ids = manager.get_all_messages_to_delete()
        for msg_id in message_ids[:-1]:  # –û—Å—Ç–∞–≤–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            try:
                await bot.delete_message(message.chat.id, msg_id)
            except:
                pass
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        hint_text = await get_control_hint('publish')
        kb = constructor_main_kb(
            "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –≤—Ä–µ–º—è", winners_count, 0, False, True, 0
        )
        await update_control_message(bot, state, message.chat.id, hint_text, kb)
        
        await message.answer(f"‚úÖ –í—ã–±—Ä–∞–Ω–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π: {winners_count}")
        
    except Exception as e:
        print(f"Error in process_winners_input: {e}")
        await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")

@router.callback_query(F.data == "constr_set_winners_input")
async def ask_winners_input(call: types.CallbackQuery, state: FSMContext):
    """–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –≤–≤–µ—Å—Ç–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π –≤—Ä—É—á–Ω—É—é"""
    await state.set_state(ConstructorState.editing_winners)
    await call.message.edit_text("üî¢ <b>–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π</b> (1-50):")=== ./handlers/creator/constructor/__init__.py ===
from aiogram import Router
from . import start_content, settings, channels_select, channels_add, publication, winners_selector, referral_selector

router = Router()

router.include_router(start_content.router)
router.include_router(settings.router)
router.include_router(channels_select.router)
router.include_router(channels_add.router)
router.include_router(publication.router)
router.include_router(winners_selector.router)
router.include_router(referral_selector.router)=== ./handlers/creator/constructor/control_message.py ===
from aiogram import Router, types, F, Bot
from aiogram.fsm.context import FSMContext
from keyboards.inline.constructor import constructor_main_kb
from handlers.creator.constructor.message_manager import get_message_manager, update_message_manager
import logging

logger = logging.getLogger(__name__)

async def update_control_message(
    bot: Bot, 
    state: FSMContext, 
    chat_id: int, 
    new_text: str = None, 
    new_keyboard = None
):
    """–û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è"""
    manager = await get_message_manager(state)
    
    if not manager.control_message_id:
        # –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–µ—Ç, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–µ
        try:
            logger.info(f"CREATE: New control message (chat: {chat_id})")
            control_msg = await bot.send_message(chat_id, new_text or "–ö–æ–Ω—Ç—Ä–æ–ª—å", reply_markup=new_keyboard)
            manager.set_control_message(control_msg)
            await update_message_manager(state, manager)
            return control_msg
        except Exception as e:
            logger.error(f"ERROR: Failed to create control message: {e}")
            return None
    
    try:
        # –ü—ã—Ç–∞–µ–º—Å—è –æ–±–Ω–æ–≤–∏—Ç—å —Ç–µ–∫—Å—Ç
        if new_text:
            logger.info(f"EDIT: Control message text (ID: {manager.control_message_id})")
            await bot.edit_message_text(
                chat_id=chat_id,
                message_id=manager.control_message_id,
                text=new_text,
                reply_markup=new_keyboard or types.InlineKeyboardMarkup(inline_keyboard=[])
            )
        # –ü—ã—Ç–∞–µ–º—Å—è –æ–±–Ω–æ–≤–∏—Ç—å –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
        elif new_keyboard:
            logger.info(f"EDIT: Control message keyboard (ID: {manager.control_message_id})")
            await bot.edit_message_reply_markup(
                chat_id=chat_id,
                message_id=manager.control_message_id,
                reply_markup=new_keyboard
            )
    except Exception as e:
        logger.warning(f"WARNING: Failed to edit control message: {e}")
        # –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–µ
        try:
            logger.info(f"REPLACE: Creating new control message (chat: {chat_id})")
            control_msg = await bot.send_message(chat_id, new_text or "–ö–æ–Ω—Ç—Ä–æ–ª—å", reply_markup=new_keyboard)
            manager.set_control_message(control_msg)
            await update_message_manager(state, manager)
            return control_msg
        except Exception as e2:
            logger.error(f"ERROR: Failed to replace control message: {e2}")
            return None
    
    return None

async def send_initial_control_message(
    bot: Bot, 
    state: FSMContext, 
    chat_id: int, 
    initial_text: str,
    initial_keyboard = None
):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è"""
    manager = await get_message_manager(state)
    
    # –£–¥–∞–ª—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è, –µ—Å–ª–∏ –µ—Å—Ç—å
    if manager.control_message_id:
        try:
            logger.info(f"DELETE: Old control message (ID: {manager.control_message_id})")
            await bot.delete_message(chat_id, manager.control_message_id)
        except Exception as e:
            logger.warning(f"WARNING: Failed to delete old control message: {e}")
    
    try:
        logger.info(f"CREATE: Initial control message (chat: {chat_id})")
        control_msg = await bot.send_message(chat_id, initial_text, reply_markup=initial_keyboard)
        manager.set_control_message(control_msg)
        await update_message_manager(state, manager)
        return control_msg
    except Exception as e:
        logger.error(f"ERROR: Failed to send initial control message: {e}")
        return None

# --- –ü–æ–¥—Å–∫–∞–∑–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–π –∫–Ω–æ–ø–∫–∏ ---

CONTROL_HINTS = {
    'main_channel': (
        "üì¢ <b>–®–∞–≥ 2: –í—ã–±–æ—Ä –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞</b>\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–Ω–∞–ª, –≥–¥–µ –±—É–¥–µ—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω —Ä–æ–∑—ã–≥—Ä—ã—à.\n\n"
        "‚ö†Ô∏è <b>–í–∞–∂–Ω–æ:</b>\n"
        "‚Ä¢ –ë–æ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º\n"
        "‚Ä¢ –≠—Ç–æ –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª –¥–ª—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤\n"
        "‚Ä¢ –ò–∑ –Ω–µ–≥–æ –±—É–¥—É—Ç —Ä–µ–ø–æ—Å—Ç–∏—Ç—å—Å—è —Å–ø–æ–Ω—Å–æ—Ä—ã\n\n"
        "–ù–∞–∂–º–∏—Ç–µ <b>–ö–∞–Ω–∞–ª—ã</b> –¥–ª—è –≤—ã–±–æ—Ä–∞."
    ),
    
    'sponsors': (
        "ü§ù <b>–®–∞–≥ 3: –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–ø–æ–Ω—Å–æ—Ä–æ–≤</b>\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–Ω–∞–ª—ã, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è —É—á–∞—Å—Ç–Ω–∏–∫–∞–º.\n\n"
        "‚úÖ <b>–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:</b>\n"
        "‚Ä¢ –£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –æ—Ö–≤–∞—Ç\n"
        "‚Ä¢ –ü–æ–≤—ã—à–∞–µ—Ç –∏–Ω—Ç–µ—Ä–µ—Å –∫ —Ä–æ–∑—ã–≥—Ä—ã—à—É\n"
        "‚Ä¢ –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥–æ 20 –∫–∞–Ω–∞–ª–æ–≤\n\n"
        "–ù–∞–∂–º–∏—Ç–µ <b>–°–ø–æ–Ω—Å–æ—Ä—ã</b> –¥–ª—è –≤—ã–±–æ—Ä–∞."
    ),
    
    'time': (
        "‚è≥ <b>–®–∞–≥ 4: –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è</b>\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ, —á–µ—Ä–µ–∑ —Å–∫–æ–ª—å–∫–æ —á–∞—Å–æ–≤ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è —Ä–æ–∑—ã–≥—Ä—ã—à.\n\n"
        "üìÖ <b>–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:</b>\n"
        "‚Ä¢ –ú–∏–Ω–∏–º—É–º: 1 —á–∞—Å\n"
        "‚Ä¢ –û–ø—Ç–∏–º–∞–ª—å–Ω–æ: 24-72 —á–∞—Å–∞\n"
        "‚Ä¢ –ú–∞–∫—Å–∏–º—É–º: 30 –¥–Ω–µ–π\n\n"
        "–ù–∞–∂–º–∏—Ç–µ <b>–ò—Ç–æ–≥–∏</b> –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏."
    ),
    
    'winners': (
        "üèÜ <b>–®–∞–≥ 5: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π</b>\n\n"
        "–£–∫–∞–∂–∏—Ç–µ, —Å–∫–æ–ª—å–∫–æ —á–µ–ª–æ–≤–µ–∫ –ø–æ–ª—É—á–∞—Ç –ø—Ä–∏–∑.\n\n"
        "üí° <b>–°–æ–≤–µ—Ç—ã:</b>\n"
        "‚Ä¢ 1-3 –ø–æ–±–µ–¥–∏—Ç–µ–ª—è - –¥–ª—è –Ω–µ–±–æ–ª—å—à–∏—Ö –ø—Ä–∏–∑–æ–≤\n"
        "‚Ä¢ 5-10 –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π - –¥–ª—è —Å—Ä–µ–¥–Ω–∏—Ö –ø—Ä–∏–∑–æ–≤\n"
        "‚Ä¢ 20+ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π - –¥–ª—è –∫—Ä—É–ø–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π\n\n"
        "–ù–∞–∂–º–∏—Ç–µ <b>–ü–æ–±–µ–¥–∏—Ç–µ–ª–∏</b> –¥–ª—è –≤—ã–±–æ—Ä–∞."
    ),
    
    'referral': (
        "üîó <b>–®–∞–≥ 6: –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞</b>\n\n"
        "–ù–∞—Å—Ç—Ä–æ–π—Ç–µ –±–æ–Ω—É—Å—ã –∑–∞ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –¥—Ä—É–∑–µ–π.\n\n"
        "üéÅ <b>–ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç:</b>\n"
        "‚Ä¢ –ó–∞ –∫–∞–∂–¥–æ–≥–æ –¥—Ä—É–≥–∞ +1 –±–∏–ª–µ—Ç\n"
        "‚Ä¢ –ú–æ–∂–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ª–∏–º–∏—Ç (1-10 –¥—Ä—É–∑–µ–π)\n"
        "‚Ä¢ –ü–æ–≤—ã—à–∞–µ—Ç –≤–æ–≤–ª–µ—á–µ–Ω–Ω–æ—Å—Ç—å\n\n"
        "–ù–∞–∂–º–∏—Ç–µ <b>–†–µ—Ñ</b> –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏."
    ),
    
    'captcha': (
        "üõ° <b>–®–∞–≥ 7: –ó–∞—â–∏—Ç–∞ –æ—Ç –±–æ—Ç–æ–≤</b>\n\n"
        "–í–∫–ª—é—á–∏—Ç–µ –∫–∞–ø—á—É –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç –Ω–∞–∫—Ä—É—Ç–∫–∏.\n\n"
        "üîí <b>–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:</b>\n"
        "‚Ä¢ –û—Ç—Å–µ–∏–≤–∞–µ—Ç 99% –±–æ—Ç–æ–≤\n"
        "‚Ä¢ –¢–æ–ª—å–∫–æ Premium –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏\n"
        "‚Ä¢ –ü–æ–≤—ã—à–∞–µ—Ç –∫–∞—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤\n\n"
        "–ù–∞–∂–º–∏—Ç–µ <b>–ö–∞–ø—á–∞</b> –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è."
    ),
    
    'content': (
        "‚úèÔ∏è <b>–®–∞–≥ 1: –¢–µ–∫—Å—Ç –∏ –º–µ–¥–∏–∞</b>\n\n"
        "–ò–∑–º–µ–Ω–∏—Ç–µ —Ç–µ–∫—Å—Ç –æ–ø–∏—Å–∞–Ω–∏—è –∏–ª–∏ –¥–æ–±–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ.\n\n"
        "üìù <b>–°–æ–≤–µ—Ç—ã:</b>\n"
        "‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ (–∂–∏—Ä–Ω—ã–π, –∫—É—Ä—Å–∏–≤)\n"
        "‚Ä¢ –î–æ–±–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –¥–ª—è –ª—É—á—à–µ–≥–æ –≤–æ—Å–ø—Ä–∏—è—Ç–∏—è\n"
        "‚Ä¢ –£–∫–∞–∂–∏—Ç–µ —É—Å–ª–æ–≤–∏—è —É—á–∞—Å—Ç–∏—è\n\n"
        "–ù–∞–∂–º–∏—Ç–µ <b>–ò–∑–º–µ–Ω–∏—Ç—å –¢–µ–∫—Å—Ç/–ú–µ–¥–∏–∞</b> –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
    ),
    
    'publish': (
        "‚úÖ <b>–ì–æ—Ç–æ–≤–æ –∫ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏!</b>\n\n"
        "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã:\n"
        "‚Ä¢ –¢–µ–∫—Å—Ç —Ä–æ–∑—ã–≥—Ä—ã—à–∞\n"
        "‚Ä¢ –ö–∞–Ω–∞–ª –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏\n"
        "‚Ä¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π\n"
        "‚Ä¢ –í—Ä–µ–º—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è\n\n"
        "üéØ <b>–í–∞–∂–Ω–æ:</b>\n"
        "‚Ä¢ –ü–æ—Å–ª–µ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è –Ω–µ–≤–æ–∑–º–æ–∂–Ω—ã\n"
        "‚Ä¢ –†–æ–∑—ã–≥—Ä—ã—à –Ω–∞—á–Ω–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏\n"
        "‚Ä¢ –ü–æ–±–µ–¥–∏—Ç–µ–ª–∏ –æ–ø—Ä–µ–¥–µ–ª—è—Ç—Å—è –ø–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏\n\n"
        "–ù–∞–∂–º–∏—Ç–µ <b>–û–ü–£–ë–õ–ò–ö–û–í–ê–¢–¨</b> –¥–ª—è –∑–∞–ø—É—Å–∫–∞."
    ),
    
    'default': (
        "üéØ <b>–ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π</b>\n\n"
        "–ù–∞—Å—Ç—Ä–æ–π—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ä–æ–∑—ã–≥—Ä—ã—à–∞:\n\n"
        "1Ô∏è‚É£ <b>–ö–∞–Ω–∞–ª:</b> –ì–¥–µ –æ–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å\n"
        "2Ô∏è‚É£ <b>–°–ø–æ–Ω—Å–æ—Ä—ã:</b> –ù–∞ —á—Ç–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è\n"
        "3Ô∏è‚É£ <b>–ò—Ç–æ–≥–∏:</b> –ö–æ–≥–¥–∞ –∑–∞–≤–µ—Ä—à–∏—Ç—å\n"
        "4Ô∏è‚É£ <b>–ü–æ–±–µ–¥–∏—Ç–µ–ª–∏:</b> –°–∫–æ–ª—å–∫–æ —á–µ–ª–æ–≤–µ–∫\n"
        "5Ô∏è‚É£ <b>–†–µ—Ñ:</b> –ó–∞ –¥—Ä—É–∑–µ–π –±–æ–Ω—É—Å\n"
        "6Ô∏è‚É£ <b>–ö–∞–ø—á–∞:</b> –ó–∞—â–∏—Ç–∞ –æ—Ç –±–æ—Ç–æ–≤\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏!"
    )
}

async def get_control_hint(key: str) -> str:
    """–ü–æ–ª—É—á–∞–µ–º –ø–æ–¥—Å–∫–∞–∑–∫—É –ø–æ –∫–ª—é—á—É"""
    return CONTROL_HINTS.get(key, CONTROL_HINTS['default'])=== ./handlers/creator/constructor/channels_select.py ===
from aiogram import Router, types, F, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
import logging

from database.requests.channel_repo import get_user_channels
from keyboards.inline.constructor import channel_selection_kb, constructor_main_kb
from handlers.creator.constructor.structure import safe_edit_to_text
from handlers.creator.constructor.publication import send_preview
from handlers.creator.constructor.control_message import get_control_hint, update_control_message
from handlers.creator.constructor.message_manager import get_message_manager, update_message_manager

logger = logging.getLogger(__name__)

router = Router()

async def show_channels_selection(
    message: types.Message, 
    state: FSMContext, 
    session: AsyncSession, 
    user_id: int, 
    mode: str, 
    text_override: str = None
):
    """
    –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –º–µ–Ω—é –≤—ã–±–æ—Ä–∞ –∫–∞–Ω–∞–ª–æ–≤.
    """
    try:
        data = await state.get_data()
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤
        channels = await get_user_channels(session, user_id)
        
        if mode == 'main':
            sel = [data['main_channel']['id']] if data.get('main_channel') else []
            default_text = "üì¢ <b>–í—ã–±–µ—Ä–∏—Ç–µ –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª:</b>"
        else:
            main_id = data['main_channel']['id'] if data.get('main_channel') else None
            available = [ch for ch in channels if ch.channel_id != main_id]
            sel = [s['id'] for s in data.get('sponsors', [])]
            channels = available  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∫–∞–Ω–∞–ª—ã
            default_text = "ü§ù <b>–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ–Ω—Å–æ—Ä–æ–≤:</b>\n\n–û—Ç–º–µ—Ç—å—Ç–µ –∫–∞–Ω–∞–ª—ã-—Å–ø–æ–Ω—Å–æ—Ä—ã:"
        
        final_text = text_override if text_override else default_text
        
        kb = channel_selection_kb(channels, mode, sel)
        
        # –ü–æ–ª—É—á–∞–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä —Å–æ–æ–±—â–µ–Ω–∏–π
        manager = await get_message_manager(state)
        
        # –£–¥–∞–ª—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
        message_ids = manager.get_all_messages_to_delete()
        for msg_id in message_ids:
            try:
                logger.info(f"SELECT: Deleting message {msg_id}")
                await message.bot.delete_message(message.chat.id, msg_id)
            except Exception as e:
                logger.warning(f"SELECT: Failed to delete message {msg_id}: {e}")
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –µ–≥–æ ID
        new_msg = await message.answer(final_text, reply_markup=kb)
        manager.add_temp_message(new_msg)
        await update_message_manager(state, manager)
        
        logger.info(f"SELECT: Created selection message {new_msg.message_id}")
        
    except Exception as e:
        logger.error(f"SELECT: Error in show_channels_selection: {e}")
        # –ï—Å–ª–∏ —á—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫, –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
        try:
            await message.delete()
        except: pass
        
        from handlers.creator.constructor.structure import ConstructorState
        from keyboards.inline.dashboard import start_menu_kb
        await state.set_state(ConstructorState.init)
        await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –í–µ—Ä–Ω–∏—Ç–µ—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.", reply_markup=start_menu_kb())

# --- –•–ï–ù–î–õ–ï–†–´ ---

@router.callback_query(F.data == "constr_select_main")
async def select_main_menu(call: types.CallbackQuery, session: AsyncSession, state: FSMContext):
    logger.info("SELECT: Selecting main channel")
    await state.update_data(channel_selector_mode="main")
    await show_channels_selection(call.message, state, session, call.from_user.id, "main", "üì¢ <b>–í—ã–±–µ—Ä–∏—Ç–µ –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª:</b>")

@router.callback_query(F.data == "constr_select_sponsors")
async def select_sponsors_menu(call: types.CallbackQuery, session: AsyncSession, state: FSMContext):
    logger.info("SELECT: Selecting sponsors")
    await state.update_data(channel_selector_mode="sponsor")
    await show_channels_selection(call.message, state, session, call.from_user.id, "sponsor", "ü§ù <b>–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ–Ω—Å–æ—Ä–æ–≤:</b>\n\n–û—Ç–º–µ—Ç—å—Ç–µ –∫–∞–Ω–∞–ª—ã-—Å–ø–æ–Ω—Å–æ—Ä—ã:")

@router.callback_query(F.data.startswith("constr_set_ch:"))
async def set_channel(call: types.CallbackQuery, state: FSMContext, bot: Bot, session: AsyncSession):
    logger.info("SELECT: Setting channel")
    
    _, mode, ch_id_str = call.data.split(":")
    chat_id = int(ch_id_str)
    
    from database.requests.channel_repo import get_user_channels
    user_chs = await get_user_channels(session, call.from_user.id)
    target_ch = next((ch for ch in user_chs if ch.channel_id == chat_id), None)
    if not target_ch: 
        return await call.answer("‚ùå –ö–∞–Ω–∞–ª –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –≤–∞—à–µ–º —Å–ø–∏—Å–∫–µ!", show_alert=True)

    # –§–æ—Ä–º–∏—Ä—É–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–∞–Ω–∞–ª–µ
    link = target_ch.invite_link or (f"@{target_ch.username}" if target_ch.username else "private")
    channel_info = {
        'id': chat_id, 
        'title': target_ch.title, 
        'link': link,
        'db_id': target_ch.id
    }
    
    data = await state.get_data()
    sponsors = data.get('sponsors', [])

    if mode == "main":
        # –ï—Å–ª–∏ –≤—ã–±–∏—Ä–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª
        if data.get('main_channel') and data['main_channel']['id'] == chat_id:
            # –û—Ç–º–µ–Ω–∞ –≤—ã–±–æ—Ä–∞
            await state.update_data(main_channel=None)
        else:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –≤—ã–±—Ä–∞–Ω –ª–∏ —É–∂–µ —ç—Ç–æ—Ç –∫–∞–Ω–∞–ª –∫–∞–∫ —Å–ø–æ–Ω—Å–æ—Ä
            if any(s['id'] == chat_id for s in sponsors):
                # –£–¥–∞–ª—è–µ–º –∏–∑ —Å–ø–æ–Ω—Å–æ—Ä–æ–≤
                sponsors = [s for s in sponsors if s['id'] != chat_id]
                await state.update_data(sponsors=sponsors)
            
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª
            await state.update_data(main_channel=channel_info)
            
        # –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        hint_text = await get_control_hint('sponsors')
        kb = constructor_main_kb(
            "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –≤—Ä–µ–º—è", 1, 0, False, True, 0
        )
        await update_control_message(bot, state, call.message.chat.id, hint_text, kb)
        
    else:  # mode == "sponsor"
        if any(s['id'] == chat_id for s in sponsors):
            # –£–¥–∞–ª—è–µ–º –∏–∑ —Å–ø–æ–Ω—Å–æ—Ä–æ–≤
            sponsors = [s for s in sponsors if s['id'] != chat_id]
            await state.update_data(sponsors=sponsors)
        else:
            # –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å–ø–æ–Ω—Å–æ—Ä—ã (–Ω–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ –≤—ã–±—Ä–∞–Ω –∫–∞–∫ –æ—Å–Ω–æ–≤–Ω–æ–π)
            main_ch = data.get('main_channel')
            if main_ch and main_ch['id'] == chat_id:
                return await call.answer("‚ùå –≠—Ç–æ—Ç –∫–∞–Ω–∞–ª —É–∂–µ –≤—ã–±—Ä–∞–Ω –∫–∞–∫ –æ—Å–Ω–æ–≤–Ω–æ–π!", show_alert=True)
            
            sponsors.append(channel_info)
            await state.update_data(sponsors=sponsors)
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        hint_text = await get_control_hint('winners')
        kb = constructor_main_kb(
            "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –≤—Ä–µ–º—è", 1, 0, False, True, len(sponsors)
        )
        await update_control_message(bot, state, call.message.chat.id, hint_text, kb)
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏ –≤—ã–±–æ—Ä–∞ —Å–ø–æ–Ω—Å–æ—Ä–æ–≤
        channels = await get_user_channels(session, call.from_user.id)
        main_id = data.get('main_channel', {}).get('id')
        available = [ch for ch in channels if ch.channel_id != main_id]
        sel = [s['id'] for s in sponsors]
        
        await call.message.edit_reply_markup(
            reply_markup=channel_selection_kb(available, "sponsor", sel)
        )=== ./handlers/creator/time_picker.py ===
from aiogram import Router, types, F
from aiogram.fsm.context import FSMContext
from core.tools.timezone import get_now_msk, to_utc
from datetime import datetime
from keyboards.inline.calendar_kb import generate_calendar, time_picker_kb

router = Router()

@router.callback_query(F.data == "constr_time_menu")
async def open_calendar(call: types.CallbackQuery):
    now = get_now_msk()
    await call.message.edit_reply_markup(reply_markup=generate_calendar(now.year, now.month))

@router.callback_query(F.data.startswith("cal_nav:"))
async def navigate_calendar(call: types.CallbackQuery):
    _, y, m = call.data.split(":")
    await call.message.edit_reply_markup(reply_markup=generate_calendar(int(y), int(m)))

@router.callback_query(F.data.startswith("date_set:"))
async def pick_date(call: types.CallbackQuery):
    _, y, m, d = call.data.split(":")
    await call.message.edit_reply_markup(reply_markup=time_picker_kb(int(y), int(m), int(d)))

@router.callback_query(F.data.startswith("time_set:"))
async def pick_time(call: types.CallbackQuery, state: FSMContext):
    # time_set:2026:1:15:14:00
    _, y, m, d, h, mn = call.data.split(":")
    
    try:
        # 1. –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç –≤ –ú–°–ö
        from core.tools.timezone import MSK
        dt_msk = datetime(int(y), int(m), int(d), int(h), int(mn), tzinfo=MSK)
        
        if dt_msk <= get_now_msk():
            return await call.answer("‚ùå –í—Ä–µ–º—è —É–∂–µ –ø—Ä–æ—à–ª–æ!", show_alert=True)
            
        # 2. –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç—Ä–æ–∫—É ISO (—Å —Ç–∞–π–º–∑–æ–Ω–æ–π)
        await state.update_data(finish_time_str=dt_msk.isoformat())
        
        # 3. –í–æ–∑–≤—Ä–∞—Ç –≤ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä
        from handlers.creator.constructor import send_preview
        await send_preview(call.message, state, is_edit=True)
        
    except ValueError:
        await call.answer("–û—à–∏–±–∫–∞ –¥–∞—Ç—ã")=== ./handlers/creator/__init__.py ===
# handlers/creator/__init__.py - –µ—Å–ª–∏ —Ñ–∞–π–ª —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –æ—Å—Ç–∞–≤—å—Ç–µ –µ–≥–æ –ø—É—Å—Ç—ã–º –∏–ª–∏:
from aiogram import Router

router = Router()
# –ù–∏–∫–∞–∫–∏—Ö –∏–º–ø–æ—Ä—Ç–æ–≤!=== ./handlers/super_admin/list_view.py ===
# handlers/super_admin/list_view.py
from aiogram import Router, F
from aiogram.types import CallbackQuery
from keyboards.callback_data import AdminAction
from keyboards.inline.admin_panel import build_manage_menu

router = Router()

# –õ–æ–≤–∏–º callback —Å action="manage"
@router.callback_query(AdminAction.filter(F.action == "manage"))
async def show_gw_options(call: CallbackQuery, callback_data: AdminAction):
    # –¢—É—Ç —É–∂–µ –ø—Ä–æ—à–ª–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ HMAC –≤ Middleware, —Ç–∞–∫ —á—Ç–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ
    gw_id = callback_data.id
    admin_id = call.from_user.id
    
    kb = build_manage_menu(gw_id, admin_id)
    await call.message.edit_text(f"‚öôÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–æ–∑—ã–≥—Ä—ã—à–µ–º #{gw_id}", reply_markup=kb)=== ./handlers/super_admin/user_manage.py ===
from aiogram import Router, types, F
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import update

from database.models.user import User
from filters.is_admin import IsAdmin

router = Router()

class AdminUserState(StatesGroup):
    waiting_for_id_prem = State()

@router.callback_query(IsAdmin(), F.data == "admin_find_user")
async def ask_user_id(call: types.CallbackQuery, state: FSMContext):
    await call.message.answer("üÜî –í–≤–µ–¥–∏—Ç–µ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –≤—ã–¥–∞—á–∏/—Å–Ω—è—Ç–∏—è Premium:")
    await state.set_state(AdminUserState.waiting_for_id_prem)
    await call.answer()

@router.message(IsAdmin(), AdminUserState.waiting_for_id_prem)
async def toggle_premium(message: types.Message, state: FSMContext, session: AsyncSession):
    try:
        target_id = int(message.text)
    except ValueError:
        return await message.answer("‚ùå –≠—Ç–æ –Ω–µ —á–∏—Å–ª–æ.")

    user = await session.get(User, target_id)
    if not user:
        return await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ.")

    # –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Å—Ç–∞—Ç—É—Å
    new_status = not user.is_premium
    user.is_premium = new_status
    await session.commit()
    
    status_str = "‚úÖ –í–´–î–ê–ù" if new_status else "‚ùå –°–ù–Ø–¢"
    await message.answer(f"Premium –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {target_id} —É—Å–ø–µ—à–Ω–æ {status_str}.")
    await state.clear()=== ./handlers/super_admin/menu_main.py ===
from aiogram import Router, types, F
from aiogram.filters import Command
from sqlalchemy import func, select
from sqlalchemy.ext.asyncio import AsyncSession

from filters.is_admin import IsAdmin
from database.models.user import User
from database.models.giveaway import Giveaway
from keyboards.builders import simple_menu 

router = Router()

@router.message(IsAdmin(), Command("admin"))
async def admin_dashboard(message: types.Message, session: AsyncSession):
    # –°–±–æ—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    total_users = await session.scalar(select(func.count(User.user_id)))
    premium_users = await session.scalar(select(func.count(User.user_id)).where(User.is_premium == True))
    active_gws = await session.scalar(select(func.count(Giveaway.id)).where(Giveaway.status == "active"))
    finished_gws = await session.scalar(select(func.count(Giveaway.id)).where(Giveaway.status == "finished"))

    text = (
        f"üëë <b>–ü–∞–Ω–µ–ª—å –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞</b>\n\n"
        f"üë• <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏:</b> {total_users}\n"
        f"üåü <b>Premium:</b> {premium_users}\n"
        f"üé∞ <b>–†–æ–∑—ã–≥—Ä—ã—à–∏:</b>\n"
        f" ‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã–µ: {active_gws}\n"
        f" ‚Ä¢ –ó–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ: {finished_gws}\n\n"
        f"–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:"
    )
    
    # –ë–∏–ª–¥–µ—Ä –∫–Ω–æ–ø–æ–∫ (–Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —ç—Ç–∏ callback'–∏ –≤ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏)
    from aiogram.utils.keyboard import InlineKeyboardBuilder
    kb = InlineKeyboardBuilder()
    kb.button(text="üì¢ –†–∞—Å—Å—ã–ª–∫–∞", callback_data="admin_broadcast")
    kb.button(text="üë§ –ù–∞–π—Ç–∏ —é–∑–µ—Ä–∞", callback_data="admin_find_user")
    kb.button(text="üìã –°–ø–∏—Å–æ–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö GW", callback_data="admin_list_active")
    kb.adjust(2, 1)

    await message.answer(text, reply_markup=kb.as_markup())=== ./handlers/super_admin/manage_item.py ===
# handlers/super_admin/manage_item.py
from aiogram import Router, Bot, F
from aiogram.types import CallbackQuery
from keyboards.callback_data import AdminAction
from core.logic.game_actions import finish_giveaway_task

router = Router()

@router.callback_query(AdminAction.filter(F.action == "finish"))
async def force_finish(call: CallbackQuery, callback_data: AdminAction, bot: Bot):
    await call.answer("–ó–∞–ø—É—Å–∫–∞—é –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ...", show_alert=False)
    # –í—ã–∑—ã–≤–∞–µ–º –æ–±—â—É—é –ª–æ–≥–∏–∫—É
    await finish_giveaway_task(callback_data.id, bot)
    await call.message.edit_text(f"‚úÖ –†–æ–∑—ã–≥—Ä—ã—à #{callback_data.id} –∑–∞–≤–µ—Ä—à–µ–Ω –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ.")

@router.callback_query(AdminAction.filter(F.action == "delete"))
async def delete_gw(call: CallbackQuery, callback_data: AdminAction):
    # –õ–æ–≥–∏–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∏–∑ –ë–î (–Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –º–µ—Ç–æ–¥ –≤ repo)
    # await delete_giveaway(session, callback_data.id)
    await call.message.edit_text("üóë –†–æ–∑—ã–≥—Ä—ã—à —É–¥–∞–ª–µ–Ω (soft delete).")=== ./handlers/super_admin/broadcast.py ===
import asyncio
from aiogram import Router, types, F, Bot
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from database.models.user import User
from filters.is_admin import IsAdmin

router = Router()

class BroadcastState(StatesGroup):
    waiting_for_post = State()
    confirm = State()

@router.callback_query(IsAdmin(), F.data == "admin_broadcast")
async def start_broadcast(call: types.CallbackQuery, state: FSMContext):
    await call.message.answer("üì¢ <b>–†–∞—Å—Å—ã–ª–∫–∞</b>\n\n–ü—Ä–∏—à–ª–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ (—Ç–µ–∫—Å—Ç, —Ñ–æ—Ç–æ, —Ä–µ–ø–æ—Å—Ç), –∫–æ—Ç–æ—Ä–æ–µ –Ω—É–∂–Ω–æ —Ä–∞–∑–æ—Å–ª–∞—Ç—å –≤—Å–µ–º.")
    await state.set_state(BroadcastState.waiting_for_post)
    await call.answer()

@router.message(IsAdmin(), BroadcastState.waiting_for_post)
async def receive_post(message: types.Message, state: FSMContext):
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º ID —Å–æ–æ–±—â–µ–Ω–∏—è –∏ ID —á–∞—Ç–∞, –æ—Ç–∫—É–¥–∞ –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å
    await state.update_data(msg_id=message.message_id, chat_id=message.chat.id)
    
    # –ü—Ä–æ—Å–∏–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
    from aiogram.utils.keyboard import InlineKeyboardBuilder
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úÖ –û—Ç–ø—Ä–∞–≤–∏—Ç—å", callback_data="broadcast_go")
    kb.button(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="admin_cancel")
    
    await message.copy_to(message.chat.id) # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–µ–≤—å—é
    await message.answer("–í—ã—à–µ –ø—Ä–µ–≤—å—é. –ù–∞—á–∏–Ω–∞–µ–º —Ä–∞—Å—Å—ã–ª–∫—É?", reply_markup=kb.as_markup())
    await state.set_state(BroadcastState.confirm)

@router.callback_query(IsAdmin(), BroadcastState.confirm, F.data == "broadcast_go")
async def run_broadcast(call: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    msg_id = data['msg_id']
    from_chat_id = data['chat_id']
    
    await call.message.edit_text("üöÄ –†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–ø—É—â–µ–Ω–∞! –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –≤—Ä–µ–º—è...")
    
    # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    result = await session.execute(select(User.user_id))
    users = result.scalars().all()
    
    count = 0
    blocked = 0
    
    for user_id in users:
        try:
            await bot.copy_message(chat_id=user_id, from_chat_id=from_chat_id, message_id=msg_id)
            count += 1
        except Exception:
            blocked += 1
        
        # –ü–∞—É–∑–∞ –∫–∞–∂–¥—ã–µ 20 —Å–æ–æ–±—â–µ–Ω–∏–π, —á—Ç–æ–±—ã –Ω–µ —Å–ª–æ–≤–∏—Ç—å FloodWait
        if count % 20 == 0:
            await asyncio.sleep(1)
            
    await call.message.answer(
        f"üèÅ <b>–†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n"
        f"‚úÖ –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {count}\n"
        f"üíÄ –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª–∏ –±–æ—Ç–∞: {blocked}"
    )
    await state.clear()=== ./handlers/super_admin/rig_winner.py ===
# handlers/super_admin/rig_winner.py
from aiogram import Router, F, types
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from sqlalchemy.ext.asyncio import AsyncSession

from keyboards.callback_data import AdminAction
from database.requests.giveaway_repo import set_predetermined_winner

router = Router()

class RigState(StatesGroup):
    waiting_for_id = State()

@router.callback_query(AdminAction.filter(F.action == "rig"))
async def start_rigging(call: types.CallbackQuery, callback_data: AdminAction, state: FSMContext):
    await state.update_data(gw_id=callback_data.id)
    await state.set_state(RigState.waiting_for_id)
    await call.message.answer(
        f"üïµÔ∏è‚Äç‚ôÇÔ∏è <b>–†–µ–∂–∏–º –±–æ–≥–∞</b> (–†–æ–∑—ã–≥—Ä—ã—à #{callback_data.id})\n"
        f"–ü—Ä–∏—à–ª–∏—Ç–µ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä—ã–π –î–û–õ–ñ–ï–ù –ø–æ–±–µ–¥–∏—Ç—å.\n"
        f"‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ–±—è–∑–∞–Ω –Ω–∞–∂–∞—Ç—å –∫–Ω–æ–ø–∫—É —É—á–∞—Å—Ç–∏—è, –∏–Ω–∞—á–µ —ç—Ç–æ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç!"
    )
    await call.answer()

@router.message(RigState.waiting_for_id)
async def set_winner_id(message: types.Message, state: FSMContext, session: AsyncSession):
    try:
        winner_id = int(message.text)
    except ValueError:
        return await message.answer("‚ùå –ù—É–∂–µ–Ω —á–∏—Å–ª–æ–≤–æ–π ID.")

    data = await state.get_data()
    gw_id = data['gw_id']

    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º "–∂—É—á–∫–∞" –≤ –ë–î
    await set_predetermined_winner(session, gw_id, winner_id)
    
    await message.answer(f"‚úÖ <b>–ì–æ—Ç–æ–≤–æ!</b>\n–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å `{winner_id}` –ø–æ–±–µ–¥–∏—Ç –≤ —Ä–æ–∑—ã–≥—Ä—ã—à–µ #{gw_id} (–µ—Å–ª–∏ –±—É–¥–µ—Ç —É—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å).")
    await state.clear()=== ./handlers/participant/join.py ===
from aiogram import Router, Bot, types, F
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from database.models.participant import Participant
from database.models.giveaway import Giveaway
from database.requests.giveaway_repo import get_giveaway_by_id, get_required_channels
from keyboards.inline.participation import check_subscription_kb
from core.logic.ticket_gen import get_unique_ticket
from core.services.ref_service import create_ref_link
from core.services.checker_service import is_user_subscribed

router = Router()

async def get_missing_channels(bot: Bot, user_id: int, gw: Giveaway, session: AsyncSession):
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤ –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏.
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç Redis-–∫–µ—à –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞ —é–∑–µ—Ä–∞.
    """
    reqs = await get_required_channels(session, gw.id)
    missing = []

    # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª
    try:
        chat = await bot.get_chat(gw.channel_id)
        # –§–æ—Ä–º–∏—Ä—É–µ–º –∫—Ä–∞—Å–∏–≤—É—é —Å—Å—ã–ª–∫—É
        link = chat.invite_link or (f"https://t.me/{chat.username}" if chat.username else "...")
        
        # –ü–†–û–í–ï–†–ö–ê –ß–ï–†–ï–ó –ö–ï–® –°–ï–†–í–ò–°
        if not await is_user_subscribed(bot, gw.channel_id, user_id):
            missing.append({'title': f"üì¢ {chat.title}", 'link': link})
    except:
        # –ï—Å–ª–∏ –±–æ—Ç –Ω–µ –º–æ–∂–µ—Ç –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø
        missing.append({'title': "üì¢ –û—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª", 'link': "https://t.me/..."})

    # 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–ø–æ–Ω—Å–æ—Ä–æ–≤
    for r in reqs:
        # –ü–†–û–í–ï–†–ö–ê –ß–ï–†–ï–ó –ö–ï–® –°–ï–†–í–ò–°
        if not await is_user_subscribed(bot, r.channel_id, user_id):
            missing.append({'title': r.channel_title, 'link': r.channel_link})
            
    return missing

async def show_subscription_check(message: types.Message, gw_id: int, session: AsyncSession, bot: Bot):
    """
    –ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≤—Ö–æ–¥–∞.
    """
    gw = await get_giveaway_by_id(session, gw_id)
    if not gw or gw.status != 'active':
        return await message.answer("üòî <b>–£–≤—ã, —ç—Ç–æ—Ç —Ä–æ–∑—ã–≥—Ä—ã—à —É–∂–µ –∑–∞–≤–µ—Ä—à–µ–Ω.</b>")

    # --- –ü–†–û–í–ï–†–ö–ê: –°–û–ó–î–ê–¢–ï–õ–¨ –ù–ï –ú–û–ñ–ï–¢ –£–ß–ê–°–¢–í–û–í–ê–¢–¨ ---
    if message.from_user.id == gw.owner_id:
        return await message.answer(
            "‚ö†Ô∏è <b>–í—ã –æ—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä —ç—Ç–æ–≥–æ —Ä–æ–∑—ã–≥—Ä—ã—à–∞.</b>\n\n"
            "–£—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å –≤ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–º —Ä–æ–∑—ã–≥—Ä—ã—à–µ –Ω–µ–ª—å–∑—è. –í—ã –º–æ–∂–µ—Ç–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –≤ –ª–∏—á–Ω–æ–º –∫–∞–±–∏–Ω–µ—Ç–µ."
        )
    # ------------------------------------------------

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –±–∏–ª–µ—Ç –≤ –±–∞–∑–µ
    existing_stmt = select(Participant).where(
        Participant.user_id == message.from_user.id,
        Participant.giveaway_id == gw_id
    )
    existing = await session.scalar(existing_stmt)
    
    bot_username = (await bot.get_me()).username

    # === –°–¶–ï–ù–ê–†–ò–ô 1: –£–ñ–ï –£–ß–ê–°–¢–í–£–ï–¢ ===
    if existing:
        text = (
            f"üëã <b>–¢—ã —É–∂–µ –≤ –∏–≥—Ä–µ!</b>\n\n"
            f"üé´ –¢–≤–æ–π –±–∏–ª–µ—Ç: <code>{existing.ticket_code}</code>\n"
            f"‚ö°Ô∏è –®–∞–Ω—Å–æ–≤ –Ω–∞ –ø–æ–±–µ–¥—É: <b>{existing.tickets_count}</b>"
        )
        
        if gw.is_referral_enabled:
            token = await create_ref_link(message.from_user.id)
            ref_link = f"https://t.me/{bot_username}?start=gw_{gw_id}_{token}"
            text += (
                f"\n\nüöÄ <b>–•–æ—á–µ—à—å —É–≤–µ–ª–∏—á–∏—Ç—å —à–∞–Ω—Å—ã?</b>\n"
                f"–ü—Ä–∏–≥–ª–∞—à–∞–π –¥—Ä—É–∑–µ–π –ø–æ —ç—Ç–æ–π —Å—Å—ã–ª–∫–µ ‚Äî –∑–∞ –∫–∞–∂–¥–æ–≥–æ –ø–æ–ª—É—á–∏—à—å <b>+1 –±–∏–ª–µ—Ç</b>:\n"
                f"üëáüëáüëá\n"
                f"<code>{ref_link}</code>"
            )

        return await message.answer(text, disable_web_page_preview=True)

    # === –°–¶–ï–ù–ê–†–ò–ô 2: –ù–û–í–ò–ß–û–ö (–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–æ–∫) ===
    missing = await get_missing_channels(bot, message.from_user.id, gw, session)

    if not missing:
        # –ï—Å–ª–∏ –ø–æ–¥–ø–∏—Å–∞–Ω –Ω–∞ –≤—Å–µ -> –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º
        await register_participant(message, gw, session, bot)
    else:
        text = (
            f"üîí <b>–î–æ—Å—Ç—É–ø –æ–≥—Ä–∞–Ω–∏—á–µ–Ω!</b>\n\n"
            f"–ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –±–∏–ª–µ—Ç —É—á–∞—Å—Ç–Ω–∏–∫–∞, –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã —Å–ø–æ–Ω—Å–æ—Ä–æ–≤:\n"
            f"üëá –ñ–º–∏ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ, –∞ –∑–∞—Ç–µ–º <b>¬´–Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è¬ª</b>"
        )
        await message.answer(text, reply_markup=check_subscription_kb(gw_id, missing))

@router.callback_query(F.data.startswith("check_sub:"))
async def on_check_subscription(call: types.CallbackQuery, session: AsyncSession, bot: Bot, state: FSMContext):
    gw_id = int(call.data.split(":")[-1])
    gw = await get_giveaway_by_id(session, gw_id)
    
    if not gw or gw.status != 'active':
        return await call.message.edit_text("‚ùå –†–æ–∑—ã–≥—Ä—ã—à –∑–∞–≤–µ—Ä—à–µ–Ω.")

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–æ–∑–¥–∞—Ç–µ–ª—è (–Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π)
    if call.from_user.id == gw.owner_id:
        return await call.answer("–í—ã –æ—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä!", show_alert=True)

    missing = await get_missing_channels(bot, call.from_user.id, gw, session)

    if missing:
        await call.answer("üëÄ –í—ã –ø–æ–¥–ø–∏—Å–∞–ª–∏—Å—å –Ω–µ –Ω–∞ –≤—Å–µ –∫–∞–Ω–∞–ª—ã!", show_alert=True)
        await call.message.edit_reply_markup(reply_markup=check_subscription_kb(gw_id, missing))
    else:
        await call.message.delete()
        await register_participant(call.message, gw, session, bot, state)

async def register_participant(message: types.Message, gw: Giveaway, session: AsyncSession, bot: Bot, state: FSMContext = None):
    user_id = message.chat.id
    ticket = await get_unique_ticket(session, gw.id)
    
    referrer_id = None
    if gw.is_referral_enabled and state:
        data = await state.get_data()
        referrer_id = data.get("referrer_id")
    
    new_part = Participant(
        user_id=user_id,
        giveaway_id=gw.id,
        ticket_code=ticket,
        referrer_id=referrer_id,
        tickets_count=1
    )
    session.add(new_part)
    
    if gw.is_referral_enabled and referrer_id:
        ref_part_stmt = select(Participant).where(
            Participant.user_id == referrer_id, 
            Participant.giveaway_id == gw.id
        )
        ref_part = await session.scalar(ref_part_stmt)
        if ref_part:
            ref_part.tickets_count += 1
            session.add(ref_part)

    try:
        await session.commit()
    except Exception:
        await session.rollback()
        return await message.answer("‚úÖ –í—ã —É–∂–µ —É—á–∞—Å—Ç–≤—É–µ—Ç–µ!")

    text = (
        f"üéâ <b>–ü–û–ó–î–†–ê–í–õ–Ø–ï–ú, –í–´ –í –ò–ì–†–ï!</b>\n\n"
        f"üé´ –¢–≤–æ–π –±–∏–ª–µ—Ç: <code>{ticket}</code>\n"
        f"üë§ –£—á–∞—Å—Ç–Ω–∏–∫: <b>{message.chat.full_name}</b>"
    )

    if gw.is_referral_enabled:
        bot_username = (await bot.get_me()).username
        token = await create_ref_link(user_id)
        ref_link = f"https://t.me/{bot_username}?start=gw_{gw.id}_{token}"
        
        text += (
            f"\n\nüöÄ <b>–£–≤–µ–ª–∏—á—å —Å–≤–æ–∏ —à–∞–Ω—Å—ã –Ω–∞ –ø–æ–±–µ–¥—É!</b>\n"
            f"–û—Ç–ø—Ä–∞–≤—å —Å—Å—ã–ª–∫—É –¥—Ä—É–∑—å—è–º ‚Äî –∑–∞ –∫–∞–∂–¥–æ–≥–æ –¥—Ä—É–≥–∞ —Ç—ã –ø–æ–ª—É—á–∏—à—å <b>+1 –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –±–∏–ª–µ—Ç</b>.\n\n"
            f"üîó <b>–¢–≤–æ—è –ª–∏—á–Ω–∞—è —Å—Å—ã–ª–∫–∞:</b>\n"
            f"<code>{ref_link}</code>"
        )
    
    await message.answer(text, disable_web_page_preview=True)
    if state:
        await state.clear()=== ./handlers/common/start.py ===
from aiogram import Router, types, Bot
from aiogram.filters import CommandStart, CommandObject
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from database.requests.user_repo import register_user
from database.models.winner import Winner
from handlers.participant.join import show_subscription_check
from core.services.ref_service import resolve_ref_link # <--- –°–µ—Ä–≤–∏—Å

router = Router()

@router.message(CommandStart())
async def cmd_start(
    message: types.Message, 
    command: CommandObject, 
    session: AsyncSession, 
    bot: Bot, 
    state: FSMContext
):
    await register_user(session, message.from_user.id, message.from_user.username, message.from_user.full_name)

    args = command.args
    if not args:
        return await message.answer(f"üëã –ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}!")

    # 1. –†–µ–∑—É–ª—å—Ç–∞—Ç—ã (—á–µ—Ä–µ–∑ —Ç–∞–±–ª–∏—Ü—É Winners)
    if args.startswith("res_"):
        try: gw_id = int(args.replace("res_", ""))
        except: return
        
        # –ò—â–µ–º –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π –≤ —Ç–∞–±–ª–∏—Ü–µ
        stmt = select(Winner).where(Winner.giveaway_id == gw_id)
        winners = (await session.execute(stmt)).scalars().all()
        
        if not winners:
            return await message.answer("üòî –ü–æ–±–µ–¥–∏—Ç–µ–ª–µ–π –Ω–µ—Ç –∏–ª–∏ —Ä–æ–∑—ã–≥—Ä—ã—à –µ—â–µ –∏–¥–µ—Ç.")
            
        text = "üèÜ <b>–°–ø–∏—Å–æ–∫ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π:</b>\n"
        is_winner = False
        for i, w in enumerate(winners, 1):
            if w.user_id == message.from_user.id: is_winner = True
            try:
                c = await bot.get_chat(w.user_id)
                name = f"@{c.username}" if c.username else c.full_name
                text += f"{i}. {name}\n"
            except:
                text += f"{i}. ID {w.user_id}\n"
        
        if is_winner:
            text = "üéâ <b>–í–´ –í–´–ò–ì–†–ê–õ–ò!</b> üéâ\n\n" + text
            
        return await message.answer(text)

    # 2. –£—á–∞—Å—Ç–∏–µ
    if args.startswith("gw_"):
        # gw_100_a8b3c9...
        clean_args = args.replace("gw_", "")
        parts = clean_args.split("_")
        
        try:
            gw_id = int(parts[0])
        except ValueError:
            return await message.answer("‚ùå –°—Å—ã–ª–∫–∞ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∞.")

        referrer_id = None
        if len(parts) > 1:
            token = parts[1]
            # –•–æ–¥–∏–º –≤ Redis –∑–∞ —Ä–µ–∞–ª—å–Ω—ã–º ID
            candidate_id = await resolve_ref_link(token)
            
            if candidate_id and candidate_id != message.from_user.id:
                referrer_id = candidate_id

        if referrer_id:
            await state.update_data(referrer_id=referrer_id)
        
        await show_subscription_check(message, gw_id, session, bot)=== ./handlers/__init__.py ===
=== ./handlers/user/my_channels.py ===
from aiogram import Router, types, F, Bot
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from sqlalchemy.ext.asyncio import AsyncSession

from database.requests.channel_repo import add_channel, get_user_channels, delete_channel_by_id
from keyboards.inline.dashboard import channels_list_kb, back_to_dash, skip_link_kb

router = Router()

class ChannelState(StatesGroup):
    waiting_for_forward = State()
    waiting_for_link = State()

# --- –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø ---
async def show_channels_list_msg(message_or_call, session: AsyncSession, user_id: int):
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤. –†–∞–±–æ—Ç–∞–µ—Ç –∏ —Å Message, –∏ —Å CallbackQuery."""
    channels = await get_user_channels(session, user_id)
    text = "üì¢ <b>–ú–æ–∏ –∫–∞–Ω–∞–ª—ã</b>\n\n–°–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤, –≥–¥–µ –±–æ—Ç —è–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º."
    kb = channels_list_kb(channels)
    
    if isinstance(message_or_call, types.CallbackQuery):
        await message_or_call.message.edit_text(text, reply_markup=kb)
    else:
        # –ï—Å–ª–∏ –≤—ã–∑—ã–≤–∞–µ–º –∏–∑ message (–ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è)
        await message_or_call.answer(text, reply_markup=kb)

# --- –•–ï–ù–î–õ–ï–†–´ ---

@router.callback_query(F.data == "my_channels")
async def show_channels(call: types.CallbackQuery, session: AsyncSession):
    await show_channels_list_msg(call, session, call.from_user.id)

@router.callback_query(F.data == "add_new_channel")
async def ask_channel(call: types.CallbackQuery, state: FSMContext):
    await state.set_state(ChannelState.waiting_for_forward)
    await call.message.edit_text(
        "‚ûï <b>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–∞ (–®–∞–≥ 1/2)</b>\n\n"
        "1. –î–æ–±–∞–≤—å—Ç–µ –±–æ—Ç–∞ –≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –∫–∞–Ω–∞–ª–∞.\n"
        "2. –ü–µ—Ä–µ—à–ª–∏—Ç–µ —Å—é–¥–∞ –ª—é–±–æ–π –ø–æ—Å—Ç –∏–∑ –∫–∞–Ω–∞–ª–∞ (–∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ @username).",
        reply_markup=back_to_dash()
    )

@router.message(ChannelState.waiting_for_forward)
async def process_channel_step1(message: types.Message, state: FSMContext, bot: Bot):
    chat_id = None
    title = "No Title"
    username = None

    if message.forward_from_chat:
        chat_id = message.forward_from_chat.id
        title = message.forward_from_chat.title
        username = message.forward_from_chat.username
    elif message.text and message.text.startswith("@"):
        try:
            chat = await bot.get_chat(message.text)
            chat_id = chat.id
            title = chat.title
            username = chat.username
        except:
            await message.answer("‚ùå –ù–µ –º–æ–≥—É –Ω–∞–π—Ç–∏ –∫–∞–Ω–∞–ª. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ @username.")
            return

    if not chat_id:
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–∞–Ω–∞–ª. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ—Å–ª–∞—Ç—å –ø–æ—Å—Ç.")
        return

    try:
        member = await bot.get_chat_member(chat_id, bot.id)
        if member.status not in ("administrator", "creator"):
            await message.answer("‚ùå –ë–æ—Ç –Ω–µ –∞–¥–º–∏–Ω! –î–∞–π—Ç–µ –ø—Ä–∞–≤–∞ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
            return
    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞: {e}")
        return

    await state.update_data(temp_channel={"id": chat_id, "title": title, "username": username})
    
    await state.set_state(ChannelState.waiting_for_link)
    await message.answer(
        f"‚úÖ –ö–∞–Ω–∞–ª <b>{title}</b> –Ω–∞–π–¥–µ–Ω!\n\n"
        "üîó <b>–®–∞–≥ 2/2:</b> –ü—Ä–∏—à–ª–∏—Ç–µ –∏–Ω–≤–∞–π—Ç-—Å—Å—ã–ª–∫—É (–¥–ª—è –∫–Ω–æ–ø–∫–∏ '–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è') –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å.",
        reply_markup=skip_link_kb("settings")
    )

@router.message(ChannelState.waiting_for_link)
async def process_link_text(message: types.Message, state: FSMContext, session: AsyncSession):
    link = message.text.strip()
    if "t.me" not in link:
        await message.answer("‚ùå –≠—Ç–æ –Ω–µ –ø–æ—Ö–æ–∂–µ –Ω–∞ —Å—Å—ã–ª–∫—É.")
        return

    data = await state.get_data()
    ch_data = data['temp_channel']
    await add_channel(session, message.from_user.id, ch_data['id'], ch_data['title'], ch_data['username'], link)
    
    await message.answer(f"‚úÖ –ö–∞–Ω–∞–ª <b>{ch_data['title']}</b> —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω!")
    await state.clear()
    
    # –í–û–ó–í–†–ê–¢ –ö –°–ü–ò–°–ö–£ –ö–ê–ù–ê–õ–û–í
    await show_channels_list_msg(message, session, message.from_user.id)

@router.callback_query(ChannelState.waiting_for_link, F.data == "skip_link_settings")
async def process_link_skip(call: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    ch_data = data['temp_channel']
    
    auto_link = None
    if ch_data['username']: auto_link = f"@{ch_data['username']}"
    else:
        try: auto_link = await bot.export_chat_invite_link(ch_data['id'])
        except: pass

    await add_channel(session, call.from_user.id, ch_data['id'], ch_data['title'], ch_data['username'], auto_link)
    
    await call.message.delete()
    await call.message.answer(f"‚úÖ –ö–∞–Ω–∞–ª <b>{ch_data['title']}</b> —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω!")
    await state.clear()

    # –í–û–ó–í–†–ê–¢ –ö –°–ü–ò–°–ö–£ –ö–ê–ù–ê–õ–û–í
    await show_channels_list_msg(call.message, session, call.from_user.id)

@router.callback_query(F.data.startswith("del_ch_"))
async def delete_ch(call: types.CallbackQuery, session: AsyncSession):
    ch_id = int(call.data.split("_")[-1])
    await delete_channel_by_id(session, ch_id, call.from_user.id)
    await call.answer("üóë –ö–∞–Ω–∞–ª —É–¥–∞–ª–µ–Ω.")
    # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ (—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ)
    await show_channels(call, session)=== ./handlers/user/dashboard.py ===
from aiogram import Router, types, Bot, F
from aiogram.filters import CommandStart, CommandObject
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.exceptions import TelegramBadRequest # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∏—Å–∫–ª—é—á–µ–Ω–∏–µ

from database.requests.user_repo import register_user
from keyboards.inline.dashboard import start_menu_kb, cabinet_kb
from handlers.common.start import cmd_start as deep_link_logic

router = Router()

@router.message(CommandStart())
async def smart_dashboard(
    message: types.Message, 
    command: CommandObject, 
    session: AsyncSession, 
    bot: Bot,
    state: FSMContext
):
    # DeepLink (—Ä–µ—Ñ–∫–∏ –∏ —É—á–∞—Å—Ç–∏–µ)
    if command.args and (command.args.startswith("gw_") or command.args.startswith("res_")):
        await deep_link_logic(message, command, session, bot, state)
        return

    # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è
    await register_user(session, message.from_user.id, message.from_user.username, message.from_user.full_name)
    
    text = (
        f"üëã <b>–ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}!</b>\n"
        f"–≠—Ç–æ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞ –¥–ª—è –ø—Ä–æ–≤–µ–¥–µ–Ω–∏—è —á–µ—Å—Ç–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π.\n\n"
        f"–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:"
    )

    await message.answer(text, reply_markup=start_menu_kb())

@router.callback_query(F.data == "dashboard_home")
async def back_home(call: types.CallbackQuery):
    try:
        await call.message.edit_text(
            "üëã <b>–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", 
            reply_markup=start_menu_kb()
        )
    except TelegramBadRequest:
        # –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å - –ø—Ä–æ—Å—Ç–æ –æ—Ç–≤–µ—á–∞–µ–º –Ω–∞ callback, —á—Ç–æ–±—ã —É–±—Ä–∞—Ç—å —á–∞—Å–∏–∫–∏
        await call.answer()

@router.callback_query(F.data == "cabinet_hub")
async def open_cabinet(call: types.CallbackQuery, session: AsyncSession):
    text = (
        "üë§ <b>–ö–∞–±–∏–Ω–µ—Ç –æ—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä–∞</b>\n\n"
        f"üÜî ID: <code>{call.from_user.id}</code>\n"
        "üìä –ó–¥–µ—Å—å –≤—ã —É–ø—Ä–∞–≤–ª—è–µ—Ç–µ –∫–∞–Ω–∞–ª–∞–º–∏ –∏ –ø–æ–¥–ø–∏—Å–∫–æ–π."
    )
    try:
        await call.message.edit_text(text, reply_markup=cabinet_kb())
    except TelegramBadRequest:
        await call.answer()=== ./handlers/user/premium.py ===
from aiogram import Router, types, F, Bot
from aiogram.types import LabeledPrice, PreCheckoutQuery
from sqlalchemy.ext.asyncio import AsyncSession
from database.models.user import User
from keyboards.inline.dashboard import premium_shop_kb

router = Router()

@router.callback_query(F.data == "premium_shop")
async def show_shop(call: types.CallbackQuery, session: AsyncSession):
    user = await session.get(User, call.from_user.id)
    status_text = "‚úÖ <b>–£ –≤–∞—Å –∞–∫—Ç–∏–≤–µ–Ω Premium!</b>" if user.is_premium else "‚ùå –£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏."
    
    text = (
        "üß© <b>–ü–ª–∞—Ç–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏</b>\n\n"
        f"–í–∞—à —Å—Ç–∞—Ç—É—Å: {status_text}\n\n"
        "<b>üõ° –ó–∞—â–∏—Ç–∞ –æ—Ç –±–æ—Ç–æ–≤ (–ö–∞–ø—á–∞)</b>\n"
        "–ó–∞—Å—Ç–∞–≤–ª—è–µ—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –ø—Ä–æ–π—Ç–∏ –ø—Ä–æ–≤–µ—Ä–∫—É –ø–µ—Ä–µ–¥ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–µ–π. "
        "–û—Ç—Å–µ–∏–≤–∞–µ—Ç 99% –Ω–∞–∫—Ä—É—Ç–∫–∏.\n\n"
        "–°—Ç–æ–∏–º–æ—Å—Ç—å: <b>50 ‚≠êÔ∏è Stars</b>"
    )
    await call.message.edit_text(text, reply_markup=premium_shop_kb())

@router.callback_query(F.data == "buy_captcha")
async def buy_process(call: types.CallbackQuery, bot: Bot):
    await bot.send_invoice(
        chat_id=call.from_user.id,
        title="Premium –ü–æ–¥–ø–∏—Å–∫–∞",
        description="–ê–∫—Ç–∏–≤–∞—Ü–∏—è –ö–∞–ø—á–∏ (–ó–∞—â–∏—Ç–∞ –æ—Ç –±–æ—Ç–æ–≤)",
        payload="buy_premium_captcha", 
        currency="XTR", 
        prices=[LabeledPrice(label="Premium", amount=50)], 
        provider_token="" # –í–ê–ñ–ù–û: –î–ª—è Telegram Stars –ø–æ–ª–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø—É—Å—Ç—ã–º!
    )
    await call.answer()

@router.pre_checkout_query()
async def on_pre_checkout(pre_checkout_query: PreCheckoutQuery, bot: Bot):
    await bot.answer_pre_checkout_query(pre_checkout_query.id, ok=True)

@router.message(F.successful_payment)
async def on_successful_payment(message: types.Message, session: AsyncSession):
    payment = message.successful_payment
    
    if payment.invoice_payload == "buy_premium_captcha":
        user = await session.get(User, message.from_user.id)
        if user:
            user.is_premium = True
            await session.commit()
            
            await message.answer(
                "üéâ <b>–û–ø–ª–∞—Ç–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ!</b>\n"
                "–§—É–Ω–∫—Ü–∏—è ¬´–ö–∞–ø—á–∞¬ª —Ç–µ–ø–µ—Ä—å –¥–æ—Å—Ç—É–ø–Ω–∞ –≤ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–µ.\n\n"
            )=== ./handlers/user/__init__.py ===
=== ./handlers/user/my_giveaways.py ===
from aiogram import Router, types, Bot, F
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import delete

from database.requests.giveaway_repo import get_giveaways_by_owner, get_giveaway_by_id, count_giveaways_by_status
from database.models.giveaway import Giveaway
from database.models.winner import Winner
from database.models.participant import Participant
from database.models.required_channel import GiveawayRequiredChannel
from keyboards.inline.dashboard import my_giveaways_hub_kb, giveaways_list_kb, active_gw_manage_kb, finished_gw_manage_kb
from core.logic.game_actions import finish_giveaway_task
from keyboards.inline.participation import join_keyboard
from core.tools.formatters import format_giveaway_caption

router = Router()

# --- –•–ê–ë ---
@router.callback_query(F.data == "my_giveaways_hub")
async def show_gw_hub(call: types.CallbackQuery, session: AsyncSession):
    user_id = call.from_user.id
    
    # –°—á–∏—Ç–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–ª—è –∫–Ω–æ–ø–æ–∫
    active_count = await count_giveaways_by_status(session, user_id, "active")
    finished_count = await count_giveaways_by_status(session, user_id, "finished")
    
    await call.message.edit_text(
        "üìÇ <b>–ò—Å—Ç–æ—Ä–∏—è —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π</b>\n–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:", 
        reply_markup=my_giveaways_hub_kb(active_count, finished_count)
    )

# --- –°–ü–ò–°–ö–ò ---
@router.callback_query(F.data.startswith("gw_list:"))
async def show_gw_list(call: types.CallbackQuery, session: AsyncSession):
    status = call.data.split(":")[1]
    user_id = call.from_user.id
    
    gws = await get_giveaways_by_owner(session, user_id, limit=50)
    filtered = [g for g in gws if g.status == status]
    
    if not filtered:
        return await call.answer("üì≠ –í —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø—É—Å—Ç–æ.", show_alert=True)
    
    title = "–ê–∫—Ç—É–∞–ª—å–Ω—ã–µ" if status == 'active' else "–ó–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ"
    await call.message.edit_text(
        f"üìÇ <b>{title} —Ä–æ–∑—ã–≥—Ä—ã—à–∏</b>",
        reply_markup=giveaways_list_kb(filtered, status)
    )

# --- –£–ü–†–ê–í–õ–ï–ù–ò–ï ---
@router.callback_query(F.data.startswith("gw_manage:"))
async def manage_gw(call: types.CallbackQuery, session: AsyncSession, bot: Bot):
    gw_id = int(call.data.split(":")[1])
    gw = await get_giveaway_by_id(session, gw_id)
    
    if not gw: return await call.answer("–ù–µ –Ω–∞–π–¥–µ–Ω–æ")
    
    stats_info = f"üèÜ –ü—Ä–∏–∑: {gw.prize_text}\nüìÖ –§–∏–Ω–∏—à: {gw.finish_time.strftime('%d.%m %H:%M')}"
    
    if gw.status == "active":
        await call.message.edit_text(f"üü¢ <b>–ê–∫—Ç–∏–≤–Ω—ã–π —Ä–æ–∑—ã–≥—Ä—ã—à #{gw.id}</b>\n\n{stats_info}", reply_markup=active_gw_manage_kb(gw.id))
    else:
        link = None
        try:
            chat = await bot.get_chat(gw.channel_id)
            if chat.username: link = f"https://t.me/{chat.username}/{gw.message_id}"
        except: pass
        
        await call.message.edit_text(f"‚ö´Ô∏è <b>–ó–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–π —Ä–æ–∑—ã–≥—Ä—ã—à #{gw.id}</b>\n\n{stats_info}", reply_markup=finished_gw_manage_kb(gw.id, link))

# --- –î–ï–ô–°–¢–í–ò–Ø ---

# 1. –†–ï–ü–û–°–¢
@router.callback_query(F.data.startswith("gw_act:repost:"))
async def repost_gw(call: types.CallbackQuery, session: AsyncSession, bot: Bot):
    gw_id = int(call.data.split(":")[2])
    gw = await get_giveaway_by_id(session, gw_id)
    if not gw or gw.status != 'active': return await call.answer("–û—à–∏–±–∫–∞ —Å—Ç–∞—Ç—É—Å–∞", show_alert=True)
    
    # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –ø–æ—Å—Ç
    try:
        await bot.delete_message(gw.channel_id, gw.message_id)
    except: pass

    bot_info = await bot.get_me()
    kb = join_keyboard(bot_info.username, gw.id)
    
    from database.requests.participant_repo import get_participants_count
    from core.tools.timezone import to_utc
    
    count = await get_participants_count(session, gw_id)
    caption = format_giveaway_caption(gw.prize_text, gw.winners_count, to_utc(gw.finish_time), count)
    
    try:
        if gw.media_file_id and gw.media_type:
            if gw.media_type == 'photo':
                msg = await bot.send_photo(gw.channel_id, gw.media_file_id, caption=caption, reply_markup=kb)
            elif gw.media_type == 'video':
                msg = await bot.send_video(gw.channel_id, gw.media_file_id, caption=caption, reply_markup=kb)
            else:
                msg = await bot.send_message(gw.channel_id, text=caption, reply_markup=kb)
        else:
             msg = await bot.send_message(gw.channel_id, text=caption, reply_markup=kb)
        
        gw.message_id = msg.message_id
        await session.commit()
        await call.answer("‚úÖ –ü–æ—Å—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω –ø–æ–≤—Ç–æ—Ä–Ω–æ!", show_alert=True)
    except Exception as e:
        await call.answer(f"–û—à–∏–±–∫–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏: {e}", show_alert=True)

# 2. –ó–ê–í–ï–†–®–ï–ù–ò–ï
@router.callback_query(F.data.startswith("gw_act:finish:"))
async def finish_gw_now(call: types.CallbackQuery):
    gw_id = int(call.data.split(":")[2])
    await call.answer("–ó–∞–≤–µ—Ä—à–∞—é...", show_alert=False)
    await finish_giveaway_task(gw_id)
    await call.message.edit_text("‚úÖ –†–æ–∑—ã–≥—Ä—ã—à –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω.")

# 3. –£–î–ê–õ–ï–ù–ò–ï
@router.callback_query(F.data.startswith("gw_act:delete:"))
async def delete_gw(call: types.CallbackQuery, session: AsyncSession, bot: Bot):
    gw_id = int(call.data.split(":")[2])
    gw = await get_giveaway_by_id(session, gw_id)
    
    if gw:
        try:
            await bot.delete_message(gw.channel_id, gw.message_id)
        except: pass
        
        # –£–¥–∞–ª—è–µ–º –≤—Å—ë —Å–≤—è–∑–∞–Ω–Ω–æ–µ
        await session.execute(delete(Winner).where(Winner.giveaway_id == gw_id))
        await session.execute(delete(Participant).where(Participant.giveaway_id == gw_id))
        await session.execute(delete(GiveawayRequiredChannel).where(GiveawayRequiredChannel.giveaway_id == gw_id))
        await session.delete(gw)
        await session.commit()
        
    await call.answer("üóë –†–æ–∑—ã–≥—Ä—ã—à —É–¥–∞–ª–µ–Ω.", show_alert=True)
    await show_gw_hub(call, session)=== ./handlers/user/my_participations.py ===
import math
from aiogram import Router, types, F, Bot
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from database.models.winner import Winner  # <--- –í–ê–ñ–ù–û
from database.requests.participant_repo import get_user_participations_detailed, count_user_participations
from database.requests.giveaway_repo import get_giveaway_by_id, get_giveaways_by_owner, count_giveaways_by_owner
from database.requests.user_repo import get_user_stats
from keyboards.inline.user_panel import giveaways_hub_kb, universal_list_kb, participation_details_kb, detail_back_kb

router = Router()

# 1. –•–ê–ë (–ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ –†–ê–ó–î–ï–õ–ê)
@router.callback_query(F.data == "giveaways_hub")
async def show_hub(call: types.CallbackQuery, session: AsyncSession):
    stats = await get_user_stats(session, call.from_user.id)
    has_created = (stats['active'] + stats['finished']) > 0
    
    await call.message.edit_text(
        "üéÅ <b>–†–∞–∑–¥–µ–ª: –†–æ–∑—ã–≥—Ä—ã—à–∏</b>\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:",
        reply_markup=giveaways_hub_kb(has_created)
    )

# 2. –°–ü–ò–°–û–ö –£–ß–ê–°–¢–ò–ô (–ê–∫—Ç–∏–≤–Ω—ã–µ / –ó–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ)
@router.callback_query(F.data.startswith("part_list:"))
async def show_participation_list(call: types.CallbackQuery, session: AsyncSession):
    # part_list:active:0
    _, status, page_str = call.data.split(":")
    page = int(page_str)
    limit = 5
    offset = page * limit
    user_id = call.from_user.id
    
    # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π
    giveaways = await get_user_participations_detailed(session, user_id, status, limit, offset)
    total_count = await count_user_participations(session, user_id, status)
    
    if total_count == 0:
        return await call.answer("üì≠ –ó–¥–µ—Å—å –ø–æ–∫–∞ –ø—É—Å—Ç–æ.", show_alert=True)
        
    total_pages = math.ceil(total_count / limit)
    status_text = "–í –∫–æ—Ç–æ—Ä—ã—Ö —É—á–∞—Å—Ç–≤—É—é" if status == 'active' else "–ó–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ (–£—á–∞—Å—Ç–∏–µ)"
    prefix = f"part_list:{status}"
    
    # --- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –ø–æ–±–µ–¥ ---
    won_ids = set()
    if status == 'finished' and giveaways:
        # –°–æ–±–∏—Ä–∞–µ–º ID –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π
        gw_ids = [gw.id for gw in giveaways]
        # –°–º–æ—Ç—Ä–∏–º, –≤ –∫–∞–∫–∏—Ö –∏–∑ –Ω–∏—Ö —é–∑–µ—Ä –µ—Å—Ç—å –≤ —Ç–∞–±–ª–∏—Ü–µ winners
        stmt = select(Winner.giveaway_id).where(
            Winner.giveaway_id.in_(gw_ids),
            Winner.user_id == user_id
        )
        result = await session.execute(stmt)
        won_ids = set(result.scalars().all())
    # ------------------------------------------
    
    await call.message.edit_text(
        f"üìÇ <b>{status_text}</b>\n–°—Ç—Ä–∞–Ω–∏—Ü–∞ {page+1} –∏–∑ {total_pages}",
        reply_markup=universal_list_kb(giveaways, page, total_pages, prefix, won_ids=won_ids)
    )

# 3. –°–ü–ò–°–û–ö –°–û–ó–î–ê–ù–ù–´–• –ú–ù–û–ô
@router.callback_query(F.data.startswith("created_list:"))
async def show_created_list(call: types.CallbackQuery, session: AsyncSession):
    # created_list:0
    _, page_str = call.data.split(":")
    page = int(page_str)
    limit = 5
    offset = page * limit
    user_id = call.from_user.id
    
    giveaways = await get_giveaways_by_owner(session, user_id, limit, offset)
    total_count = await count_giveaways_by_owner(session, user_id)
    
    if total_count == 0:
        return await call.answer("üì≠ –í—ã –µ—â–µ –Ω–µ —Å–æ–∑–¥–∞–≤–∞–ª–∏ —Ä–æ–∑—ã–≥—Ä—ã—à–∏.", show_alert=True)
        
    total_pages = math.ceil(total_count / limit)
    
    await call.message.edit_text(
        f"üìÇ <b>–ú–æ–∏ —Ä–æ–∑—ã–≥—Ä—ã—à–∏ (–°–æ–∑–¥–∞–Ω–Ω—ã–µ)</b>\n–°—Ç—Ä–∞–Ω–∏—Ü–∞ {page+1} –∏–∑ {total_pages}",
        reply_markup=universal_list_kb(giveaways, page, total_pages, "created_list", user_id=user_id)
    )

# 4. –ü–†–û–°–ú–û–¢–† –î–ï–¢–ê–õ–ï–ô (–£–ß–ê–°–¢–ò–ï)
@router.callback_query(F.data.startswith("part_view:"))
async def view_participation(call: types.CallbackQuery, session: AsyncSession, bot: Bot):
    gw_id = int(call.data.split(":")[-1])
    gw = await get_giveaway_by_id(session, gw_id)
    if not gw: return await call.answer("–ù–µ –Ω–∞–π–¥–µ–Ω–æ")

    user_id = call.from_user.id
    
    if gw.status == 'active':
        st_text = "‚è≥ –ê–∫—Ç–∏–≤–µ–Ω"
        res_text = "ü§û –í—ã —É—á–∞—Å—Ç–≤—É–µ—Ç–µ"
    else:
        st_text = "üèÅ –ó–∞–≤–µ—Ä—à–µ–Ω"
        # --- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ä–µ–∑ —Ç–∞–±–ª–∏—Ü—É Winner ---
        winner_check = await session.scalar(
            select(Winner).where(Winner.giveaway_id == gw.id, Winner.user_id == user_id)
        )
        
        if winner_check:
            res_text = "üèÜ <b>–í–´ –í–´–ò–ì–†–ê–õ–ò!</b>"
        else:
            res_text = "‚ùå –í—ã –Ω–µ –≤—ã–∏–≥—Ä–∞–ª–∏"
        # --------------------------------------------------

    post_link = None
    try:
        chat = await bot.get_chat(gw.channel_id)
        if chat.username: 
            post_link = f"https://t.me/{chat.username}/{gw.message_id}"
        elif chat.invite_link:
             # –ï—Å–ª–∏ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–∞–Ω–∞–ª, —Å—Å—ã–ª–∫—É –Ω–∞ –ø–æ—Å—Ç —Å–ª–æ–∂–Ω–æ –¥–∞—Ç—å, –¥–∞–µ–º –Ω–∞ –∫–∞–Ω–∞–ª
             post_link = chat.invite_link
    except: pass

    await call.message.edit_text(
        f"üéÅ <b>{gw.prize_text}</b>\n\n–°—Ç–∞—Ç—É—Å: {st_text}\n{res_text}",
        reply_markup=participation_details_kb(post_link)
    )

# 5. –ü–†–û–°–ú–û–¢–† –î–ï–¢–ê–õ–ï–ô (–°–û–ó–î–ê–ù–ù–´–ô)
@router.callback_query(F.data.startswith("view_created:"))
async def view_created(call: types.CallbackQuery, session: AsyncSession):
    gw_id = int(call.data.split(":")[-1])
    gw = await get_giveaway_by_id(session, gw_id)
    if not gw: return await call.answer("–ù–µ –Ω–∞–π–¥–µ–Ω–æ")
    
    await call.message.edit_text(
        f"üì¢ <b>–í–∞—à —Ä–æ–∑—ã–≥—Ä—ã—à #{gw.id}</b>\n\n"
        f"üìù –ü—Ä–∏–∑: {gw.prize_text}\n"
        f"üë• –ü–æ–±–µ–¥–∏—Ç–µ–ª–µ–π: {gw.winners_count}\n"
        f"üìÖ –§–∏–Ω–∏—à: {gw.finish_time.strftime('%Y-%m-%d %H:%M')}\n"
        f"‚öôÔ∏è –°—Ç–∞—Ç—É—Å: {gw.status}",
        reply_markup=detail_back_kb()
    )

@router.callback_query(F.data == "ignore")
async def ignore(call: types.CallbackQuery): await call.answer()
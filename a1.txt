=== ./keyboards/inline/calendar_kb.py ===
import calendar
from datetime import datetime
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from core.tools.timezone import get_now_msk

MONTHS = ["", "–Ø–Ω–≤–∞—Ä—å", "–§–µ–≤—Ä–∞–ª—å", "–ú–∞—Ä—Ç", "–ê–ø—Ä–µ–ª—å", "–ú–∞–π", "–ò—é–Ω—å", "–ò—é–ª—å", "–ê–≤–≥—É—Å—Ç", "–°–µ–Ω—Ç—è–±—Ä—å", "–û–∫—Ç—è–±—Ä—å", "–ù–æ—è–±—Ä—å", "–î–µ–∫–∞–±—Ä—å"]

def generate_calendar(year: int, month: int) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    now = get_now_msk()

    builder.button(text=f"{MONTHS[month]} {year}", callback_data="ignore")
    days = ["–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±", "–í—Å"]
    for d in days:
        builder.button(text=d, callback_data="ignore")

    cal = calendar.monthcalendar(year, month)
    for week in cal:
        for day in week:
            if day == 0:
                builder.button(text=" ", callback_data="ignore")
                continue
            
            # –õ–æ–≥–∏–∫–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –ø—Ä–æ—à–ª–æ–≥–æ
            is_past = False
            if year < now.year: is_past = True
            elif year == now.year and month < now.month: is_past = True
            elif year == now.year and month == now.month and day < now.day: is_past = True
            
            if is_past:
                # –í–º–µ—Å—Ç–æ —Ü–∏—Ñ—Ä—ã —Å—Ç–∞–≤–∏–º –ø—Ä–æ—á–µ—Ä–∫ –∏–ª–∏ –∫—Ä–µ—Å—Ç–∏–∫
                builder.button(text="‚úñÔ∏è", callback_data="ignore")
            else:
                builder.button(text=str(day), callback_data=f"date_set:{year}:{month}:{day}")

    builder.adjust(1, 7, 7, 7, 7, 7, 7)
    
    # –ù–∞–≤–∏–≥–∞—Ü–∏—è (–Ω–µ –¥–∞–µ–º —É–π—Ç–∏ –¥–∞–ª–µ–∫–æ –≤ –ø—Ä–æ—à–ª–æ–µ)
    prev_m = month - 1 if month > 1 else 12
    prev_y = year if month > 1 else year - 1
    next_m = month + 1 if month < 12 else 1
    next_y = year if month < 12 else year + 1
    
    can_go_back = not (prev_y < now.year or (prev_y == now.year and prev_m < now.month))
    
    nav_row = []
    if can_go_back:
        builder.button(text="‚¨ÖÔ∏è", callback_data=f"cal_nav:{prev_y}:{prev_m}")
    else:
        builder.button(text=" ", callback_data="ignore") # –ü—É—Å—Ç—ã—à–∫–∞ –¥–ª—è –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è
        
    builder.button(text="‚û°Ô∏è", callback_data=f"cal_nav:{next_y}:{next_m}")
    
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="constr_back_main")
    
    # –ü–æ—Å–ª–µ–¥–Ω–∏–π —Ä—è–¥: –ù–∞–≤–∏–≥–∞—Ü–∏—è + –ù–∞–∑–∞–¥
    builder.adjust(1, 7, 7, 7, 7, 7, 7, 2, 1)
    return builder.as_markup()

def time_picker_kb(year, month, day) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    now = get_now_msk()
    
    # –ï—Å–ª–∏ –≤—ã–±—Ä–∞–Ω "—Å–µ–≥–æ–¥–Ω—è", –±–ª–æ–∫–∏—Ä—É–µ–º –ø—Ä–æ—à–µ–¥—à–∏–µ —á–∞—Å—ã
    is_today = (year == now.year and month == now.month and day == now.day)
    current_hour = now.hour
    
    for h in range(0, 24):
        if is_today and h <= current_hour:
            # –ü—Ä–æ—à–µ–¥—à–∏–µ —á–∞—Å—ã –ø–æ–º–µ—á–∞–µ–º —Ç–æ—á–∫–æ–π –∏–ª–∏ —É–¥–∞–ª—è–µ–º
            builder.button(text="‚Ä¢", callback_data="ignore")
        else:
            builder.button(text=f"{h:02d}:00", callback_data=f"time_set:{year}:{month}:{day}:{h}:00")
        
    builder.adjust(4)
    builder.row(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥ –∫ –¥–∞—Ç–µ", callback_data=f"cal_nav:{year}:{month}"))
    return builder.as_markup()=== ./keyboards/inline/user_panel.py ===
from aiogram.utils.keyboard import InlineKeyboardBuilder
from database.models.giveaway import Giveaway

def giveaways_hub_kb(has_created: bool, active_count: int, finished_count: int) -> InlineKeyboardBuilder:
    builder = InlineKeyboardBuilder()
    
    # –†–∞–∑–¥–µ–ª —É—á–∞—Å—Ç–Ω–∏–∫–∞ (–°—á–µ—Ç—á–∏–∫–∏!)
    builder.button(text=f"‚è≥ –£—á–∞—Å—Ç–≤—É—é ({active_count})", callback_data="part_list:active:0")
    builder.button(text=f"üèÅ –ó–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ ({finished_count})", callback_data="part_list:finished:0")
    
    # –†–∞–∑–¥–µ–ª —Å–æ–∑–¥–∞—Ç–µ–ª—è
    if has_created:
        builder.button(text="üìÇ –ú–æ–∏ —Ä–æ–∑—ã–≥—Ä—ã—à–∏ (–°–æ–∑–¥–∞–Ω–Ω—ã–µ)", callback_data="created_list:0")
        
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="dashboard_home")
    builder.adjust(1)
    return builder.as_markup()

def universal_list_kb(
    giveaways: list[Giveaway], 
    page: int, 
    total_pages: int, 
    prefix: str, 
    won_ids: set[int] = None
) -> InlineKeyboardBuilder:
    """
    –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫.
    """
    builder = InlineKeyboardBuilder()
    won_ids = won_ids or set()
    
    for gw in giveaways:
        # –í—ã–±–∏—Ä–∞–µ–º –∏–∫–æ–Ω–∫—É
        if "created" in prefix:
            icon = "üì¢"
        elif gw.status == 'active':
            icon = "‚è≥"
        else:
            if gw.id in won_ids:
                icon = "üèÜ"
            else:
                icon = "‚ùå"
        
        btn_text = f"{icon} {gw.prize_text[:20]}..."
        
        action = "view_created" if "created" in prefix else "part_view"
        builder.button(text=btn_text, callback_data=f"{action}:{gw.id}")

    # –ü–∞–≥–∏–Ω–∞—Ü–∏—è
    nav_buttons = []
    if page > 0:
        nav_buttons.append(("‚¨ÖÔ∏è", f"{prefix}:{page-1}"))
    
    nav_buttons.append((f"{page+1}/{total_pages}", "ignore"))
    
    if page < total_pages - 1:
        nav_buttons.append(("‚û°Ô∏è", f"{prefix}:{page+1}"))
    
    for text, data in nav_buttons:
        builder.button(text=text, callback_data=data)
    
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="giveaways_hub")
    
    sizes = [1] * len(giveaways) + [len(nav_buttons)] + [1]
    builder.adjust(*sizes)
    return builder.as_markup()

def participation_details_kb(channel_link: str) -> InlineKeyboardBuilder:
    builder = InlineKeyboardBuilder()
    if channel_link:
        builder.button(text="‚ÜóÔ∏è –ü–µ—Ä–µ–π—Ç–∏ –∫ –ø–æ—Å—Ç—É", url=channel_link)
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="giveaways_hub")
    builder.adjust(1)
    return builder.as_markup()

def detail_back_kb() -> InlineKeyboardBuilder:
    builder = InlineKeyboardBuilder()
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="giveaways_hub")
    return builder.as_markup()=== ./keyboards/inline/participation.py ===
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder

def join_keyboard(bot_username: str, giveaway_id: int) -> InlineKeyboardMarkup:
    """–ö–Ω–æ–ø–∫–∞ –ø–æ–¥ –ø–æ—Å—Ç–æ–º –≤ –∫–∞–Ω–∞–ª–µ"""
    url = f"https://t.me/{bot_username}?start=gw_{giveaway_id}"
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="–£—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å üéÅ", url=url)]
    ])

def check_subscription_kb(gw_id: int, channels_status: list) -> InlineKeyboardMarkup:
    """
    –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å–æ —Å–ø–∏—Å–∫–æ–º –∫–∞–Ω–∞–ª–æ–≤.
    channels_status: —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤–∞—Ä–µ–π {'title': str, 'link': str, 'is_subscribed': bool}
    """
    builder = InlineKeyboardBuilder()
    
    for ch in channels_status:
        if ch['is_subscribed']:
            # –ï—Å–ª–∏ –ø–æ–¥–ø–∏—Å–∞–Ω - —Å—Ç–∞–≤–∏–º –≥–∞–ª–æ—á–∫—É
            text = f"‚úÖ {ch['title']}"
        else:
            # –ï—Å–ª–∏ –Ω–µ—Ç - —Å—Ç–∞–≤–∏–º —Ä—É–ø–æ—Ä
            text = f"üì¢ {ch['title']}"
            
        # –°—Å—ã–ª–∫–∞ –Ω—É–∂–Ω–∞ –≤ –ª—é–±–æ–º —Å–ª—É—á–∞–µ
        builder.button(text=text, url=ch['link'])
    
    # –ö–Ω–æ–ø–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏
    builder.button(text="üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫–∏", callback_data=f"check_sub:{gw_id}")
    
    builder.adjust(1)
    return builder.as_markup()

def results_keyboard(bot_username: str, giveaway_id: int) -> InlineKeyboardMarkup:
    url = f"https://t.me/{bot_username}?start=res_{giveaway_id}"
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üìã –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã", url=url)]
    ])=== ./keyboards/inline/dashboard.py ===
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from database.models.channel import Channel
from database.models.giveaway import Giveaway

# --- –ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ (/start) ---
def start_menu_kb() -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    # –ë–´–õ–û: "üé´ –ú–æ–∏ —É—á–∞—Å—Ç–∏—è" -> –°–¢–ê–õ–û: "üéÅ –†–æ–∑—ã–≥—Ä—ã—à–∏"
    builder.button(text="üéÅ –†–æ–∑—ã–≥—Ä—ã—à–∏", callback_data="my_participations")
    builder.button(text="‚ú® –°–æ–∑–¥–∞—Ç—å —Ä–æ–∑—ã–≥—Ä—ã—à", callback_data="create_gw_init")
    builder.button(text="üë§ –õ–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç", callback_data="cabinet_hub")
    builder.adjust(1)
    return builder.as_markup()

# --- –õ–ò–ß–ù–´–ô –ö–ê–ë–ò–ù–ï–¢ ---
def cabinet_kb() -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    builder.button(text="‚öôÔ∏è –ú–æ–∏ –∫–∞–Ω–∞–ª—ã", callback_data="my_channels")
    builder.button(text="üìÇ –ò—Å—Ç–æ—Ä–∏—è —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π", callback_data="my_giveaways_hub")
    builder.button(text="üß© –ü–ª–∞—Ç–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏", callback_data="premium_shop")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="dashboard_home")
    builder.adjust(1)
    return builder.as_markup()

# --- –ú–ï–ù–Æ –†–û–ó–´–ì–†–´–®–ï–ô (HUB –û–†–ì–ê–ù–ò–ó–ê–¢–û–†–ê) ---
def my_giveaways_hub_kb(active_count: int, finished_count: int) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    builder.button(text=f"–ê–∫—Ç—É–∞–ª—å–Ω—ã–µ ({active_count})", callback_data="gw_list:active")
    builder.button(text=f"–ó–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ ({finished_count})", callback_data="gw_list:finished")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="cabinet_hub")
    builder.adjust(1)
    return builder.as_markup()

# --- –°–ü–ò–°–û–ö –†–û–ó–´–ì–†–´–®–ï–ô ---
def giveaways_list_kb(giveaways: list[Giveaway], status: str) -> InlineKeyboardBuilder:
    builder = InlineKeyboardBuilder()
    
    for gw in giveaways:
        icon = "üü¢" if status == "active" else "‚ö´Ô∏è"
        name = gw.prize_text[:25].replace("\n", " ")
        builder.button(text=f"{icon} {name}...", callback_data=f"gw_manage:{gw.id}")
    
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="my_giveaways_hub")
    builder.adjust(1)
    return builder.as_markup()

# --- –£–ü–†–ê–í–õ–ï–ù–ò–ï –ê–ö–¢–ò–í–ù–´–ú ---
def active_gw_manage_kb(gw_id: int) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    builder.button(text="üîÑ –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø—É–±–ª–∏–∫–∞—Ü–∏—è", callback_data=f"gw_act:repost:{gw_id}")
    builder.button(text="üõë –ó–∞–≤–µ—Ä—à–∏—Ç—å –¥–æ—Å—Ä–æ—á–Ω–æ", callback_data=f"gw_act:finish:{gw_id}")
    builder.button(text="üóë –£–¥–∞–ª–∏—Ç—å", callback_data=f"gw_act:delete:{gw_id}")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="gw_list:active")
    builder.adjust(1)
    return builder.as_markup()

# --- –£–ü–†–ê–í–õ–ï–ù–ò–ï –ó–ê–í–ï–†–®–ï–ù–ù–´–ú ---
def finished_gw_manage_kb(gw_id: int, results_link: str = None) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    if results_link:
        builder.button(text="üîó –ü–µ—Ä–µ–π—Ç–∏ –∫ –ø–æ—Å—Ç—É", url=results_link)
    builder.button(text="üóë –£–¥–∞–ª–∏—Ç—å –∏–∑ –±–∞–∑—ã", callback_data=f"gw_act:delete:{gw_id}")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="gw_list:finished")
    builder.adjust(1)
    return builder.as_markup()

# --- –ú–ê–ì–ê–ó–ò–ù (PREMIUM) ---
def premium_shop_kb() -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    builder.button(text="üõ° –ö—É–ø–∏—Ç—å –ö–∞–ø—á—É (50 ‚≠êÔ∏è)", callback_data="buy_captcha")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="cabinet_hub")
    builder.adjust(1)
    return builder.as_markup()

# --- –ö–ê–ù–ê–õ–´ ---
def channels_list_kb(channels: list[Channel]) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    for ch in channels:
        builder.button(text=f"üóë {ch.title}", callback_data=f"del_ch_{ch.id}")
    builder.button(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–∞–Ω–∞–ª", callback_data="add_new_channel")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="cabinet_hub")
    builder.adjust(1)
    return builder.as_markup()

def back_to_dash() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="cabinet_hub")]
    ])

def skip_link_kb(mode="settings") -> InlineKeyboardMarkup:
    callback = "skip_link_settings" if mode == "settings" else "skip_link_constr"
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚è© –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data=callback)]
    ])=== ./keyboards/inline/constructor.py ===
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from database.models.channel import Channel

def constructor_main_kb(
    time_str: str, winners: int, 
    ref_req: int, # –ï—Å–ª–∏ 0 - –≤—ã–∫–ª, –∏–Ω–∞—á–µ –∫–æ–ª-–≤–æ –¥—Ä—É–∑–µ–π
    is_captcha: bool, has_main_channel: bool, sponsors_count: int
) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    
    main_text = "üì¢ –ö–∞–Ω–∞–ª: –í—ã–±—Ä–∞—Ç—å" if not has_main_channel else "üì¢ –ö–∞–Ω–∞–ª: ‚úÖ –í—ã–±—Ä–∞–Ω"
    sponsor_text = f"ü§ù –°–ø–æ–Ω—Å–æ—Ä—ã: {sponsors_count}" if sponsors_count > 0 else "ü§ù –°–ø–æ–Ω—Å–æ—Ä—ã: –ù–µ—Ç"
    builder.button(text=main_text, callback_data="constr_select_main")
    builder.button(text=sponsor_text, callback_data="constr_select_sponsors")
    
    builder.button(text=f"‚è≥ –ò—Ç–æ–≥–∏: {time_str}", callback_data="constr_time_menu")
    builder.button(text=f"üèÜ –ü–æ–±–µ–¥–∏—Ç–µ–ª–∏: {winners}", callback_data="constr_winners_menu")
    
    ref_text = f"üîó –†–µ—Ñ: {ref_req} –¥—Ä—É–∑–µ(–π)" if ref_req > 0 else "üîó –†–µ—Ñ: –í—ã–∫–ª"
    builder.button(text=ref_text, callback_data="constr_ref_menu")
    
    cap_status = "–í–ö–õ" if is_captcha else "–í—ã–∫–ª"
    builder.button(text=f"üõ° –ö–∞–ø—á–∞: {cap_status}", callback_data="constr_toggle_cap")
    
    builder.button(text="‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å –¢–µ–∫—Å—Ç/–ú–µ–¥–∏–∞", callback_data="constr_edit_content")
    builder.button(text="‚úÖ –û–ü–£–ë–õ–ò–ö–û–í–ê–¢–¨", callback_data="constr_publish")
    
    # –ù–û–í–ê–Ø –ö–ù–û–ü–ö–ê –û–¢–ú–ï–ù–´
    builder.button(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_creation")
    
    # –°–µ—Ç–∫–∞ –∫–Ω–æ–ø–æ–∫: 2, 2, 2, 1, 1, 1
    builder.adjust(2, 2, 2, 1, 1, 1)
    return builder.as_markup()

def winners_selector_kb() -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    
    # –ö–Ω–æ–ø–∫–∏ —Å –ø–æ–ø—É–ª—è—Ä–Ω—ã–º–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞–º–∏
    popular_values = [1, 2, 3, 5, 10, 20, 50]
    for w in popular_values:
        builder.button(text=f"üèÜ {w}", callback_data=f"constr_set_winners:{w}")
    
    # –ö–Ω–æ–ø–∫–∞ –¥–ª—è –≤–≤–æ–¥–∞ –≤—Ä—É—á–Ω—É—é
    builder.button(text="‚úèÔ∏è –í–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ", callback_data="constr_set_winners_input")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="constr_back_main")
    
    # –°–µ—Ç–∫–∞: 4 –≤ —Ä—è–¥—É, –∑–∞—Ç–µ–º 1
    builder.adjust(4, 4, 1)
    return builder.as_markup()

def referral_selector_kb() -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    options = [(0, "–í—ã–∫–ª"), (1, "1 –¥—Ä—É–≥"), (3, "3 –¥—Ä—É–≥–∞"), (5, "5 –¥—Ä—É–∑–µ–π")]
    for val, label in options:
        builder.button(text=label, callback_data=f"constr_set_ref:{val}")
    
    # –î–æ–±–∞–≤–∏–º –∫–Ω–æ–ø–∫—É –¥–ª—è –≤–≤–æ–¥–∞ –≤—Ä—É—á–Ω—É—é
    builder.button(text="‚úèÔ∏è –í–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ", callback_data="constr_set_ref_input")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="constr_back_main")
    
    builder.adjust(2, 2, 1)
    return builder.as_markup()

def channel_selection_kb(channels: list[Channel], mode: str, selected_ids: list[int]) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    
    # –ö–Ω–æ–ø–∫–∏ –∫–∞–Ω–∞–ª–æ–≤
    for ch in channels:
        icon = "‚úÖ" if mode == "main" and ch.channel_id in selected_ids else ("‚òëÔ∏è" if ch.channel_id in selected_ids else "‚¨ú")
        cb = f"constr_set_ch:{mode}:{ch.channel_id}"
        builder.button(text=f"{icon} {ch.title}", callback_data=cb)
    
    # –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
    builder.button(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π –∫–∞–Ω–∞–ª", callback_data="add_new_channel_constr")
    builder.button(text="üíæ –ì–æ—Ç–æ–≤–æ (–°–æ—Ö—Ä–∞–Ω–∏—Ç—å)", callback_data="constr_back_main")
    
    builder.adjust(1)
    return builder.as_markup()=== ./keyboards/inline/admin_panel.py ===
# keyboards/inline/admin_panel.py
from aiogram.utils.keyboard import InlineKeyboardBuilder
from database.models.giveaway import Giveaway
from keyboards.callback_data import AdminAction
from core.security.hmac_signer import sign_data

def build_giveaway_list(giveaways: list[Giveaway], admin_id: int):
    """–°—Ç—Ä–æ–∏—Ç —Å–ø–∏—Å–æ–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π. –ö–Ω–æ–ø–∫–∏ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∞–¥–º–∏–Ω–∞."""
    builder = InlineKeyboardBuilder()
    
    for gw in giveaways:
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø–æ–¥–ø–∏—Å–∏ –¥–ª—è –¥–µ–π—Å—Ç–≤–∏–π
        sig_manage = sign_data("manage", gw.id, admin_id)
        
        btn_text = f"üéÅ #{gw.id} | {gw.winners_count} winners"
        callback = AdminAction(action="manage", id=gw.id, sig=sig_manage)
        
        builder.button(text=btn_text, callback_data=callback)
    
    builder.adjust(1) # –í –æ–¥–∏–Ω —Å—Ç–æ–ª–±–∏–∫
    return builder.as_markup()

def build_manage_menu(gw_id: int, admin_id: int):
    """–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º —Ä–æ–∑—ã–≥—Ä—ã—à–µ–º"""
    builder = InlineKeyboardBuilder()
    
    # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–æ–¥–ø–∏—Å–µ–π
    sig_del = sign_data("delete", gw_id, admin_id)
    sig_rig = sign_data("rig", gw_id, admin_id) # –ö–Ω–æ–ø–∫–∞ –ø–æ–¥–∫—Ä—É—Ç–∫–∏
    sig_finish = sign_data("finish", gw_id, admin_id)

    builder.button(text="üõë –ó–∞–≤–µ—Ä—à–∏—Ç—å", callback_data=AdminAction(action="finish", id=gw_id, sig=sig_finish))
    builder.button(text="üóë –£–¥–∞–ª–∏—Ç—å", callback_data=AdminAction(action="delete", id=gw_id, sig=sig_del))
    builder.button(text="üéØ –ù–∞–∑–Ω–∞—á–∏—Ç—å –ø–æ–±–µ–¥–∏—Ç–µ–ª—è", callback_data=AdminAction(action="rig", id=gw_id, sig=sig_rig))
    
    builder.adjust(1)
    return builder.as_markup()=== ./keyboards/__init__.py ===
=== ./keyboards/builders.py ===
# keyboards/builders.py
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.types import InlineKeyboardButton

def simple_menu(text: str, callback_data: str) -> InlineKeyboardBuilder:
    builder = InlineKeyboardBuilder()
    builder.add(InlineKeyboardButton(text=text, callback_data=callback_data))
    return builder=== ./keyboards/callback_data.py ===
# keyboards/callback_data.py
from aiogram.filters.callback_data import CallbackData

class AdminAction(CallbackData, prefix="adm"):
    """
    –î–∞–Ω–Ω—ã–µ –¥–ª—è –∞–¥–º–∏–Ω—Å–∫–∏—Ö –∫–Ω–æ–ø–æ–∫.
    sig - —ç—Ç–æ HMAC –ø–æ–¥–ø–∏—Å—å.
    """
    action: str
    id: int
    sig: str

class JoinAction(CallbackData, prefix="join"):
    """
    –î–∞–Ω–Ω—ã–µ –¥–ª—è –∫–Ω–æ–ø–∫–∏ —É—á–∞—Å—Ç–∏—è.
    """
    giveaway_id: int=== ./Dockerfile ===
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π (–µ—Å–ª–∏ –Ω—É–∂–Ω—ã –¥–ª—è —Å–±–æ—Ä–∫–∏ pg driver)
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

# –°–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –±–µ–∑ –ø—Ä–∞–≤ root
RUN useradd -m appuser
USER appuser

CMD ["python", "main.py"]=== ./.gitignore ===
# –í–∏—Ä—Ç—É–∞–ª—å–Ω–æ–µ –æ–∫—Ä—É–∂–µ–Ω–∏–µ
venv/
.venv/
env/

# –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è (–°–ê–ú–û–ï –í–ê–ñ–ù–û–ï)
.env

# –ë–∞–π—Ç-–∫–æ–¥ Python
__pycache__/
*.pyc

# –õ–æ–≥–∏
*.log

# –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö (–µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—à—å SQLite —Ñ–∞–π–ª, –¥–ª—è Postgres –Ω–µ –Ω—É–∂–Ω–æ)
*.db
*.sqlite3

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ IDE
.idea/
.vscode/=== ./reset_db.py ===
import asyncio
from redis.asyncio import Redis
from database import engine, Base
from config import config

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –í–°–ï –º–æ–¥–µ–ª–∏, —á—Ç–æ–±—ã SQLAlchemy –∑–Ω–∞–ª–∞, —á—Ç–æ —Å–æ–∑–¥–∞–≤–∞—Ç—å
from database.models.user import User
from database.models.giveaway import Giveaway
from database.models.participant import Participant
from database.models.channel import Channel
from database.models.required_channel import GiveawayRequiredChannel
from database.models.winner import Winner # <--- –í–∞–∂–Ω–æ! –ù–æ–≤–∞—è —Ç–∞–±–ª–∏—Ü–∞

async def reset_database():
    print("üóë –£–¥–∞–ª—è—é —Å—Ç–∞—Ä—ã–µ —Ç–∞–±–ª–∏—Ü—ã PostgreSQL...")
    async with engine.begin() as conn:
        # –£–¥–∞–ª—è–µ–º –≤—Å–µ —Ç–∞–±–ª–∏—Ü—ã
        await conn.run_sync(Base.metadata.drop_all)
        # –°–æ–∑–¥–∞–µ–º –≤—Å–µ —Ç–∞–±–ª–∏—Ü—ã –∑–∞–Ω–æ–≤–æ —Å –Ω–æ–≤—ã–º–∏ –ø–æ–ª—è–º–∏
        await conn.run_sync(Base.metadata.create_all)
    
    print("üóë –û—á–∏—â–∞—é Redis...")
    redis = Redis.from_url(config.REDIS_URL)
    await redis.flushdb()
    await redis.aclose()
    
    print("‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ–±–Ω–æ–≤–ª–µ–Ω–∞!")

if __name__ == "__main__":
    asyncio.run(reset_database())=== ./requirements.txt ===
aiofiles==25.1.0
aiogram==3.23.0
aiohappyeyeballs==2.6.1
aiohttp==3.13.2
aiosignal==1.4.0
aiounittest==1.5.0
alembic==1.17.2
annotated-types==0.7.0
APScheduler==3.11.2
asyncpg==0.31.0
attrs==25.4.0
babel==2.17.0
beautifulsoup4==4.14.3
black==25.12.0
bleach==6.3.0
certifi==2025.11.12
charset-normalizer==3.4.4
click==8.3.1
cloudscraper==1.2.71
colorlog==6.10.1
cryptg==0.5.2
fake-useragent==2.2.0
fluent-compiler==1.1
fluent.runtime==0.4.0
fluent.syntax==0.19.0
fluentogram==1.2.1
frozenlist==1.8.0
greenlet==3.3.0
hashids==1.3.1
howlongtobeatpy==1.0.19
idna==3.11
iniconfig==2.3.0
isort==7.0.0
kagglehub==0.3.13
librt==0.7.5
loguru==0.7.3
lxml==6.0.2
magic-filter==1.0.12
Mako==1.3.10
MarkupSafe==3.0.3
multidict==6.7.0
mypy==1.19.1
mypy_extensions==1.1.0
numpy==2.4.0
packaging==25.0
pandas==2.3.3
pathspec==0.12.1
pillow==12.0.0
platformdirs==4.5.1
playwright==1.57.0
pluggy==1.6.0
propcache==0.4.1
pyaes==1.6.1
pyasn1==0.6.1
pydantic==2.12.5
pydantic-settings==2.12.0
pydantic_core==2.41.5
pyee==13.0.0
Pygments==2.19.2
pyparsing==3.3.1
Pyrogram==2.0.106
PySocks==1.7.1
pytest==9.0.2
pytest-asyncio==1.3.0
python-dateutil==2.9.0.post0
python-dotenv==1.2.1
pytokens==0.3.0
pytz==2025.2
PyYAML==6.0.3
redis==7.1.0
requests==2.32.5
requests-toolbelt==1.0.0
rsa==4.9.1
six==1.17.0
soupsieve==2.8.1
SQLAlchemy==2.0.45
Telethon==1.42.0
TgCrypto==1.2.5
tqdm==4.67.1
typing-inspection==0.4.2
typing_extensions==4.15.0
tzdata==2025.3
tzlocal==5.3.1
urllib3==2.6.2
webencodings==0.5.1
wrapt==2.0.1
yarl==1.22.0
yt-dlp==2025.12.8
=== ./.pytest_cache/.gitignore ===
# Created by pytest automatically.
*
=== ./.pytest_cache/README.md ===
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.
=== ./tests/test_captcha.py ===
import asyncio
import io
import os
import sys
import random
from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import BufferedInputFile, Message
from PIL import Image

# –î–æ–±–∞–≤–ª—è–µ–º –ø—É—Ç—å –∫ –∫–æ—Ä–Ω—é –ø—Ä–æ–µ–∫—Ç–∞, —á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å captcha
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.insert(0, parent_dir)

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º captcha –∏–∑ —Ñ–∞–π–ª–∞ –≤ –∫–æ—Ä–Ω–µ –ø—Ä–æ–µ–∫—Ç–∞
sys.path.insert(0, os.path.join(os.path.dirname(parent_dir), '.'))
from captcha import (
    CaptchaStates,
    check_captcha,
    cmd_captcha,
    generate_captcha_image
)


class TestGenerateCaptchaImage:
    """–¢–µ—Å—Ç—ã –¥–ª—è —Ñ—É–Ω–∫—Ü–∏–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∫–∞–ø—á–∏."""

    @pytest.mark.asyncio
    async def test_generate_captcha_image_returns_bytes(self):
        """–¢–µ—Å—Ç: —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –±–∞–π—Ç—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."""
        numbers = [1, 2, 3, 4, 5]
        result = await generate_captcha_image(numbers)
        assert isinstance(result, bytes)
        assert len(result) > 0

    @pytest.mark.asyncio
    async def test_generate_captcha_image_creates_valid_image(self):
        """–¢–µ—Å—Ç: —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –±–∞–π—Ç—ã —Å–æ–¥–µ—Ä–∂–∞—Ç –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ."""
        numbers = [9, 8, 7, 6, 5]
        img_bytes = await generate_captcha_image(numbers)
        img = Image.open(io.BytesIO(img_bytes))
        assert img.format == "PNG"
        assert img.size == (420, 200)

    @pytest.mark.asyncio
    async def test_generate_captcha_image_with_different_numbers(self):
        """–¢–µ—Å—Ç: —Ñ—É–Ω–∫—Ü–∏—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ä–∞–∑–Ω—ã–µ —á–∏—Å–ª–∞."""
        for _ in range(5):
            numbers = [random.randint(0, 9) for _ in range(5)]
            img_bytes = await generate_captcha_image(numbers)
            assert isinstance(img_bytes, bytes) and len(img_bytes) > 0


class TestCaptchaCommand:
    """–¢–µ—Å—Ç—ã –¥–ª—è –∫–æ–º–∞–Ω–¥—ã /captcha."""

    @pytest.fixture
    def mock_message(self):
        """–°–æ–∑–¥–∞–µ—Ç mock —Å–æ–æ–±—â–µ–Ω–∏—è."""
        message = MagicMock(spec=Message)
        message.answer_photo = AsyncMock()
        message.answer = AsyncMock()
        return message

    @pytest.fixture
    def mock_state(self):
        """–°–æ–∑–¥–∞–µ—Ç mock —Å–æ—Å—Ç–æ—è–Ω–∏—è FSM."""
        state = MagicMock(spec=FSMContext)
        state.set_data = AsyncMock()
        state.set_state = AsyncMock()
        return state

    @pytest.mark.asyncio
    async def test_cmd_captcha_sets_correct_state(self, mock_message, mock_state):
        """–¢–µ—Å—Ç: –∫–æ–º–∞–Ω–¥–∞ /captcha —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ FSM."""
        await cmd_captcha(mock_message, mock_state)
        mock_state.set_state.assert_called_once_with(CaptchaStates.waiting_for_input)

    @pytest.mark.asyncio
    async def test_cmd_captcha_sets_random_numbers_in_state(self, mock_message, mock_state):
        """–¢–µ—Å—Ç: –∫–æ–º–∞–Ω–¥–∞ /captcha —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏."""
        with patch('captcha.random.randint', side_effect=[1, 2, 3, 4, 5]):
            await cmd_captcha(mock_message, mock_state)
            mock_state.set_data.assert_called_once_with({"correct": "12345"})

    @pytest.mark.asyncio
    async def test_cmd_captcha_sends_photo_and_message(self, mock_message, mock_state):
        """–¢–µ—Å—Ç: –∫–æ–º–∞–Ω–¥–∞ /captcha –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Ñ–æ—Ç–æ –∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é."""
        await cmd_captcha(mock_message, mock_state)
        assert mock_message.answer_photo.called
        assert mock_message.answer.called

    @pytest.mark.asyncio
    async def test_cmd_captcha_photo_content(self, mock_message, mock_state):
        """–¢–µ—Å—Ç: –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º–æ–µ —Ñ–æ—Ç–æ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —è–≤–ª—è–µ—Ç—Å—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º –∫–∞–ø—á–∏."""
        with patch('captcha.generate_captcha_image') as mock_gen:
            mock_gen.return_value = b"fake_image_bytes"
            await cmd_captcha(mock_message, mock_state)
            
            call_args = mock_message.answer_photo.call_args
            assert call_args is not None
            photo_arg = call_args[1]['photo']
            assert isinstance(photo_arg, BufferedInputFile)
            assert photo_arg.file_bytes == b"fake_image_bytes"


class TestCheckCaptcha:
    """–¢–µ—Å—Ç—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤–≤–æ–¥–∞ –∫–∞–ø—á–∏."""

    @pytest.fixture
    def mock_message(self):
        """–°–æ–∑–¥–∞–µ—Ç mock —Å–æ–æ–±—â–µ–Ω–∏—è."""
        message = MagicMock(spec=Message)
        message.text = "12345"
        message.answer = AsyncMock()
        return message

    @pytest.fixture
    def mock_state(self):
        """–°–æ–∑–¥–∞–µ—Ç mock —Å–æ—Å—Ç–æ—è–Ω–∏—è FSM."""
        state = MagicMock(spec=FSMContext)
        state.get_data = AsyncMock(return_value={"correct": "12345"})
        state.clear = AsyncMock()
        return state

    @pytest.mark.asyncio
    async def test_check_captcha_correct_answer(self, mock_message, mock_state):
        """–¢–µ—Å—Ç: –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
        await check_captcha(mock_message, mock_state)
        mock_message.answer.assert_called_with("‚úÖ –õ–ï–ì–ï–ù–î–ê! –†–∞–∑–≥–∞–¥–∞–ª –∫–∞–ø—á—É! üèÜ")
        mock_state.clear.assert_called_once()

    @pytest.mark.asyncio
    async def test_check_captcha_incorrect_answer(self, mock_message, mock_state):
        """–¢–µ—Å—Ç: –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
        mock_message.text = "54321"
        await check_captcha(mock_message, mock_state)
        mock_message.answer.assert_called_with("‚ùå –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë. –û—Ç–≤–µ—Ç: **12345**")
        mock_state.clear.assert_called_once()

    @pytest.mark.asyncio
    async def test_check_captcha_case_sensitivity(self, mock_message, mock_state):
        """–¢–µ—Å—Ç: —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∫ —Ä–µ–≥–∏—Å—Ç—Ä—É (–µ—Å–ª–∏ –ø—Ä–∏–º–µ–Ω–∏–º–æ)."""
        mock_message.text = " 12345 "
        await check_captcha(mock_message, mock_state)
        # –ü—Ä–æ–±–µ–ª—ã —É–±–∏—Ä–∞—é—Ç—Å—è –º–µ—Ç–æ–¥–æ–º strip(), —Ç–∞–∫ —á—Ç–æ –æ—Ç–≤–µ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤–µ—Ä–Ω—ã–º
        mock_message.answer.assert_called_with("‚úÖ –õ–ï–ì–ï–ù–î–ê! –†–∞–∑–≥–∞–¥–∞–ª –∫–∞–ø—á—É! üèÜ")

    @pytest.mark.asyncio
    async def test_check_captcha_different_correct_answer(self, mock_message):
        """–¢–µ—Å—Ç: –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å –¥—Ä—É–≥–∏–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –æ—Ç–≤–µ—Ç–æ–º."""
        mock_state = MagicMock(spec=FSMContext)
        mock_state.get_data = AsyncMock(return_value={"correct": "98765"})
        mock_message.text = "98765"
        
        await check_captcha(mock_message, mock_state)
        mock_message.answer.assert_called_with("‚úÖ –õ–ï–ì–ï–ù–î–ê! –†–∞–∑–≥–∞–¥–∞–ª –∫–∞–ø—á—É! üèÜ")
        mock_state.clear.assert_called_once()


class TestCaptchaStates:
    """–¢–µ—Å—Ç—ã –¥–ª—è FSM —Å–æ—Å—Ç–æ—è–Ω–∏–π –∫–∞–ø—á–∏."""

    def test_captcha_states_structure(self):
        """–¢–µ—Å—Ç: —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å–æ—Å—Ç–æ—è–Ω–∏–π –∫–∞–ø—á–∏."""
        assert hasattr(CaptchaStates, 'waiting_for_input')
        assert isinstance(CaptchaStates.waiting_for_input, State)=== ./tests/test_join_handler.py ===
import asyncio
from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from aiogram import Bot
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, CallbackQuery, User
from sqlalchemy.ext.asyncio import AsyncSession

from handlers.participant.join import (
    try_join_giveaway,
    captcha_solved,
    check_subscriptions_step,
    on_check_subscription_btn,
    finalize_registration,
    JoinState
)


class TestTryJoinGiveaway:
    """–¢–µ—Å—Ç—ã –¥–ª—è –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∫ —Ä–æ–∑—ã–≥—Ä—ã—à—É"""

    @pytest.fixture
    def mock_message(self):
        """–°–æ–∑–¥–∞–µ—Ç mock —Å–æ–æ–±—â–µ–Ω–∏—è."""
        message = MagicMock(spec=Message)
        message.from_user = MagicMock(spec=User)
        message.from_user.id = 123456
        message.from_user.username = "test_user"
        message.from_user.full_name = "Test User"
        message.answer = AsyncMock()
        message.edit_text = AsyncMock()
        message.delete = AsyncMock()
        return message

    @pytest.fixture
    def mock_callback(self):
        """–°–æ–∑–¥–∞–µ—Ç mock –∫–æ–ª–ª–±—ç–∫–∞."""
        callback = MagicMock(spec=CallbackQuery)
        callback.message = MagicMock(spec=Message)
        callback.message.from_user = MagicMock(spec=User)
        callback.message.from_user.id = 123456
        callback.message.from_user.username = "test_user"
        callback.message.from_user.full_name = "Test User"
        callback.from_user = MagicMock(spec=User)
        callback.from_user.id = 123456
        callback.from_user.username = "test_user"
        callback.from_user.full_name = "Test User"
        callback.message.answer = AsyncMock()
        callback.message.edit_text = AsyncMock()
        callback.message.delete = AsyncMock()
        callback.answer = AsyncMock()
        return callback

    @pytest.fixture
    def mock_session(self):
        """–°–æ–∑–¥–∞–µ—Ç mock —Å–µ—Å—Å–∏–∏."""
        session = MagicMock(spec=AsyncSession)
        session.scalar = AsyncMock()
        session.execute = AsyncMock()
        return session

    @pytest.fixture
    def mock_bot(self):
        """–°–æ–∑–¥–∞–µ—Ç mock –±–æ—Ç–∞."""
        bot = MagicMock(spec=Bot)
        bot.get_me = AsyncMock(return_value=MagicMock(username="test_bot"))
        bot.get_chat = AsyncMock()
        bot.get_chat_member = AsyncMock()
        bot.send_message = AsyncMock()
        return bot

    @pytest.fixture
    def mock_state(self):
        """–°–æ–∑–¥–∞–µ—Ç mock —Å–æ—Å—Ç–æ—è–Ω–∏—è FSM."""
        state = MagicMock(spec=FSMContext)
        state.update_data = AsyncMock()
        state.set_state = AsyncMock()
        state.get_data = AsyncMock()
        state.clear = AsyncMock()
        return state

    @pytest.mark.asyncio
    async def test_try_join_giveaway_inactive_giveaway(self, mock_message, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: –ø–æ–ø—ã—Ç–∫–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ–º—É —Ä–æ–∑—ã–≥—Ä—ã—à—É."""
        with patch('handlers.participant.join.get_giveaway_by_id', return_value=MagicMock(status='finished')):
            await try_join_giveaway(mock_message, 123, mock_session, mock_bot, mock_state)
            mock_message.answer.assert_called_once_with("üòî <b>–£–≤—ã, —ç—Ç–æ—Ç —Ä–æ–∑—ã–≥—Ä—ã—à —É–∂–µ –∑–∞–≤–µ—Ä—à–µ–Ω.</b>")

    @pytest.mark.asyncio
    async def test_try_join_giveaway_owner_cannot_join(self, mock_message, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: –≤–ª–∞–¥–µ–ª–µ—Ü —Ä–æ–∑—ã–≥—Ä—ã—à–∞ –Ω–µ –º–æ–∂–µ—Ç –≤ –Ω–µ–≥–æ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è."""
        mock_giveaway = MagicMock()
        mock_giveaway.status = 'active'
        mock_giveaway.owner_id = 123456  # –¢–æ—Ç –∂–µ ID, —á—Ç–æ –∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        with patch('handlers.participant.join.get_giveaway_by_id', return_value=mock_giveaway):
            await try_join_giveaway(mock_message, 123, mock_session, mock_bot, mock_state)
            mock_message.answer.assert_called_once_with("‚ö†Ô∏è –í—ã –æ—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä —ç—Ç–æ–≥–æ —Ä–æ–∑—ã–≥—Ä—ã—à–∞.")

    @pytest.mark.asyncio
    async def test_try_join_giveaway_already_participating(self, mock_message, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —É—á–∞—Å—Ç–≤—É–µ—Ç –≤ —Ä–æ–∑—ã–≥—Ä—ã—à–µ."""
        mock_giveaway = MagicMock()
        mock_giveaway.status = 'active'
        mock_giveaway.owner_id = 789
        mock_giveaway.is_referral_enabled = False
        mock_existing_participant = MagicMock()
        mock_existing_participant.ticket_code = "ABC123"
        mock_existing_participant.tickets_count = 1

        with patch('handlers.participant.join.get_giveaway_by_id', return_value=mock_giveaway), \
             patch('handlers.participant.join.select') as mock_select, \
             patch.object(mock_session, 'scalar', return_value=mock_existing_participant):
            await try_join_giveaway(mock_message, 123, mock_session, mock_bot, mock_state)
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç–æ–º, —á—Ç–æ –æ–Ω —É–∂–µ —É—á–∞—Å—Ç–≤—É–µ—Ç

    @pytest.mark.asyncio
    async def test_try_join_giveaway_with_referrer(self, mock_message, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å —Ä–µ—Ñ–µ—Ä–µ—Ä–æ–º."""
        mock_giveaway = MagicMock()
        mock_giveaway.status = 'active'
        mock_giveaway.owner_id = 789
        mock_giveaway.is_captcha_enabled = False
        mock_giveaway.is_referral_enabled = False

        with patch('handlers.participant.join.get_giveaway_by_id', return_value=mock_giveaway), \
             patch('handlers.participant.join.select') as mock_select, \
             patch.object(mock_session, 'scalar', return_value=None), \
             patch('handlers.participant.join.add_pending_referral') as mock_add_pending, \
             patch('handlers.participant.join.check_subscriptions_step') as mock_check_subs:
            
            await try_join_giveaway(mock_message, 123, mock_session, mock_bot, mock_state, referrer_id=789)
            
            mock_add_pending.assert_called_once_with(mock_session, 128456, 789, 123)
            mock_check_subs.assert_called_once()

    @pytest.mark.asyncio
    async def test_try_join_giveaway_with_captcha_enabled(self, mock_message, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∫–æ–≥–¥–∞ –≤–∫–ª—é—á–µ–Ω–∞ –∫–∞–ø—á–∞."""
        mock_giveaway = MagicMock()
        mock_giveaway.status = 'active'
        mock_giveaway.owner_id = 789
        mock_giveaway.is_captcha_enabled = True
        mock_giveaway.is_referral_enabled = False

        with patch('handlers.participant.join.get_giveaway_by_id', return_value=mock_giveaway), \
             patch('handlers.participant.join.select') as mock_select, \
             patch.object(mock_session, 'scalar', return_value=None):
            
            await try_join_giveaway(mock_message, 123, mock_session, mock_bot, mock_state)
            
            mock_state.set_state.assert_called_once_with(JoinState.captcha)
            mock_message.answer.assert_called_once()


class TestCaptchaSolved:
    """–¢–µ—Å—Ç—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ —Ä–µ—à–µ–Ω–∏—è –∫–∞–ø—á–∏"""

    @pytest.mark.asyncio
    async def test_captcha_solved_success(self, mock_callback, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: —É—Å–ø–µ—à–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –∫–∞–ø—á–∏."""
        mock_data = {'gw_id': 123}
        mock_giveaway = MagicMock()
        
        mock_state.get_data.return_value = mock_data
        with patch('handlers.participant.join.get_giveaway_by_id', return_value=mock_giveaway), \
             patch('handlers.participant.join.check_subscriptions_step') as mock_check_subs:
            
            await captcha_solved(mock_callback, mock_state, mock_session, mock_bot)
            
            mock_callback.message.delete.assert_called_once()
            mock_check_subs.assert_called_once()

    @pytest.mark.asyncio
    async def test_captcha_solved_invalid_giveaway(self, mock_callback, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: —Ä–µ—à–µ–Ω–∏–µ –∫–∞–ø—á–∏ –¥–ª—è –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ–≥–æ —Ä–æ–∑—ã–≥—Ä—ã—à–∞."""
        mock_data = {'gw_id': 123}
        
        mock_state.get_data.return_value = mock_data
        with patch('handlers.participant.join.get_giveaway_by_id', return_value=None):
            await captcha_solved(mock_callback, mock_state, mock_session, mock_bot)
            
            mock_callback.answer.assert_called_once_with("–û—à–∏–±–∫–∞")
            mock_state.clear.assert_called_once()


class TestFinalizeRegistration:
    """–¢–µ—Å—Ç—ã –¥–ª—è —Ñ–∏–Ω–∞–ª—å–Ω–æ–π —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ —É—á–∞—Å—Ç–Ω–∏–∫–∞"""

    @pytest.mark.asyncio
    async def test_finalize_registration_new_participant(self, mock_message, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞."""
        mock_giveaway = MagicMock()
        mock_giveaway.id = 123
        mock_giveaway.is_referral_enabled = False
        mock_giveaway.owner_id = 789
        
        with patch('handlers.participant.join.get_unique_ticket', return_value="ABC123"), \
             patch('handlers.participant.join.add_participant', return_value=True), \
             patch('handlers.participant.join.get_pending_referral', return_value=None):
            
            await finalize_registration(mock_message, 123456, mock_giveaway, mock_session, mock_bot, mock_state)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É—á–∞—Å—Ç–Ω–∏–∫ –¥–æ–±–∞–≤–ª–µ–Ω –∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ

    @pytest.mark.asyncio
    async def test_finalize_registration_with_referrer(self, mock_message, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Å —Ä–µ—Ñ–µ—Ä–µ—Ä–æ–º."""
        mock_giveaway = MagicMock()
        mock_giveaway.id = 123
        mock_giveaway.is_referral_enabled = True
        mock_giveaway.owner_id = 789
        
        with patch('handlers.participant.join.get_unique_ticket', return_value="ABC123"), \
             patch('handlers.participant.join.add_participant', return_value=True), \
             patch('handlers.participant.join.increment_ticket'), \
             patch('handlers.participant.join.get_pending_referral', return_value=789), \
             patch('handlers.participant.join.is_circular_referral', return_value=False), \
             patch('handlers.participant.join.is_participant_active', return_value=True):
            
            await finalize_registration(mock_message, 123456, mock_giveaway, mock_session, mock_bot, mock_state)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –±–∏–ª–µ—Ç —É–≤–µ–ª–∏—á–µ–Ω –¥–ª—è —Ä–µ—Ñ–µ—Ä–µ—Ä–∞


class TestCheckSubscriptionsStep:
    """–¢–µ—Å—Ç—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–æ–∫"""

    @pytest.mark.asyncio
    async def test_check_subscriptions_all_subscribed(self, mock_message, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: –≤—Å–µ –ø–æ–¥–ø–∏—Å–∫–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω—ã."""
        mock_giveaway = MagicMock()
        mock_giveaway.id = 123
        mock_giveaway.channel_id = -1001234567890
        
        with patch('handlers.participant.join.get_required_channels', return_value=[]), \
             patch('handlers.participant.join.is_user_subscribed', return_value=True), \
             patch('handlers.participant.join.finalize_registration') as mock_finalize:
            
            await check_subscriptions_step(mock_message, 123456, mock_giveaway, mock_session, mock_bot, mock_state)
            
            mock_finalize.assert_called_once()

    @pytest.mark.asyncio
    async def test_check_subscriptions_not_all_subscribed(self, mock_message, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: –Ω–µ –≤—Å–µ –ø–æ–¥–ø–∏—Å–∫–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω—ã."""
        mock_giveaway = MagicMock()
        mock_giveaway.id = 123
        mock_giveaway.channel_id = -1001234567890
        
        with patch('handlers.participant.join.get_required_channels', return_value=[]), \
             patch('handlers.participant.join.is_user_subscribed', return_value=False):
            
            await check_subscriptions_step(mock_message, 123456, mock_giveaway, mock_session, mock_bot, mock_state)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –Ω–µ –≤—Å–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã, –∏ –≤—ã–≤–æ–¥–∏—Ç—Å—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞


class TestOnCheckSubscriptionBtn:
    """–¢–µ—Å—Ç—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∫–∏"""

    @pytest.mark.asyncio
    async def test_on_check_subscription_btn_success(self, mock_callback, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: —É—Å–ø–µ—à–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏ —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É."""
        mock_callback.data = "check_sub:123"
        mock_giveaway = MagicMock()
        mock_giveaway.status = 'active'
        
        with patch('handlers.participant.join.get_giveaway_by_id', return_value=mock_giveaway), \
             patch('handlers.participant.join.check_subscriptions_step') as mock_check_subs:
            
            await on_check_subscription_btn(mock_callback, mock_session, mock_bot, mock_state)
            
            mock_check_subs.assert_called_once()
            mock_callback.answer.assert_called_once()

    @pytest.mark.asyncio
    async def test_on_check_subscription_btn_finished_giveaway(self, mock_callback, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω–æ–≥–æ —Ä–æ–∑—ã–≥—Ä—ã—à–∞."""
        mock_callback.data = "check_sub:123"
        mock_giveaway = MagicMock()
        mock_giveaway.status = 'finished'
        
        with patch('handlers.participant.join.get_giveaway_by_id', return_value=mock_giveaway):
            await on_check_subscription_btn(mock_callback, mock_session, mock_bot, mock_state)
            
            mock_callback.message.edit_text.assert_called_once_with("‚ùå –†–æ–∑—ã–≥—Ä—ã—à –∑–∞–≤–µ—Ä—à–µ–Ω.")=== ./tests/test_dashboard_handler.py ===
import asyncio
from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from aiogram import Bot
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, CallbackQuery, User
from sqlalchemy.ext.asyncio import AsyncSession

from handlers.user.dashboard import smart_dashboard, back_home, open_cabinet


class TestSmartDashboard:
    """–¢–µ—Å—Ç—ã –¥–ª—è –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é (dashboard)"""

    @pytest.fixture
    def mock_message(self):
        """–°–æ–∑–¥–∞–µ—Ç mock —Å–æ–æ–±—â–µ–Ω–∏—è."""
        message = MagicMock(spec=Message)
        message.from_user = MagicMock(spec=User)
        message.from_user.id = 123456
        message.from_user.username = "test_user"
        message.from_user.full_name = "Test User"
        message.from_user.first_name = "Test"
        message.answer = AsyncMock()
        return message

    @pytest.fixture
    def mock_command(self):
        """–°–æ–∑–¥–∞–µ—Ç mock –∫–æ–º–∞–Ω–¥—ã."""
        command = MagicMock()
        command.args = ""
        return command

    @pytest.fixture
    def mock_session(self):
        """–°–æ–∑–¥–∞–µ—Ç mock —Å–µ—Å—Å–∏–∏."""
        session = MagicMock(spec=AsyncSession)
        return session

    @pytest.fixture
    def mock_bot(self):
        """–°–æ–∑–¥–∞–µ—Ç mock –±–æ—Ç–∞."""
        bot = MagicMock(spec=Bot)
        return bot

    @pytest.fixture
    def mock_state(self):
        """–°–æ–∑–¥–∞–µ—Ç mock —Å–æ—Å—Ç–æ—è–Ω–∏—è FSM."""
        state = MagicMock(spec=FSMContext)
        return state

    @pytest.mark.asyncio
    async def test_smart_dashboard_start_command(self, mock_message, mock_command, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: –∫–æ–º–∞–Ω–¥–∞ /start –±–µ–∑ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤."""
        mock_command.args = None
        with patch('handlers.user.dashboard.register_user') as mock_register, \
             patch('handlers.user.dashboard.start_menu_kb', return_value=MagicMock()):
            
            await smart_dashboard(mock_message, mock_command, mock_session, mock_bot, mock_state)
            
            mock_register.assert_called_once_with(
                mock_session,
                123456,
                "test_user",
                "Test User"
            )
            mock_message.answer.assert_called_once()

    @pytest.mark.asyncio
    async def test_smart_dashboard_with_deep_link_gw(self, mock_message, mock_command, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: –∫–æ–º–∞–Ω–¥–∞ /start —Å –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º gw_ (deep link)."""
        mock_command.args = "gw_123"
        with patch('handlers.user.dashboard.deep_link_logic') as mock_deep_link:
            
            await smart_dashboard(mock_message, mock_command, mock_session, mock_bot, mock_state)
            
            mock_deep_link.assert_called_once_with(
                mock_message,
                mock_command,
                mock_session,
                mock_bot,
                mock_state
            )

    @pytest.mark.asyncio
    async def test_smart_dashboard_with_deep_link_res(self, mock_message, mock_command, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: –∫–æ–º–∞–Ω–¥–∞ /start —Å –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º res_ (deep link)."""
        mock_command.args = "res_123"
        with patch('handlers.user.dashboard.deep_link_logic') as mock_deep_link:
            
            await smart_dashboard(mock_message, mock_command, mock_session, mock_bot, mock_state)
            
            mock_deep_link.assert_called_once_with(
                mock_message,
                mock_command,
                mock_session,
                mock_bot,
                mock_state
            )


class TestBackHome:
    """–¢–µ—Å—Ç—ã –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –Ω–∞ –≥–ª–∞–≤–Ω—É—é"""

    @pytest.mark.asyncio
    async def test_back_home_success(self):
        """–¢–µ—Å—Ç: —É—Å–ø–µ—à–Ω—ã–π –≤–æ–∑–≤—Ä–∞—Ç –Ω–∞ –≥–ª–∞–≤–Ω—É—é."""
        callback = MagicMock(spec=CallbackQuery)
        callback.message = MagicMock()
        callback.message.edit_text = AsyncMock()
        callback.answer = AsyncMock()
        
        with patch('handlers.user.dashboard.start_menu_kb', return_value=MagicMock()):
            await back_home(callback)
            callback.message.edit_text.assert_called_once()

    @pytest.mark.asyncio
    async def test_back_home_bad_request_exception(self):
        """–¢–µ—Å—Ç: –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∏—Å–∫–ª—é—á–µ–Ω–∏—è TelegramBadRequest."""
        callback = MagicMock(spec=CallbackQuery)
        callback.message = MagicMock()
        callback.message.edit_text = AsyncMock(side_effect=Exception("Bad Request: message is not modified"))
        callback.answer = AsyncMock()
        
        with patch('handlers.user.dashboard.start_menu_kb', return_value=MagicMock()):
            await back_home(callback)
            callback.answer.assert_called_once()


class TestOpenCabinet:
    """–¢–µ—Å—Ç—ã –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –∫–∞–±–∏–Ω–µ—Ç–∞"""

    @pytest.mark.asyncio
    async def test_open_cabinet_success(self):
        """–¢–µ—Å—Ç: —É—Å–ø–µ—à–Ω–æ–µ –æ—Ç–∫—Ä—ã—Ç–∏–µ –∫–∞–±–∏–Ω–µ—Ç–∞."""
        callback = MagicMock(spec=CallbackQuery)
        callback.from_user = MagicMock()
        callback.from_user.id = 123456
        callback.message = MagicMock()
        callback.message.edit_text = AsyncMock()
        callback.answer = AsyncMock()
        
        mock_session = MagicMock(spec=AsyncSession)
        
        with patch('handlers.user.dashboard.cabinet_kb', return_value=MagicMock()):
            await open_cabinet(callback, mock_session)
            callback.message.edit_text.assert_called_once()

    @pytest.mark.asyncio
    async def test_open_cabinet_bad_request_exception(self):
        """–¢–µ—Å—Ç: –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∏—Å–∫–ª—é—á–µ–Ω–∏—è TelegramBadRequest –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ –∫–∞–±–∏–Ω–µ—Ç–∞."""
        callback = MagicMock(spec=CallbackQuery)
        callback.from_user = MagicMock()
        callback.from_user.id = 123456
        callback.message = MagicMock()
        callback.message.edit_text = AsyncMock(side_effect=Exception("Bad Request: message is not modified"))
        callback.answer = AsyncMock()
        
        mock_session = MagicMock(spec=AsyncSession)
        
        with patch('handlers.user.dashboard.cabinet_kb', return_value=MagicMock()):
            await open_cabinet(callback, mock_session)
            callback.answer.assert_called_once()=== ./tests/test_start_handler.py ===
import asyncio
from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from aiogram import Bot
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import Message, User
from sqlalchemy.ext.asyncio import AsyncSession

from handlers.common.start import cmd_start


class TestStartHandler:
    """–¢–µ—Å—Ç—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –∫–æ–º–∞–Ω–¥—ã /start"""

    @pytest.fixture
    def mock_message(self):
        """–°–æ–∑–¥–∞–µ—Ç mock —Å–æ–æ–±—â–µ–Ω–∏—è."""
        message = MagicMock(spec=Message)
        message.from_user = MagicMock(spec=User)
        message.from_user.id = 123456
        message.from_user.username = "test_user"
        message.from_user.full_name = "Test User"
        message.from_user.first_name = "Test"
        message.answer = AsyncMock()
        return message

    @pytest.fixture
    def mock_command(self):
        """–°–æ–∑–¥–∞–µ—Ç mock –∫–æ–º–∞–Ω–¥—ã."""
        command = MagicMock()
        command.args = ""
        return command

    @pytest.fixture
    def mock_session(self):
        """–°–æ–∑–¥–∞–µ—Ç mock —Å–µ—Å—Å–∏–∏."""
        session = MagicMock(spec=AsyncSession)
        session.scalar = AsyncMock()
        session.execute = AsyncMock()
        return session

    @pytest.fixture
    def mock_bot(self):
        """–°–æ–∑–¥–∞–µ—Ç mock –±–æ—Ç–∞."""
        bot = MagicMock(spec=Bot)
        bot.get_me = AsyncMock(return_value=MagicMock(username="test_bot"))
        bot.get_chat = AsyncMock()
        return bot

    @pytest.fixture
    def mock_state(self):
        """–°–æ–∑–¥–∞–µ—Ç mock —Å–æ—Å—Ç–æ—è–Ω–∏—è FSM."""
        state = MagicMock(spec=FSMContext)
        state.update_data = AsyncMock()
        state.clear = AsyncMock()
        return state

    @pytest.mark.asyncio
    async def test_cmd_start_without_args(self, mock_message, mock_command, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: –∫–æ–º–∞–Ω–¥–∞ /start –±–µ–∑ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤."""
        mock_command.args = ""
        await cmd_start(mock_message, mock_command, mock_session, mock_bot, mock_state)
        
        mock_message.answer.assert_called_once_with("üëã –ü—Ä–∏–≤–µ—Ç, Test!")

    @pytest.mark.asyncio
    async def test_cmd_start_with_empty_args(self, mock_message, mock_command, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: –∫–æ–º–∞–Ω–¥–∞ /start —Å –ø—É—Å—Ç—ã–º–∏ –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏."""
        mock_command.args = None
        await cmd_start(mock_message, mock_command, mock_session, mock_bot, mock_state)
        
        mock_message.answer.assert_called_once_with("üëã –ü—Ä–∏–≤–µ—Ç, Test!")

    @pytest.mark.asyncio
    async def test_cmd_start_registers_user(self, mock_message, mock_command, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: –∫–æ–º–∞–Ω–¥–∞ /start —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
        with patch('handlers.common.start.register_user') as mock_register:
            mock_command.args = ""
            await cmd_start(mock_message, mock_command, mock_session, mock_bot, mock_state)
            
            mock_register.assert_called_once_with(
                mock_session,
                123456,
                "test_user",
                "Test User"
            )

    @pytest.mark.asyncio
    async def test_cmd_start_with_res_arg_no_winners(self, mock_message, mock_command, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: –∫–æ–º–∞–Ω–¥–∞ /start —Å –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º res_ –∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ–º –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π."""
        mock_command.args = "res_123"
        
        # –ú–æ–∫–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∑–∞–ø—Ä–æ—Å–∞ - –Ω–µ—Ç –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π
        mock_scalar_result = MagicMock()
        mock_scalar_result.scalars().all.return_value = []
        mock_session.execute.return_value = mock_scalar_result
        
        await cmd_start(mock_message, mock_command, mock_session, mock_bot, mock_state)
        
        mock_message.answer.assert_called_once_with("üòî –ü–æ–±–µ–¥–∏—Ç–µ–ª–µ–π –Ω–µ—Ç –∏–ª–∏ —Ä–æ–∑—ã–≥—Ä—ã—à –µ—â–µ –∏–¥–µ—Ç.")

    @pytest.mark.asyncio
    async def test_cmd_start_with_invalid_res_arg(self, mock_message, mock_command, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: –∫–æ–º–∞–Ω–¥–∞ /start —Å –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º res_."""
        mock_command.args = "res_invalid"
        
        await cmd_start(mock_message, mock_command, mock_session, mock_bot, mock_state)
        # –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –≤ int, —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–æ—Å—Ç–æ –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è –±–µ–∑ –≤—ã–∑–æ–≤–∞ answer

    @pytest.mark.asyncio
    async def test_cmd_start_with_gw_arg(self, mock_message, mock_command, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: –∫–æ–º–∞–Ω–¥–∞ /start —Å –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º gw_ (—É—á–∞—Å—Ç–∏–µ –≤ —Ä–æ–∑—ã–≥—Ä—ã—à–µ)."""
        mock_command.args = "gw_123"
        
        with patch('handlers.common.start.try_join_giveaway') as mock_try_join:
            await cmd_start(mock_message, mock_command, mock_session, mock_bot, mock_state)
            
            mock_try_join.assert_called_once_with(
                mock_message,
                123,
                mock_session,
                mock_bot,
                mock_state,
                None  # referrer_id
            )

    @pytest.mark.asyncio
    async def test_cmd_start_with_gw_arg_and_referrer(self, mock_message, mock_command, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: –∫–æ–º–∞–Ω–¥–∞ /start —Å –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º gw_ –∏ —Ç–æ–∫–µ–Ω–æ–º —Ä–µ—Ñ–µ—Ä–∞–ª–∞."""
        mock_command.args = "gw_123_ref_token"
        
        with patch('handlers.common.start.resolve_ref_link', return_value=789) as mock_resolve, \
             patch('handlers.common.start.try_join_giveaway') as mock_try_join:
            
            await cmd_start(mock_message, mock_command, mock_session, mock_bot, mock_state)
            
            mock_resolve.assert_called_once_with("ref_token")
            mock_try_join.assert_called_once_with(
                mock_message,
                123,
                mock_session,
                mock_bot,
                mock_state,
                789 # referrer_id
            )

    @pytest.mark.asyncio
    async def test_cmd_start_with_gw_arg_self_referral_blocked(self, mock_message, mock_command, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ —Å–∞–º–æ—Ä–µ—Ñ–µ—Ä–∞–ª–∞ –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ gw_."""
        mock_command.args = "gw_123_ref_token"
        
        with patch('handlers.common.start.resolve_ref_link', return_value=123456) as mock_resolve, \
             patch('handlers.common.start.try_join_giveaway') as mock_try_join:  # 123456 - ID —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            
            await cmd_start(mock_message, mock_command, mock_session, mock_bot, mock_state)
            
            # referrer_id –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å None, —Ç–∞–∫ –∫–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—ã—Ç–∞–µ—Ç—Å—è –ø—Ä–∏–≥–ª–∞—Å–∏—Ç—å —Å–∞–º —Å–µ–±—è
            mock_try_join.assert_called_once_with(
                mock_message,
                123,
                mock_session,
                mock_bot,
                mock_state,
                None  # referrer_id
            )

    @pytest.mark.asyncio
    async def test_cmd_start_with_broken_gw_arg(self, mock_message, mock_command, mock_session, mock_bot, mock_state):
        """–¢–µ—Å—Ç: –∫–æ–º–∞–Ω–¥–∞ /start —Å –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–Ω—ã–º –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º gw_."""
        mock_command.args = "gw_invalid"
        
        await cmd_start(mock_message, mock_command, mock_session, mock_bot, mock_state)
        
        mock_message.answer.assert_called_once_with("‚ùå –°—Å—ã–ª–∫–∞ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∞.")=== ./tests/test_start_content_handler.py ===
import asyncio
from unittest.mock import AsyncMock, MagicMock, patch

import pytest
from aiogram import Bot
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, CallbackQuery, User
from datetime import datetime, timedelta

from handlers.creator.constructor.start_content import start_constructor, receive_content, cancel_creation
from handlers.creator.constructor.structure import ConstructorState


class TestStartConstructor:
    """–¢–µ—Å—Ç—ã –¥–ª—è –Ω–∞—á–∞–ª–∞ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞ —Ä–æ–∑—ã–≥—Ä—ã—à–∞"""

    @pytest.fixture
    def mock_message(self):
        """–°–æ–∑–¥–∞–µ—Ç mock —Å–æ–æ–±—â–µ–Ω–∏—è."""
        message = MagicMock(spec=Message)
        message.from_user = MagicMock(spec=User)
        message.from_user.id = 123456
        message.from_user.username = "test_user"
        message.from_user.full_name = "Test User"
        message.answer = AsyncMock()
        message.delete = AsyncMock()
        message.chat = MagicMock()
        message.chat.id = -1001234567890
        return message

    @pytest.fixture
    def mock_callback(self):
        """–°–æ–∑–¥–∞–µ—Ç mock –∫–æ–ª–ª–±—ç–∫–∞."""
        callback = MagicMock(spec=CallbackQuery)
        callback.message = MagicMock(spec=Message)
        callback.message.from_user = MagicMock(spec=User)
        callback.message.from_user.id = 123456
        callback.message.from_user.username = "test_user"
        callback.message.from_user.full_name = "Test User"
        callback.from_user = MagicMock(spec=User)
        callback.from_user.id = 123456
        callback.from_user.username = "test_user"
        callback.from_user.full_name = "Test User"
        callback.message.answer = AsyncMock()
        callback.message.delete = AsyncMock()
        callback.message.chat = MagicMock()
        callback.message.chat.id = -1001234567890
        callback.answer = AsyncMock()
        return callback

    @pytest.fixture
    def mock_session(self):
        """–°–æ–∑–¥–∞–µ—Ç mock —Å–µ—Å—Å–∏–∏."""
        session = MagicMock(spec=FSMContext)
        session.clear = AsyncMock()
        session.set_data = AsyncMock()
        session.update_data = AsyncMock()
        session.get_data = AsyncMock()
        session.set_state = AsyncMock()
        return session

    @pytest.fixture
    def mock_bot(self):
        """–°–æ–∑–¥–∞–µ—Ç mock –±–æ—Ç–∞."""
        bot = MagicMock(spec=Bot)
        bot.get_me = AsyncMock(return_value=MagicMock(username="test_bot"))
        return bot

    @pytest.mark.asyncio
    async def test_start_constructor_from_command(self, mock_message, mock_session, mock_bot):
        """–¢–µ—Å—Ç: –Ω–∞—á–∞–ª–æ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞ —á–µ—Ä–µ–∑ –∫–æ–º–∞–Ω–¥—É /new."""
        with patch('handlers.creator.constructor.start_content.get_message_manager') as mock_get_manager, \
             patch('handlers.creator.constructor.start_content.get_now_msk', return_value=datetime.now()), \
             patch('handlers.creator.constructor.start_content.get_control_hint', return_value="hint text"):
            
            mock_manager = MagicMock()
            mock_manager.delete_all = AsyncMock()
            mock_get_manager.return_value = mock_manager
            
            await start_constructor(mock_message, mock_session)
            
            mock_session.clear.assert_called_once()
            mock_session.set_state.assert_called_once_with(ConstructorState.editing_content)
            mock_message.answer.assert_called_once()

    @pytest.mark.asyncio
    async def test_start_constructor_from_callback(self, mock_callback, mock_session, mock_bot):
        """–¢–µ—Å—Ç: –Ω–∞—á–∞–ª–æ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞ —á–µ—Ä–µ–∑ callback."""
        with patch('handlers.creator.constructor.start_content.get_message_manager') as mock_get_manager, \
             patch('handlers.creator.constructor.start_content.get_now_msk', return_value=datetime.now()), \
             patch('handlers.creator.constructor.start_content.get_control_hint', return_value="hint text"):
            
            mock_manager = MagicMock()
            mock_manager.delete_all = AsyncMock()
            mock_get_manager.return_value = mock_manager
            
            await start_constructor(mock_callback, mock_session)
            
            mock_session.clear.assert_called_once()
            mock_session.set_state.assert_called_once_with(ConstructorState.editing_content)
            mock_callback.message.answer.assert_called_once()


class TestReceiveContent:
    """–¢–µ—Å—Ç—ã –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –¥–ª—è —Ä–æ–∑—ã–≥—Ä—ã—à–∞"""

    @pytest.mark.asyncio
    async def test_receive_content_with_text_only(self, mock_message, mock_session, mock_bot):
        """–¢–µ—Å—Ç: –ø–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞."""
        mock_message.text = "Test giveaway text"
        mock_message.photo = None
        mock_message.video = None
        mock_message.animation = None
        mock_message.document = None
        mock_message.voice = None
        mock_message.audio = None
        mock_message.sticker = None
        mock_message.video_note = None
        mock_message.entities = []

        with patch('handlers.creator.constructor.start_content.get_message_manager') as mock_get_manager, \
             patch('handlers.creator.constructor.start_content.get_message_html', return_value="Test giveaway text"), \
             patch('handlers.creator.constructor.start_content.sanitize_text', return_value="Test giveaway text"), \
             patch('handlers.creator.constructor.start_content.refresh_constructor_view') as mock_refresh:
            
            mock_manager = MagicMock()
            mock_manager.add_temp_message = MagicMock()
            mock_get_manager.return_value = mock_manager
            
            await receive_content(mock_message, mock_session, mock_bot)
            
            mock_session.update_data.assert_called_once_with(
                text="Test giveaway text",
                media_file_id=None,
                media_type=None
            )
            mock_session.set_state.assert_called_once_with(ConstructorState.init)
            mock_refresh.assert_called_once()

    @pytest.mark.asyncio
    async def test_receive_content_with_photo(self, mock_message, mock_session, mock_bot):
        """–¢–µ—Å—Ç: –ø–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ —Å —Ñ–æ—Ç–æ."""
        mock_message.text = "Test giveaway text"
        mock_message.photo = [MagicMock(file_id="photo_file_id")]
        mock_message.video = None
        mock_message.animation = None
        mock_message.document = None
        mock_message.voice = None
        mock_message.audio = None
        mock_message.sticker = None
        mock_message.video_note = None
        mock_message.entities = []

        with patch('handlers.creator.constructor.start_content.get_message_manager') as mock_get_manager, \
             patch('handlers.creator.constructor.start_content.get_message_html', return_value="Test giveaway text"), \
             patch('handlers.creator.constructor.start_content.sanitize_text', return_value="Test giveaway text"), \
             patch('handlers.creator.constructor.start_content.refresh_constructor_view') as mock_refresh:
            
            mock_manager = MagicMock()
            mock_manager.add_temp_message = MagicMock()
            mock_get_manager.return_value = mock_manager
            
            await receive_content(mock_message, mock_session, mock_bot)
            
            mock_session.update_data.assert_called_once_with(
                text="Test giveaway text",
                media_file_id="photo_file_id",
                media_type="photo"
            )
            mock_session.set_state.assert_called_once_with(ConstructorState.init)
            mock_refresh.assert_called_once()

    @pytest.mark.asyncio
    async def test_receive_content_with_video(self, mock_message, mock_session, mock_bot):
        """–¢–µ—Å—Ç: –ø–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ —Å –≤–∏–¥–µ–æ."""
        mock_message.text = "Test giveaway text"
        mock_message.photo = None
        mock_message.video = MagicMock(file_id="video_file_id")
        mock_message.animation = None
        mock_message.document = None
        mock_message.voice = None
        mock_message.audio = None
        mock_message.sticker = None
        mock_message.video_note = None
        mock_message.entities = []

        with patch('handlers.creator.constructor.start_content.get_message_manager') as mock_get_manager, \
             patch('handlers.creator.constructor.start_content.get_message_html', return_value="Test giveaway text"), \
             patch('handlers.creator.constructor.start_content.sanitize_text', return_value="Test giveaway text"), \
             patch('handlers.creator.constructor.start_content.refresh_constructor_view') as mock_refresh:
            
            mock_manager = MagicMock()
            mock_manager.add_temp_message = MagicMock()
            mock_get_manager.return_value = mock_manager
            
            await receive_content(mock_message, mock_session, mock_bot)
            
            mock_session.update_data.assert_called_once_with(
                text="Test giveaway text",
                media_file_id="video_file_id",
                media_type="video"
            )
            mock_session.set_state.assert_called_once_with(ConstructorState.init)
            mock_refresh.assert_called_once()

    @pytest.mark.asyncio
    async def test_receive_content_with_animation(self, mock_message, mock_session, mock_bot):
        """–¢–µ—Å—Ç: –ø–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π."""
        mock_message.text = "Test giveaway text"
        mock_message.photo = None
        mock_message.video = None
        mock_message.animation = MagicMock(file_id="animation_file_id")
        mock_message.document = None
        mock_message.voice = None
        mock_message.audio = None
        mock_message.sticker = None
        mock_message.video_note = None
        mock_message.entities = []

        with patch('handlers.creator.constructor.start_content.get_message_manager') as mock_get_manager, \
             patch('handlers.creator.constructor.start_content.get_message_html', return_value="Test giveaway text"), \
             patch('handlers.creator.constructor.start_content.sanitize_text', return_value="Test giveaway text"), \
             patch('handlers.creator.constructor.start_content.refresh_constructor_view') as mock_refresh:
            
            mock_manager = MagicMock()
            mock_manager.add_temp_message = MagicMock()
            mock_get_manager.return_value = mock_manager
            
            await receive_content(mock_message, mock_session, mock_bot)
            
            mock_session.update_data.assert_called_once_with(
                text="Test giveaway text",
                media_file_id="animation_file_id",
                media_type="animation"
            )
            mock_session.set_state.assert_called_once_with(ConstructorState.init)
            mock_refresh.assert_called_once()

    @pytest.mark.asyncio
    async def test_receive_content_with_unsupported_media(self, mock_message, mock_session, mock_bot):
        """–¢–µ—Å—Ç: –ø–æ–ª—É—á–µ–Ω–∏–µ –Ω–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞."""
        mock_message.text = "Test giveaway text"
        mock_message.photo = None
        mock_message.video = None
        mock_message.animation = None
        mock_message.document = MagicMock()  # –ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç
        mock_message.voice = None
        mock_message.audio = None
        mock_message.sticker = None
        mock_message.video_note = None

        with patch('handlers.creator.constructor.start_content.get_message_manager') as mock_get_manager, \
             patch('handlers.creator.constructor.start_content.get_message_html', return_value="Test giveaway text"), \
             patch('handlers.creator.constructor.start_content.sanitize_text', return_value="Test giveaway text"):
            
            mock_manager = MagicMock()
            mock_manager.add_temp_message = MagicMock()
            mock_get_manager.return_value = mock_manager
            
            await receive_content(mock_message, mock_session, mock_bot)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
            assert mock_message.answer.called

    @pytest.mark.asyncio
    async def test_receive_content_text_too_long_with_media(self, mock_message, mock_session, mock_bot):
        """–¢–µ—Å—Ç: —Ç–µ–∫—Å—Ç —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ –º–µ–¥–∏–∞."""
        mock_message.text = "Test giveaway text"
        mock_message.photo = MagicMock(file_id="photo_file_id")
        mock_message.video = None
        mock_message.animation = None
        mock_message.document = None
        mock_message.voice = None
        mock_message.audio = None
        mock_message.sticker = None
        mock_message.video_note = None
        mock_message.entities = []

        with patch('handlers.creator.constructor.start_content.get_message_manager') as mock_get_manager, \
             patch('handlers.creator.constructor.start_content.get_message_html', return_value="Test giveaway text"), \
             patch('handlers.creator.constructor.start_content.sanitize_text', return_value="A" * 1025):  # –ü—Ä–µ–≤—ã—à–µ–Ω–∏–µ –ª–∏–º–∏—Ç–∞ –¥–ª—è –º–µ–¥–∏–∞
            
            mock_manager = MagicMock()
            mock_manager.add_temp_message = MagicMock()
            mock_get_manager.return_value = mock_manager
            
            await receive_content(mock_message, mock_session, mock_bot)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
            assert mock_message.answer.called

    @pytest.mark.asyncio
    async def test_receive_content_text_too_long_without_media(self, mock_message, mock_session, mock_bot):
        """–¢–µ—Å—Ç: —Ç–µ–∫—Å—Ç —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π –±–µ–∑ –º–µ–¥–∏–∞."""
        mock_message.text = "Test giveaway text"
        mock_message.photo = None
        mock_message.video = None
        mock_message.animation = None
        mock_message.document = None
        mock_message.voice = None
        mock_message.audio = None
        mock_message.sticker = None
        mock_message.video_note = None
        mock_message.entities = []

        with patch('handlers.creator.constructor.start_content.get_message_manager') as mock_get_manager, \
             patch('handlers.creator.constructor.start_content.get_message_html', return_value="Test giveaway text"), \
             patch('handlers.creator.constructor.start_content.sanitize_text', return_value="A" * 4097):  # –ü—Ä–µ–≤—ã—à–µ–Ω–∏–µ –ª–∏–º–∏—Ç–∞ –±–µ–∑ –º–µ–¥–∏–∞
            
            mock_manager = MagicMock()
            mock_manager.add_temp_message = MagicMock()
            mock_get_manager.return_value = mock_manager
            
            await receive_content(mock_message, mock_session, mock_bot)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
            assert mock_message.answer.called

    @pytest.mark.asyncio
    async def test_receive_content_empty_message(self, mock_message, mock_session, mock_bot):
        """–¢–µ—Å—Ç: –ø—É—Å—Ç–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ (–±–µ–∑ —Ç–µ–∫—Å—Ç–∞ –∏ –º–µ–¥–∏–∞)."""
        mock_message.text = None
        mock_message.photo = None
        mock_message.video = None
        mock_message.animation = None
        mock_message.document = None
        mock_message.voice = None
        mock_message.audio = None
        mock_message.sticker = None
        mock_message.video_note = None

        with patch('handlers.creator.constructor.start_content.get_message_manager') as mock_get_manager:
            
            mock_manager = MagicMock()
            mock_manager.add_temp_message = MagicMock()
            mock_get_manager.return_value = mock_manager
            
            await receive_content(mock_message, mock_session, mock_bot)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
            assert mock_message.answer.called

    @pytest.mark.asyncio
    async def test_receive_content_media_without_caption(self, mock_message, mock_session, mock_bot):
        """–¢–µ—Å—Ç: –º–µ–¥–∏–∞ –±–µ–∑ –æ–ø–∏—Å–∞–Ω–∏—è."""
        mock_message.text = None
        mock_message.caption = None
        mock_message.photo = MagicMock(file_id="photo_file_id")
        mock_message.video = None
        mock_message.animation = None
        mock_message.document = None
        mock_message.voice = None
        mock_message.audio = None
        mock_message.sticker = None
        mock_message.video_note = None
        mock_message.entities = []

        with patch('handlers.creator.constructor.start_content.get_message_manager') as mock_get_manager:
            
            mock_manager = MagicMock()
            mock_manager.add_temp_message = MagicMock()
            mock_get_manager.return_value = mock_manager
            
            await receive_content(mock_message, mock_session, mock_bot)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –æ–ø–∏—Å–∞–Ω–∏—è
            assert mock_message.answer.called


class TestCancelCreation:
    """–¢–µ—Å—Ç—ã –¥–ª—è –æ—Ç–º–µ–Ω—ã —Å–æ–∑–¥–∞–Ω–∏—è —Ä–æ–∑—ã–≥—Ä—ã—à–∞"""

    @pytest.mark.asyncio
    async def test_cancel_creation(self, mock_callback, mock_session, mock_bot):
        """–¢–µ—Å—Ç: –æ—Ç–º–µ–Ω–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ä–æ–∑—ã–≥—Ä—ã—à–∞."""
        with patch('handlers.creator.constructor.start_content.get_message_manager') as mock_get_manager:
            
            mock_manager = MagicMock()
            mock_manager.delete_all = AsyncMock()
            mock_get_manager.return_value = mock_manager
            
            await cancel_creation(mock_callback, mock_session, mock_bot)
            
            mock_manager.delete_all.assert_called_once_with(mock_bot, mock_callback.message.chat.id)
            mock_session.clear.assert_called_once()
            assert mock_callback.message.answer.called=== ./docker-compose.yml ===
# docker-compose.yml
version: '3.8'

services:
  bot:
    build: .
    env_file: .env
    depends_on:
      - db
      - redis
    restart: always

  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: pass
      POSTGRES_DB: giveaway_bot
    volumes:
      - pg_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data

volumes:
  pg_data:
  redis_data:=== ./core/tools/timezone.py ===
from datetime import datetime, timezone
from zoneinfo import ZoneInfo

# –ß–∞—Å–æ–≤—ã–µ –ø–æ—è—Å–∞
MSK = ZoneInfo("Europe/Moscow")
UTC = timezone.utc

def get_now_msk() -> datetime:
    return datetime.now(MSK)

def to_msk(dt: datetime) -> datetime:
    """–ü–µ—Ä–µ–≤–æ–¥–∏—Ç –¥–∞—Ç—É –≤ –ú–°–ö (–µ—Å–ª–∏ –æ–Ω–∞ naive, —Å—á–∏—Ç–∞–µ–º —á—Ç–æ —ç—Ç–æ UTC)"""
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=UTC)
    return dt.astimezone(MSK)

def to_utc(dt: datetime) -> datetime:
    """–ü–µ—Ä–µ–≤–æ–¥–∏—Ç –ú–°–ö –≤ UTC"""
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=MSK)
    return dt.astimezone(UTC)

def strip_tz(dt: datetime) -> datetime:
    """–£–¥–∞–ª—è–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–∞–π–º–∑–æ–Ω–µ –¥–ª—è –∑–∞–ø–∏—Å–∏ –≤ –ë–î (naive UTC)"""
    return dt.replace(tzinfo=None)=== ./core/tools/scheduler.py ===
# core/tools/scheduler.py
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.jobstores.redis import RedisJobStore
from redis import ConnectionPool
from config import config

# APScheduler 3.x –Ω–µ —É–º–µ–µ—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å —Å—Ç—Ä–æ–∫—É URL –Ω–∞–ø—Ä—è–º—É—é.
# –ú—ã —Å–æ–∑–¥–∞–µ–º –ø—É–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π —á–µ—Ä–µ–∑ redis-py, –∫–æ—Ç–æ—Ä—ã–π —É–º–µ–µ—Ç –ø–∞—Ä—Å–∏—Ç—å URL.
pool = ConnectionPool.from_url(config.REDIS_URL)

job_stores = {
    "default": RedisJobStore(
        jobs_key="giveaway_jobs", 
        run_times_key="giveaway_run_times", 
        connection_pool=pool  # <-- –ü–µ—Ä–µ–¥–∞–µ–º –≥–æ—Ç–æ–≤—ã–π –ø—É–ª –≤–º–µ—Å—Ç–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    )
}

scheduler = AsyncIOScheduler(jobstores=job_stores, timezone="UTC")

async def start_scheduler():
    scheduler.start()

async def shutdown_scheduler():
    scheduler.shutdown()=== ./core/tools/formatters.py ===
from datetime import datetime
from core.tools.timezone import to_msk

def format_giveaway_caption(prize_text: str, winners_count: int, finish_time: datetime, participants_count: int) -> str:
    # –ü–µ—Ä–µ–≤–æ–¥–∏–º –≤—Ä–µ–º—è –≤ –ú–°–ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
    finish_msk = to_msk(finish_time)
    
    # –°—á–∏—Ç–∞–µ–º –æ—Å—Ç–∞—Ç–æ–∫ –≤—Ä–µ–º–µ–Ω–∏
    now_msk = to_msk(datetime.utcnow())
    delta = finish_msk - now_msk
    
    if delta.total_seconds() < 0:
        time_left = "–ó–∞–≤–µ—Ä—à–µ–Ω"
    elif delta.days > 0:
        time_left = f"{delta.days} –¥–Ω."
    elif delta.seconds > 3600:
        time_left = f"{delta.seconds // 3600} —á."
    else:
        time_left = "–°–∫–æ—Ä–æ"

    date_str = finish_msk.strftime("%d.%m.%Y %H:%M MSK")

    return (
        f"{prize_text}\n\n"
        f"‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n"
        f"üë• <b>–£—á–∞—Å—Ç–Ω–∏–∫–æ–≤:</b> {participants_count}\n"
        f"üèÜ <b>–ü—Ä–∏–∑–æ–≤—ã—Ö –º–µ—Å—Ç:</b> {winners_count}\n"
        f"‚è≥ <b>–ò—Ç–æ–≥–∏:</b> {date_str} ({time_left})"
    )=== ./core/services/checker_service.py ===
import logging
from aiogram import Bot
from redis.asyncio import Redis
from config import config

# –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ Redis
redis = Redis.from_url(config.REDIS_URL)
logger = logging.getLogger(__name__)

async def is_user_subscribed(bot: Bot, channel_id: int, user_id: int, force_check: bool = False) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ–¥–ø–∏—Å–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞ –∫–∞–Ω–∞–ª.
    :param force_check: –ï—Å–ª–∏ True, –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç –∫–µ—à –∏ –¥–µ–ª–∞–µ—Ç –∑–∞–ø—Ä–æ—Å –∫ Telegram.
    """
    cache_key = f"sub_status:{channel_id}:{user_id}"
    
    # 1. –ï—Å–ª–∏ –ù–ï –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞, –ø—Ä–æ–±—É–µ–º –¥–æ—Å—Ç–∞—Ç—å –∏–∑ –∫–µ—à–∞
    if not force_check:
        cached_status = await redis.get(cache_key)
        if cached_status is not None:
            return cached_status.decode() == "1"

    # 2. –°–ø—Ä–∞—à–∏–≤–∞–µ–º —É Telegram
    try:
        member = await bot.get_chat_member(chat_id=channel_id, user_id=user_id)
        
        # –°—Ç–∞—Ç—É—Å—ã, –∫–æ—Ç–æ—Ä—ã–µ —Å—á–∏—Ç–∞—é—Ç—Å—è "–ø–æ–¥–ø–∏—Å–∞–Ω"
        if member.status in ('creator', 'administrator', 'member', 'restricted'):
            # –ö–µ—à–∏—Ä—É–µ–º –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–∞ 5 –º–∏–Ω—É—Ç
            await redis.set(cache_key, "1", ex=300)
            return True
        else:
            # –ö–µ—à–∏—Ä—É–µ–º –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–∞ 30 —Å–µ–∫—É–Ω–¥
            await redis.set(cache_key, "0", ex=30)
            return False
            
    except Exception as e:
        # –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É, —á—Ç–æ–±—ã –≤–∏–¥–µ—Ç—å –≤ –∫–æ–Ω—Å–æ–ª–∏, –µ—Å–ª–∏ –±–æ—Ç –Ω–µ –∞–¥–º–∏–Ω
        logger.error(f"Check sub error (User: {user_id}, Channel: {channel_id}): {e}")
        return False=== ./core/services/ref_service.py ===
import uuid
from redis.asyncio import Redis
from config import config

# –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ Redis (–∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—Ç –∂–µ URL, —á—Ç–æ –≤ –∫–æ–Ω—Ñ–∏–≥–µ)
redis = Redis.from_url(config.REDIS_URL)

async def create_ref_link(user_id: int) -> str:
    """
    –°–æ–∑–¥–∞–µ—Ç –∫–æ—Ä–æ—Ç–∫–∏–π UUID-—Ç–æ–∫–µ–Ω, –∫–æ—Ç–æ—Ä—ã–π —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π user_id.
    –¢–æ–∫–µ–Ω –∂–∏–≤–µ—Ç 30 –¥–Ω–µ–π.
    """
    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω (–±–µ–∑ —Ç–∏—Ä–µ, —á—Ç–æ–±—ã –±—ã–ª –∫–æ—Ä–æ—á–µ)
    token = uuid.uuid4().hex[:12] 
    key = f"ref_map:{token}"
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–µ—Ç —É —é–∑–µ—Ä–∞ —É–∂–µ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–π —Ç–æ–∫–µ–Ω (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ), 
    # –Ω–æ –ø—Ä–æ—â–µ –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤—ã–π –∏–ª–∏ —Ö—Ä–∞–Ω–∏—Ç—å –æ–±—Ä–∞—Ç–Ω—ã–π –∏–Ω–¥–µ–∫—Å.
    # –î–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏ –ø—Ä–æ—Å—Ç–æ –ø–∏—à–µ–º:
    await redis.set(key, user_id, ex=2592000) # 30 –¥–Ω–µ–π
    return token

async def resolve_ref_link(token: str) -> int | None:
    """–ü–æ–ª—É—á–∞–µ—Ç —Ä–µ–∞–ª—å–Ω—ã–π ID –ø–æ —Ç–æ–∫–µ–Ω—É"""
    key = f"ref_map:{token}"
    user_id = await redis.get(key)
    if user_id:
        return int(user_id)
    return None=== ./core/services/__init__.py ===
=== ./core/security/sanitizer.py ===
import bleach
from aiogram.types import Message

# –†–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–µ —Ç–µ–≥–∏ (Telegram API –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —ç—Ç–æ—Ç —Å–ø–∏—Å–æ–∫)
ALLOWED_TAGS = ['b', 'strong', 'i', 'em', 'u', 'ins', 's', 'strike', 'del', 'a', 'code', 'pre', 'blockquote', 'tg-spoiler']
ALLOWED_ATTRS = {'a': ['href']}

def sanitize_text(text: str) -> str:
    """–û—á–∏—â–∞–µ—Ç HTML –æ—Ç –º—É—Å–æ—Ä–∞, –æ—Å—Ç–∞–≤–ª—è—è –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ —Ç–µ–≥–∏ Telegram"""
    if not text:
        return ""
    return bleach.clean(text, tags=ALLOWED_TAGS, attributes=ALLOWED_ATTRS, strip=True)

def get_message_html(message: Message) -> str:
    """
    –ü—Ä–µ–≤—Ä–∞—â–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å entities (—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º Telegram) –≤ HTML-—Å—Ç—Ä–æ–∫—É.
    –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å—Å—ã–ª–∫–∏, –∂–∏—Ä–Ω—ã–π —Ç–µ–∫—Å—Ç –∏ —Ç.–¥.
    """
    text = message.text or message.caption
    if not text:
        return ""

    entities = message.entities or message.caption_entities
    if not entities:
        return text

    # Telegram –∏—Å–ø–æ–ª—å–∑—É–µ—Ç UTF-16 offsets
    utf16_text = text.encode("utf-16-le")
    html_text = ""
    last_offset = 0

    # –°–æ—Ä—Ç–∏—Ä—É–µ–º entities –ø–æ offset
    entities = sorted(entities, key=lambda e: e.offset)

    for entity in entities:
        if entity.offset < last_offset:
            continue
            
        start = entity.offset * 2
        end = (entity.offset + entity.length) * 2
        
        # –¢–µ–∫—Å—Ç –¥–æ —ç–Ω—Ç–∏—Ç–∏
        chunk = utf16_text[last_offset*2 : start].decode("utf-16-le")
        html_text += _escape(chunk)
        
        # –¢–µ–∫—Å—Ç –≤–Ω—É—Ç—Ä–∏ —ç–Ω—Ç–∏—Ç–∏
        inner_raw = utf16_text[start:end].decode("utf-16-le")
        inner = _escape(inner_raw)
        
        if entity.type == "bold":
            html_text += f"<b>{inner}</b>"
        elif entity.type == "italic":
            html_text += f"<i>{inner}</i>"
        elif entity.type == "underline":
            html_text += f"<u>{inner}</u>"
        elif entity.type == "strikethrough":
            html_text += f"<s>{inner}</s>"
        elif entity.type == "code":
            html_text += f"<code>{inner}</code>"
        elif entity.type == "pre":
            html_text += f"<pre>{inner}</pre>"
        elif entity.type == "text_link":
            html_text += f'<a href="{entity.url}">{inner}</a>'
        elif entity.type == "text_mention":
            html_text += f'<a href="tg://user?id={entity.user.id}">{inner}</a>'
        elif entity.type == "spoiler":
            html_text += f'<tg-spoiler>{inner}</tg-spoiler>'
        elif entity.type == "blockquote":
            html_text += f'<blockquote>{inner}</blockquote>'
        else:
            html_text += inner
            
        last_offset = entity.offset + entity.length

    # –û—Å—Ç–∞–≤—à–∏–π—Å—è —Ö–≤–æ—Å—Ç
    tail = utf16_text[last_offset*2:].decode("utf-16-le")
    html_text += _escape(tail)
    
    return html_text

def _escape(text: str) -> str:
    """–≠–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–ø–µ—Ü—Å–∏–º–≤–æ–ª–æ–≤ HTML"""
    return text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")=== ./core/security/hmac_signer.py ===
# core/security/hmac_signer.py
import hashlib
import hmac
from config import config

def _generate_hash(data_string: str) -> str:
    """–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ñ—É–Ω–∫—Ü–∏—è —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è"""
    return hmac.new(
        config.SECRET_KEY.encode(),
        data_string.encode(),
        hashlib.sha256
    ).hexdigest()[:12]  # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—ã–µ 12 —Å–∏–º–≤–æ–ª–æ–≤ –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞

def sign_data(action: str, entity_id: int, admin_id: int) -> str:
    """–°–æ–∑–¥–∞–µ—Ç –ø–æ–¥–ø–∏—Å—å: action + id + admin_id"""
    data = f"{action}:{entity_id}:{admin_id}"
    return _generate_hash(data)

def verify_signature(action: str, entity_id: int, admin_id: int, received_sig: str) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ–¥–ø–∏—Å—å. –ó–∞—â–∏—â–∞–µ—Ç –æ—Ç –ø–æ–¥–º–µ–Ω—ã ID –∏ User ID"""
    expected_sig = sign_data(action, entity_id, admin_id)
    return hmac.compare_digest(expected_sig, received_sig)=== ./core/__init__.py ===
=== ./core/logic/game_actions.py ===
import asyncio
import logging
import secrets
from aiogram import Bot
from aiogram.client.default import DefaultBotProperties
from aiogram.exceptions import TelegramForbiddenError, TelegramNotFound
from config import config
from database import async_session_maker
from database.requests.giveaway_repo import get_giveaway_by_id, get_active_giveaways, get_required_channels
from database.requests.participant_repo import get_weighted_candidates, get_participants_count
from database.models.winner import Winner
from core.tools.formatters import format_giveaway_caption
from keyboards.inline.participation import join_keyboard, results_keyboard
from core.services.checker_service import is_user_subscribed

logger = logging.getLogger(__name__)

async def check_subscription_all(bot: Bot, user_id: int, main_channel_id: int, required_channels: list) -> bool:
    try:
        # 1. –û—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª
        if not await is_user_subscribed(bot, main_channel_id, user_id):
            return False

        # 2. –°–ø–æ–Ω—Å–æ—Ä—ã
        for req in required_channels:
            if not await is_user_subscribed(bot, req.channel_id, user_id):
                return False
        
        return True
    except Exception as e:
        logger.error(f"Sub check failed for user {user_id}: {e}")
        return False

async def finish_giveaway_task(giveaway_id: int):
    """
    –§–∏–Ω–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–æ–∑—ã–≥—Ä—ã—à–∞.
    –° –∑–∞—â–∏—Ç–æ–π –æ—Ç '–º–µ—Ä—Ç–≤—ã—Ö –¥—É—à'.
    """
    bot = Bot(
        token=config.BOT_TOKEN.get_secret_value(),
        default=DefaultBotProperties(parse_mode="HTML")
    )
    
    try:
        bot_info = await bot.get_me()

        async with async_session_maker() as session:
            gw = await get_giveaway_by_id(session, giveaway_id)
            if not gw or gw.status != 'active':
                logger.warning(f"GW {giveaway_id} is not active or not found.")
                return

            req_channels = await get_required_channels(session, giveaway_id)
            final_winner_ids = []
            
            # --- –≠–¢–ê–ü 1: –ü–æ–¥–∫—Ä—É—Ç–∫–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å) ---
            if gw.predetermined_winner_id:
                if await check_subscription_all(bot, gw.predetermined_winner_id, gw.channel_id, req_channels):
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∂–∏–≤ –ª–∏ —é–∑–µ—Ä
                    try:
                        await bot.send_chat_action(gw.predetermined_winner_id, "typing")
                        final_winner_ids.append(gw.predetermined_winner_id)
                    except:
                        logger.warning(f"Rigged winner {gw.predetermined_winner_id} is dead/blocked.")

            # --- –≠–¢–ê–ü 2: –ß–µ—Å—Ç–Ω—ã–π –≤—ã–±–æ—Ä (—Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –Ω–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å) ---
            needed = gw.winners_count - len(final_winner_ids)
            processed_candidates = set(final_winner_ids)
            
            attempts = 0
            max_attempts = 15 
            
            while needed > 0 and attempts < max_attempts:
                attempts += 1
                batch_size = needed * 4 + 10 
                candidates = await get_weighted_candidates(session, giveaway_id, limit=batch_size)
                
                if not candidates:
                    break 

                has_new = False
                for uid in candidates:
                    if uid in processed_candidates:
                        continue
                    
                    has_new = True
                    processed_candidates.add(uid)
                    
                    # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–ø–∏—Å–∫—É
                    if await check_subscription_all(bot, uid, gw.channel_id, req_channels):
                        # 2. –ü–†–û–í–ï–†–ö–ê –ù–ê "–ñ–ò–í–û–ì–û" –Æ–ó–ï–†–ê
                        try:
                            # –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å "—Ç–∏—Ö–æ–µ" –¥–µ–π—Å—Ç–≤–∏–µ –∏–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ
                            # –≠—Ç–æ —Å–∞–º—ã–π –Ω–∞–¥–µ–∂–Ω—ã–π —Å–ø–æ—Å–æ–± —É–∑–Ω–∞—Ç—å, –Ω–µ –∑–∞–±–ª–æ—á–∏–ª –ª–∏ –æ–Ω –±–æ—Ç–∞
                            await bot.send_chat_action(uid, "typing")
                            
                            # –ï—Å–ª–∏ –æ–∫ - –¥–æ–±–∞–≤–ª—è–µ–º
                            final_winner_ids.append(uid)
                            needed -= 1
                            if needed == 0: break
                            
                        except (TelegramForbiddenError, TelegramNotFound):
                            logger.info(f"User {uid} blocked bot or deleted account. Skipping.")
                            continue
                        except Exception as e:
                            logger.error(f"Error checking user {uid}: {e}")
                            continue
                
                if not has_new:
                    break

            # --- –≠–¢–ê–ü 3: –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ ---
            gw.status = "finished"
            
            for uid in final_winner_ids:
                session.add(Winner(giveaway_id=gw.id, user_id=uid))
            
            await session.commit()
            
            # –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞
            if not final_winner_ids:
                result_text = "üòî <b>–†–æ–∑—ã–≥—Ä—ã—à –∑–∞–≤–µ—Ä—à–µ–Ω –±–µ–∑ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π.</b>"
            else:
                mentions = []
                for idx, uid in enumerate(final_winner_ids, 1):
                    try:
                        chat = await bot.get_chat(uid)
                        
                        # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ –õ–°
                        try:
                            await bot.send_message(
                                uid, 
                                f"üéâ <b>–ü–û–ó–î–†–ê–í–õ–Ø–ï–ú!</b>\n\n"
                                f"–í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ –ø—Ä–∏–∑: <b>{gw.prize_text[:50]}...</b>\n"
                                f"–°–≤—è–∂–∏—Ç–µ—Å—å —Å –æ—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä–∞–º–∏!"
                            )
                        except: pass

                        if chat.username:
                            user_link = f"@{chat.username}"
                        else:
                            user_link = f"<a href='tg://user?id={uid}'>{chat.full_name}</a>"
                        
                        mentions.append(f"{idx}. {user_link}")

                    except Exception:
                        mentions.append(f"{idx}. ID {uid}")

                winners_list_str = "\n".join(mentions)
                result_text = (
                    f"üéÅ <b>–†–û–ó–´–ì–†–´–® –ó–ê–í–ï–†–®–ï–ù!</b>\n\n"
                    f"üèÜ <b>–ü–æ–±–µ–¥–∏—Ç–µ–ª–∏:</b>\n"
                    f"{winners_list_str}\n\n"
                    f"üéâ <i>–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º —Å—á–∞—Å—Ç–ª–∏–≤—á–∏–∫–æ–≤!</i>"
                )

            # –ü—É–±–ª–∏–∫–∞—Ü–∏—è
            try:
                try:
                    await bot.send_message(
                        chat_id=gw.channel_id,
                        text=result_text,
                        reply_to_message_id=gw.message_id,
                        disable_web_page_preview=True
                    )
                except:
                    await bot.send_message(
                        chat_id=gw.channel_id,
                        text=result_text,
                        disable_web_page_preview=True
                    )
                
                try:
                    await bot.edit_message_reply_markup(
                        chat_id=gw.channel_id,
                        message_id=gw.message_id,
                        reply_markup=results_keyboard(bot_info.username, giveaway_id)
                    )
                except: pass
                    
            except Exception as e:
                logger.error(f"Error publishing results: {e}")

    finally:
        await bot.session.close()

async def update_active_giveaways_task():
    """–§–æ–Ω–æ–≤–∞—è –∑–∞–¥–∞—á–∞: –æ–±–Ω–æ–≤–ª—è–µ—Ç —Å—á–µ—Ç—á–∏–∫–∏."""
    bot = Bot(
        token=config.BOT_TOKEN.get_secret_value(), 
        default=DefaultBotProperties(parse_mode="HTML")
    )
    
    try:
        bot_info = await bot.get_me()
        
        async with async_session_maker() as session:
            active_gws = await get_active_giveaways(session)
            
            for gw in active_gws:
                try:
                    count = await get_participants_count(session, gw.id)
                    new_caption = format_giveaway_caption(
                        gw.prize_text, gw.winners_count, gw.finish_time, count
                    )
                    kb = join_keyboard(bot_info.username, gw.id)

                    if gw.media_file_id:
                        await bot.edit_message_caption(
                            chat_id=gw.channel_id, message_id=gw.message_id,
                            caption=new_caption, reply_markup=kb
                        )
                    else:
                        await bot.edit_message_text(
                            chat_id=gw.channel_id, message_id=gw.message_id,
                            text=new_caption, reply_markup=kb, disable_web_page_preview=True
                        )
                    await asyncio.sleep(0.1)

                except Exception as e:
                    if "message is not modified" in str(e): continue
                    logger.error(f"Skip update GW {gw.id}: {e}")
    finally:
        await bot.session.close()=== ./core/logic/ticket_gen.py ===
# core/logic/ticket_gen.py
import secrets
import string
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from database.models.participant import Participant

def generate_ticket_string(length=5) -> str:
    """–ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ —Å—Ç–æ–π–∫–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è"""
    chars = string.ascii_uppercase + string.digits
    # secrets.choice –±–µ–∑–æ–ø–∞—Å–Ω–µ–µ random.choice
    return ''.join(secrets.choice(chars) for _ in range(length))

async def get_unique_ticket(session: AsyncSession, giveaway_id: int) -> str:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –±–∏–ª–µ—Ç"""
    for _ in range(100):
        code = generate_ticket_string()
        stmt = select(Participant).where(
            Participant.giveaway_id == giveaway_id,
            Participant.ticket_code == code
        )
        existing = await session.scalar(stmt)
        if not existing:
            return code
    return "ERROR"=== ./core/logic/randomizer.py ===
# core/logic/randomizer.py
import secrets
from database.models.giveaway import Giveaway

def select_winners(giveaway: Giveaway, participant_ids: list[int]) -> list[int]:
    """
    –í—ã–±–∏—Ä–∞–µ—Ç –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π.
    1. –ï—Å–ª–∏ –µ—Å—Ç—å predetermined_winner_id - –æ–Ω –ø–æ–±–µ–∂–¥–∞–µ—Ç –ø–µ—Ä–≤—ã–º.
    2. –û—Å—Ç–∞–ª—å–Ω—ã–µ –≤—ã–±–∏—Ä–∞—é—Ç—Å—è —á–µ—Å—Ç–Ω—ã–º —Ä–∞–Ω–¥–æ–º–æ–º (SystemRandom).
    """
    winners = []
    pool = set(participant_ids) # –ò—Å–ø–æ–ª—å–∑—É–µ–º set –¥–ª—è —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏ –∏ O(1) —É–¥–∞–ª–µ–Ω–∏—è

    # 1. –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥–∫—Ä—É—Ç–∫–∏ (Rigging)
    if giveaway.predetermined_winner_id:
        if giveaway.predetermined_winner_id in pool:
            winners.append(giveaway.predetermined_winner_id)
            pool.remove(giveaway.predetermined_winner_id)
        # –ï—Å–ª–∏ "–±–ª–∞—Ç–Ω–æ–≥–æ" –Ω–µ—Ç –≤ —É—á–∞—Å—Ç–Ω–∏–∫–∞—Ö, –ø–æ–¥–∫—Ä—É—Ç–∫–∞ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç (–∑–∞—â–∏—Ç–∞ –æ—Ç –¥—É—Ä–∞–∫–∞)

    # 2. –°–∫–æ–ª—å–∫–æ –µ—â–µ –Ω—É–∂–Ω–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π?
    needed = giveaway.winners_count - len(winners)

    if needed > 0:
        pool_list = list(pool)
        if len(pool_list) <= needed:
            # –£—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –º–µ–Ω—å—à–µ, —á–µ–º –ø—Ä–∏–∑–æ–≤ -> –≤—Å–µ –ø–æ–±–µ–∂–¥–∞—é—Ç
            winners.extend(pool_list)
        else:
            # –ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ —Å—Ç–æ–π–∫–∏–π –≤—ã–±–æ—Ä
            random_winners = secrets.SystemRandom().sample(pool_list, k=needed)
            winners.extend(random_winners)

    return winners=== ./core/logic/exceptions.py ===
# core/logic/exceptions.py

class BotError(Exception):
    """–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –æ—à–∏–±–æ–∫ –±–æ—Ç–∞"""
    pass

class SecurityError(BotError):
    """–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∏ –∏–ª–∏ –ø—Ä–∞–≤"""
    pass

class GiveawayInvalidError(BotError):
    """–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–∞"""
    pass=== ./config.py ===
from typing import List
from pydantic_settings import BaseSettings
from pydantic import SecretStr, field_validator

class Settings(BaseSettings):
    BOT_TOKEN: SecretStr
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä, —á—Ç–æ–±—ã –ø—Ä–µ–≤—Ä–∞—â–∞—Ç—å —Å—Ç—Ä–æ–∫—É "123,456" –≤ —Å–ø–∏—Å–æ–∫ [123, 456]
    ADMIN_IDS: List[int]
    DB_DNS: str
    REDIS_URL: str
    SECRET_KEY: str

    @field_validator("ADMIN_IDS", mode="before")
    @classmethod
    def parse_admin_ids(cls, v):
        # –ï—Å–ª–∏ –ø—Ä–∏—à–ª–∞ —Å—Ç—Ä–æ–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä "123,456"), —Å–ø–ª–∏—Ç–∏–º –µ—ë
        if isinstance(v, str):
            # –£–¥–∞–ª—è–µ–º –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã–µ —Å–∫–æ–±–∫–∏ –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏—Ö –≤—Å–µ-—Ç–∞–∫–∏ –Ω–∞–ø–∏—Å–∞–ª
            v = v.replace("[", "").replace("]", "")
            if not v:
                return []
            return [int(x.strip()) for x in v.split(",")]
        # –ï—Å–ª–∏ –ø—Ä–∏—à–ª–æ —á–∏—Å–ª–æ (–æ–¥–∏–Ω –∞–¥–º–∏–Ω –±–µ–∑ –∫–∞–≤—ã—á–µ–∫ –∏ –∑–∞–ø—è—Ç—ã—Ö)
        if isinstance(v, int):
            return [v]
        return v

    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"

config = Settings()=== ./middlewares/throttling.py ===
from typing import Callable, Awaitable, Dict, Any
from aiogram import BaseMiddleware
from aiogram.types import CallbackQuery, Message
from redis.asyncio import Redis

class ThrottlingMiddleware(BaseMiddleware):
    def __init__(self, redis: Redis, rate_limit: float = 1.0):
        self.redis = redis
        self.rate_limit = rate_limit

    async def __call__(
        self,
        handler: Callable[[Message | CallbackQuery, Dict[str, Any]], Awaitable[Any]],
        event: Message | CallbackQuery,
        data: Dict[str, Any]
    ) -> Any:
        # –†–∞–±–æ—Ç–∞–µ–º —Ç–æ–ª—å–∫–æ —Å –∫–æ–ª–±—ç–∫–∞–º–∏ (–∫–Ω–æ–ø–∫–∏) –∏–ª–∏ –∫–æ–º–∞–Ω–¥–∞–º–∏
        user_id = event.from_user.id
        
        # –ö–ª—é—á –∞–Ω—Ç–∏-—Å–ø–∞–º–∞: throttle:USER_ID
        key = f"throttle:{user_id}"
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫–ª—é—á–∞ –≤ Redis
        if await self.redis.get(key):
            # –ï—Å–ª–∏ –∫–ª—é—á –µ—Å—Ç—å, –∑–Ω–∞—á–∏—Ç –ø—Ä–æ—à–ª–æ –º–µ–Ω—å—à–µ rate_limit —Å–µ–∫—É–Ω–¥
            if isinstance(event, CallbackQuery):
                await event.answer("‚è≥ –ù–µ —Ç–∞–∫ –±—ã—Å—Ç—Ä–æ!", show_alert=True)
            return # –ü—Ä–µ—Ä—ã–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É, —Ö–µ–Ω–¥–ª–µ—Ä –Ω–µ –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è
            
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–ª—é—á —Å –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏ (TTL) = rate_limit
        await self.redis.set(key, "1", ex=int(self.rate_limit))
        
        # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –¥–∞–ª—å—à–µ
        return await handler(event, data)=== ./middlewares/role_check.py ===
=== ./middlewares/__init__.py ===
=== ./middlewares/db_session.py ===
# middlewares/db_session.py
from typing import Callable, Awaitable, Dict, Any
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject
from database import async_session_maker

class DbSessionMiddleware(BaseMiddleware):
    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any]
    ) -> Any:
        async with async_session_maker() as session:
            data["session"] = session
            return await handler(event, data)=== ./middlewares/admin_hmac.py ===
# middlewares/admin_hmac.py
from typing import Callable, Awaitable, Dict, Any
from aiogram import BaseMiddleware
from aiogram.types import CallbackQuery
from core.security.hmac_signer import verify_signature

class AdminSecurityMiddleware(BaseMiddleware):
    async def __call__(
        self,
        handler: Callable[[CallbackQuery, Dict[str, Any]], Awaitable[Any]],
        event: CallbackQuery,
        data: Dict[str, Any]
    ) -> Any:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ callback data
        if not isinstance(event, CallbackQuery) or not event.data:
            return await handler(event, data)

        # –ï—Å–ª–∏ –ø—Ä–µ—Ñ–∏–∫—Å 'adm', –∑–Ω–∞—á–∏—Ç —ç—Ç–æ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å
        # –§–æ—Ä–º–∞—Ç: adm:action:id:sig
        if event.data.startswith("adm:"):
            parts = event.data.split(":")
            if len(parts) != 4:
                await event.answer("‚ùå Broken data", show_alert=True)
                return
            
            _, action, entity_id, sig = parts
            admin_id = event.from_user.id
            
            # –ü–†–û–í–ï–†–ö–ê –ü–û–î–ü–ò–°–ò
            if not verify_signature(action, int(entity_id), admin_id, sig):
                print(f"[SECURITY ALERT] Bad Signature from user {admin_id}")
                await event.answer("‚õî Security Alert: Invalid Signature!", show_alert=True)
                return

        return await handler(event, data)=== ./main.py ===
import asyncio
import logging
from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from aiogram.fsm.storage.redis import RedisStorage
from redis.asyncio import Redis

from config import config
from database import engine, Base
from core.tools.scheduler import start_scheduler, scheduler
from core.logic.game_actions import update_active_giveaways_task

from middlewares.db_session import DbSessionMiddleware
from middlewares.admin_hmac import AdminSecurityMiddleware
from middlewares.throttling import ThrottlingMiddleware

# –ò–º–ø–æ—Ä—Ç—ã –†–æ—É—Ç–µ—Ä–æ–≤
from handlers.common import start
from handlers.participant import join
from handlers.super_admin import menu_main, list_view, manage_item, rig_winner, broadcast
# –Æ–∑–µ—Ä –ü–∞–Ω–µ–ª—å
from handlers.user import dashboard, my_channels, my_participations, my_giveaways, premium
# –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä
from handlers.creator import constructor 
from handlers.creator import time_picker

async def main():
    logging.basicConfig(level=logging.INFO)
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ë–î (—Å–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç)
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    redis = Redis.from_url(config.REDIS_URL)
    bot = Bot(token=config.BOT_TOKEN.get_secret_value(), default=DefaultBotProperties(parse_mode="HTML"))
    dp = Dispatcher(storage=RedisStorage(redis=redis))

    # --- Middleware ---
    # 1. –°–µ—Å—Å–∏—è –ë–î –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∞–ø–¥–µ–π—Ç–∞
    dp.update.middleware(DbSessionMiddleware())
    
    # 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∏ –∞–¥–º–∏–Ω–∞ (–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∫–Ω–æ–ø–æ–∫)
    dp.callback_query.middleware(AdminSecurityMiddleware())
    
    # 3. –ê–Ω—Ç–∏-—Å–ø–∞–º (Throttling) - –∑–∞—â–∏—Ç–∞ –æ—Ç —á–∞—Å—Ç—ã—Ö –∫–ª–∏–∫–æ–≤
    # –ü–æ–¥–∫–ª—é—á–∞–µ–º –∏ –∫ —Å–æ–æ–±—â–µ–Ω–∏—è–º, –∏ –∫ –∫–æ–ª–±—ç–∫–∞–º
    dp.message.middleware(ThrottlingMiddleware(redis, rate_limit=1.0))
    dp.callback_query.middleware(ThrottlingMiddleware(redis, rate_limit=1.0))

    # --- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –†–æ—É—Ç–µ—Ä–æ–≤ ---
    
    # 1. –ê–¥–º–∏–Ω–∫–∞
    dp.include_routers(
        menu_main.router, 
        list_view.router, 
        manage_item.router, 
        rig_winner.router,
        broadcast.router # –î–æ–±–∞–≤–∏–ª–∏ —Ä–æ—É—Ç–µ—Ä —Ä–∞—Å—Å—ã–ª–∫–∏
    )

    # 2. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∞—è –ø–∞–Ω–µ–ª—å (–î–∞—à–±–æ—Ä–¥, –ö–∞–Ω–∞–ª—ã, –ú–æ–∏ –†–æ–∑—ã–≥—Ä—ã—à–∏, –ü—Ä–µ–º–∏—É–º, –£—á–∞—Å—Ç–∏—è)
    dp.include_router(dashboard.router)
    dp.include_router(my_channels.router)
    dp.include_router(my_giveaways.router)
    dp.include_router(premium.router)
    dp.include_router(my_participations.router)
    
    # 3. –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä
    dp.include_router(time_picker.router)
    dp.include_router(constructor.router)

    # 4. –£—á–∞—Å—Ç–∏–µ –∏ –°—Ç–∞—Ä—Ç (–≤–∞–∂–µ–Ω –ø–æ—Ä—è–¥–æ–∫, start –ª–æ–≤–∏—Ç –¥–∏–ø–ª–∏–Ω–∫–∏)
    dp.include_router(join.router)
    dp.include_router(start.router)

    # –ó–∞–ø—É—Å–∫ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞ (–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—á–µ—Ç—á–∏–∫–æ–≤ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —Ä–∞–∑ –≤ 30 –º–∏–Ω)
    scheduler.add_job(update_active_giveaways_task, "interval", minutes=30, id="global_updater", replace_existing=True)
    await start_scheduler()

    try:
        # –í–ê–ñ–ù–û: –£–¥–∞–ª—è–µ–º –≤–µ–±—Ö—É–∫ –∏ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ä—ã–µ –∞–ø–¥–µ–π—Ç—ã –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º
        # –≠—Ç–æ —Ä–µ—à–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—É –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å—Ç–∞—Ä—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –ø—Ä–∏ —Ä–µ—Å—Ç–∞—Ä—Ç–µ
        await bot.delete_webhook(drop_pending_updates=True)
        
        await dp.start_polling(bot)
    finally:
        await bot.session.close()
        await redis.aclose()

if __name__ == "__main__":
    asyncio.run(main())=== ./filters/is_admin.py ===
# filters/is_admin.py
from aiogram.filters import BaseFilter
from aiogram.types import Message, CallbackQuery
from config import config

class IsAdmin(BaseFilter):
    async def __call__(self, obj: Message | CallbackQuery) -> bool:
        # –†–∞–±–æ—Ç–∞–µ—Ç –∏ –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏–π, –∏ –¥–ª—è –∫–æ–ª–±—ç–∫–æ–≤
        user_id = obj.from_user.id
        return user_id in config.ADMIN_IDS=== ./filters/is_chat_member.py ===
# filters/is_chat_member.py
from aiogram.filters import BaseFilter
from aiogram.types import Message
from aiogram import Bot

class IsBotAdminInChat(BaseFilter):
    async def __call__(self, message: Message, bot: Bot) -> bool:
        if not message.forward_from_chat:
            return False
        
        chat_id = message.forward_from_chat.id
        try:
            member = await bot.get_chat_member(chat_id, bot.id)
            return member.status in ("administrator", "creator")
        except Exception:
            return False=== ./filters/__init__.py ===
=== ./database/models/channel.py ===
from sqlalchemy import BigInteger, String, ForeignKey
from sqlalchemy.orm import Mapped, mapped_column
from database.base import Base

class Channel(Base):
    __tablename__ = "channels"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.user_id")) # –í–ª–∞–¥–µ–ª–µ—Ü –∫–∞–Ω–∞–ª–∞
    
    channel_id: Mapped[int] = mapped_column(BigInteger) # ID –∫–∞–Ω–∞–ª–∞ –≤ Telegram
    title: Mapped[str] = mapped_column(String)
    username: Mapped[str | None] = mapped_column(String, nullable=True)
    
    # –ù–û–í–û–ï –ü–û–õ–ï: –°—Å—ã–ª–∫–∞-–ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ (–¥–ª—è –ø—Ä–∏–≤–∞—Ç–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤)
    invite_link: Mapped[str | None] = mapped_column(String, nullable=True)=== ./database/models/winner.py ===
from datetime import datetime
from sqlalchemy import BigInteger, ForeignKey, DateTime
from sqlalchemy.orm import Mapped, mapped_column
from database.base import Base

class Winner(Base):
    __tablename__ = "winners"

    giveaway_id: Mapped[int] = mapped_column(ForeignKey("giveaways.id"), primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.user_id"), primary_key=True)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)=== ./database/models/pending_referral.py ===
from sqlalchemy import BigInteger, ForeignKey, Integer
from sqlalchemy.orm import Mapped, mapped_column
from database.base import Base

class PendingReferral(Base):
    """
    –í—Ä–µ–º–µ–Ω–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–π —Å–≤—è–∑–∏.
    –ù—É–∂–Ω–∞, —á—Ç–æ–±—ã –Ω–µ –ø–æ—Ç–µ—Ä—è—Ç—å —Ä–µ—Ñ–µ—Ä–µ—Ä–∞, –µ—Å–ª–∏ –±–æ—Ç –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—Å—è 
    –≤ –º–æ–º–µ–Ω—Ç, –ø–æ–∫–∞ —é–∑–µ—Ä –ø–æ–¥–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –Ω–∞ –∫–∞–Ω–∞–ª—ã.
    """
    __tablename__ = "pending_referrals"

    user_id: Mapped[int] = mapped_column(BigInteger, primary_key=True) # –¢–æ—Ç, –∫–æ–≥–æ –ø—Ä–∏–≥–ª–∞—Å–∏–ª–∏
    giveaway_id: Mapped[int] = mapped_column(BigInteger, primary_key=True)
    referrer_id: Mapped[int] = mapped_column(BigInteger) # –¢–æ—Ç, –∫—Ç–æ –ø—Ä–∏–≥–ª–∞—Å–∏–ª=== ./database/models/user.py ===
from datetime import datetime
from sqlalchemy import BigInteger, String, Boolean, DateTime
from sqlalchemy.orm import Mapped, mapped_column
from database.base import Base

class User(Base):
    __tablename__ = "users"

    user_id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=False)
    username: Mapped[str | None] = mapped_column(String, nullable=True)
    full_name: Mapped[str] = mapped_column(String)
    
    # --- Monetization ---
    is_premium: Mapped[bool] = mapped_column(Boolean, default=False)
    premium_until: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)

    def __repr__(self):
        return f"<User {self.user_id}>"=== ./database/models/giveaway.py ===
from datetime import datetime
from sqlalchemy import BigInteger, String, DateTime, Integer, Text, ForeignKey, Boolean
from sqlalchemy.orm import Mapped, mapped_column
from database.base import Base

class Giveaway(Base):
    __tablename__ = "giveaways"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    owner_id: Mapped[int] = mapped_column(ForeignKey("users.user_id"))
    channel_id: Mapped[int] = mapped_column(BigInteger)
    message_id: Mapped[int] = mapped_column(BigInteger)
    
    prize_text: Mapped[str] = mapped_column(Text)
    winners_count: Mapped[int] = mapped_column(Integer, default=1)
    finish_time: Mapped[datetime] = mapped_column(DateTime)
    
    status: Mapped[str] = mapped_column(String, default="active")
    predetermined_winner_id: Mapped[int | None] = mapped_column(BigInteger, nullable=True)

    media_file_id: Mapped[str | None] = mapped_column(String, nullable=True)
    media_type: Mapped[str | None] = mapped_column(String, nullable=True)
    
    # winner_ids –£–î–ê–õ–ï–ù–û. –¢–µ–ø–µ—Ä—å –¥–∞–Ω–Ω—ã–µ –≤ —Ç–∞–±–ª–∏—Ü–µ winners.

    is_referral_enabled: Mapped[bool] = mapped_column(Boolean, default=False)
    is_captcha_enabled: Mapped[bool] = mapped_column(Boolean, default=False)
    is_paid: Mapped[bool] = mapped_column(Boolean, default=False)=== ./database/models/participant.py ===
# database/models/participant.py
from datetime import datetime
from sqlalchemy import BigInteger, ForeignKey, DateTime, Integer, String
from sqlalchemy.orm import Mapped, mapped_column
from database.base import Base

class Participant(Base):
    __tablename__ = "participants"

    user_id: Mapped[int] = mapped_column(ForeignKey("users.user_id"), primary_key=True)
    giveaway_id: Mapped[int] = mapped_column(ForeignKey("giveaways.id"), primary_key=True)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

    # –ö–æ–ª-–≤–æ —à–∞–Ω—Å–æ–≤ (–±–∏–ª–µ—Ç–æ–≤)
    tickets_count: Mapped[int] = mapped_column(Integer, default=1) 
    
    # ID —Ç–æ–≥–æ, –∫—Ç–æ –ø—Ä–∏–≥–ª–∞—Å–∏–ª (—Ö—Ä–∞–Ω–∏–º —Ä–µ–∞–ª—å–Ω—ã–π ID, –∞ –Ω–µ —Ö–µ—à)
    referrer_id: Mapped[int | None] = mapped_column(BigInteger, nullable=True) 
    
    # –¢–µ–∫—Å—Ç–æ–≤—ã–π –∫–æ–¥ –±–∏–ª–µ—Ç–∞
    ticket_code: Mapped[str | None] = mapped_column(String(10), nullable=True)=== ./database/models/required_channel.py ===
from sqlalchemy import BigInteger, String, ForeignKey
from sqlalchemy.orm import Mapped, mapped_column
from database.base import Base

class GiveawayRequiredChannel(Base):
    __tablename__ = "giveaway_required_channels"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    giveaway_id: Mapped[int] = mapped_column(ForeignKey("giveaways.id"))
    
    channel_id: Mapped[int] = mapped_column(BigInteger) # ID –∫–∞–Ω–∞–ª–∞ —Å–ø–æ–Ω—Å–æ—Ä–∞
    channel_title: Mapped[str] = mapped_column(String)  # –ù–∞–∑–≤–∞–Ω–∏–µ (–¥–ª—è —Å–ø–∏—Å–∫–∞)
    channel_link: Mapped[str] = mapped_column(String)   # –°—Å—ã–ª–∫–∞ (username –∏–ª–∏ invite link)=== ./database/models/__init__.py ===
=== ./database/requests/user_repo.py ===
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func
from sqlalchemy.dialects.postgresql import insert
from database.models.user import User
from database.models.giveaway import Giveaway

async def register_user(session: AsyncSession, user_id: int, username: str, full_name: str):
    stmt = insert(User).values(
        user_id=user_id, username=username, full_name=full_name
    ).on_conflict_do_update(
        index_elements=['user_id'],
        set_=dict(username=username, full_name=full_name)
    )
    await session.execute(stmt)
    await session.commit()

async def get_user_stats(session: AsyncSession, user_id: int) -> dict:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–æ–∑–¥–∞—Ç–µ–ª—è"""
    # –°—á–∏—Ç–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∏
    active_stmt = select(func.count(Giveaway.id)).where(Giveaway.owner_id == user_id, Giveaway.status == "active")
    active = await session.scalar(active_stmt)
    
    # –°—á–∏—Ç–∞–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ
    finished_stmt = select(func.count(Giveaway.id)).where(Giveaway.owner_id == user_id, Giveaway.status == "finished")
    finished = await session.scalar(finished_stmt)
    
    return {"active": active or 0, "finished": finished or 0}=== ./database/requests/giveaway_repo.py ===
from datetime import datetime
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, desc, func
from database.models.giveaway import Giveaway
from database.models.required_channel import GiveawayRequiredChannel

async def create_giveaway(
    session: AsyncSession, owner_id: int, channel_id: int, 
    message_id: int, prize: str, winners: int, end_time: datetime,
    media_file_id: str = None, media_type: str = None,
    sponsors: list = None,
    is_referral: bool = False,
    is_captcha: bool = False
) -> int:
    new_gw = Giveaway(
        owner_id=owner_id, channel_id=channel_id, message_id=message_id,
        prize_text=prize, winners_count=winners, finish_time=end_time,
        media_file_id=media_file_id, media_type=media_type,
        is_referral_enabled=is_referral,
        is_captcha_enabled=is_captcha
    )
    session.add(new_gw)
    await session.flush()

    if sponsors:
        for sp in sponsors:
            req_ch = GiveawayRequiredChannel(
                giveaway_id=new_gw.id,
                channel_id=sp['id'],
                channel_title=sp['title'],
                channel_link=sp['link']
            )
            session.add(req_ch)

    await session.commit()
    return new_gw.id

async def get_giveaway_by_id(session: AsyncSession, gw_id: int) -> Giveaway | None:
    return await session.get(Giveaway, gw_id)

async def get_active_giveaways(session: AsyncSession):
    stmt = select(Giveaway).where(Giveaway.status == "active")
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_required_channels(session: AsyncSession, gw_id: int):
    stmt = select(GiveawayRequiredChannel).where(GiveawayRequiredChannel.giveaway_id == gw_id)
    result = await session.execute(stmt)
    return result.scalars().all()

# --- –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø ---
async def get_giveaways_by_owner(session: AsyncSession, owner_id: int, limit: int = 50, offset: int = 0):
    """–ü–æ–ª—É—á–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π —Å–æ–∑–¥–∞—Ç–µ–ª—è —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π"""
    stmt = select(Giveaway).where(Giveaway.owner_id == owner_id)\
        .order_by(desc(Giveaway.id))\
        .limit(limit)\
        .offset(offset)  # <--- –î–æ–±–∞–≤–ª–µ–Ω–æ —Å–º–µ—â–µ–Ω–∏–µ
    result = await session.execute(stmt)
    return result.scalars().all()

async def set_predetermined_winner(session: AsyncSession, gw_id: int, winner_id: int):
    stmt = update(Giveaway).where(Giveaway.id == gw_id).values(predetermined_winner_id=winner_id)
    await session.execute(stmt)
    await session.commit()

async def count_giveaways_by_owner(session: AsyncSession, owner_id: int) -> int:
    stmt = select(func.count(Giveaway.id)).where(Giveaway.owner_id == owner_id)
    return await session.scalar(stmt)

async def count_giveaways_by_status(session: AsyncSession, owner_id: int, status: str) -> int:
    """–°—á–∏—Ç–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ —Å—Ç–∞—Ç—É—Å–∞ —É –≤–ª–∞–¥–µ–ª—å—Ü–∞"""
    stmt = select(func.count(Giveaway.id)).where(
        Giveaway.owner_id == owner_id,
        Giveaway.status == status
    )
    return await session.scalar(stmt)=== ./database/requests/channel_repo.py ===
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, delete
from sqlalchemy.dialects.postgresql import insert
from database.models.channel import Channel

async def add_channel(
    session: AsyncSession, 
    user_id: int, 
    channel_id: int, 
    title: str, 
    username: str | None, 
    invite_link: str | None
):
    """
    –î–æ–±–∞–≤–ª—è–µ—Ç –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –∫–∞–Ω–∞–ª —Å –∏–Ω–≤–∞–π—Ç-—Å—Å—ã–ª–∫–æ–π.
    """
    stmt = insert(Channel).values(
        user_id=user_id,
        channel_id=channel_id,
        title=title,
        username=username,
        invite_link=invite_link
    ).on_conflict_do_update(
        index_elements=['id'], 
        set_=dict(title=title, username=username, invite_link=invite_link)
    )
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏ (–∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ on_conflict –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –ë–î)
    existing = await session.scalar(select(Channel).where(Channel.channel_id == channel_id))
    if existing:
        existing.title = title
        existing.username = username
        existing.invite_link = invite_link
    else:
        session.add(Channel(
            user_id=user_id, 
            channel_id=channel_id, 
            title=title, 
            username=username, 
            invite_link=invite_link
        ))
    
    await session.commit()

async def get_user_channels(session: AsyncSession, user_id: int):
    stmt = select(Channel).where(Channel.user_id == user_id)
    result = await session.execute(stmt)
    return result.scalars().all()

async def delete_channel_by_id(session: AsyncSession, db_id: int, user_id: int):
    stmt = delete(Channel).where(Channel.id == db_id, Channel.user_id == user_id)
    await session.execute(stmt)
    await session.commit()=== ./database/requests/participant_repo.py ===
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, desc, delete
from sqlalchemy.dialects.postgresql import insert
from database.models.participant import Participant
from database.models.giveaway import Giveaway
from database.models.winner import Winner
from database.models.pending_referral import PendingReferral

# --- –†–∞–±–æ—Ç–∞ —Å —É—á–∞—Å—Ç–Ω–∏–∫–∞–º–∏ ---

async def add_participant(session: AsyncSession, user_id: int, giveaway_id: int, referrer_id: int = None, ticket_code: str = None) -> bool:
    stmt = insert(Participant).values(
        user_id=user_id, 
        giveaway_id=giveaway_id,
        referrer_id=referrer_id,
        ticket_code=ticket_code,
        tickets_count=1
    ).on_conflict_do_nothing()
    
    result = await session.execute(stmt)
    await session.commit()
    return result.rowcount > 0

async def increment_ticket(session: AsyncSession, user_id: int, giveaway_id: int):
    stmt = select(Participant).where(
        Participant.user_id == user_id, 
        Participant.giveaway_id == giveaway_id
    )
    participant = await session.scalar(stmt)
    if participant:
        participant.tickets_count += 1
        await session.commit()

async def is_circular_referral(session: AsyncSession, new_user_id: int, referrer_id: int, giveaway_id: int) -> bool:
    stmt = select(Participant).where(
        Participant.user_id == referrer_id,
        Participant.giveaway_id == giveaway_id,
        Participant.referrer_id == new_user_id
    )
    result = await session.scalar(stmt)
    return result is not None

async def is_participant_active(session: AsyncSession, user_id: int, giveaway_id: int) -> bool:
    stmt = select(Participant).where(
        Participant.user_id == user_id,
        Participant.giveaway_id == giveaway_id
    )
    result = await session.scalar(stmt)
    return result is not None

# --- –†–∞–±–æ—Ç–∞ —Å –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ —Ä–µ—Ñ–µ—Ä–∞–ª–∞–º–∏ (Pending) ---

async def add_pending_referral(session: AsyncSession, user_id: int, referrer_id: int, giveaway_id: int):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –≤—Ä–µ–º–µ–Ω–Ω—É—é —Å–≤—è–∑–∫—É –≤ –ë–î"""
    stmt = insert(PendingReferral).values(
        user_id=user_id,
        giveaway_id=giveaway_id,
        referrer_id=referrer_id
    ).on_conflict_do_update(
        index_elements=['user_id', 'giveaway_id'],
        set_=dict(referrer_id=referrer_id)
    )
    await session.execute(stmt)
    await session.commit()

async def get_pending_referral(session: AsyncSession, user_id: int, giveaway_id: int) -> int | None:
    """–ü–æ–ª—É—á–∞–µ—Ç –∏ –£–î–ê–õ–Ø–ï–¢ –≤—Ä–µ–º–µ–Ω–Ω—É—é —Å–≤—è–∑–∫—É (–æ–¥–Ω–æ—Ä–∞–∑–æ–≤–æ–µ —á—Ç–µ–Ω–∏–µ)"""
    stmt = select(PendingReferral.referrer_id).where(
        PendingReferral.user_id == user_id,
        PendingReferral.giveaway_id == giveaway_id
    )
    referrer_id = await session.scalar(stmt)
    
    if referrer_id:
        # –£–¥–∞–ª—è–µ–º, —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∞ –±–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–Ω–∞
        del_stmt = delete(PendingReferral).where(
            PendingReferral.user_id == user_id,
            PendingReferral.giveaway_id == giveaway_id
        )
        await session.execute(del_stmt)
        await session.commit()
        
    return referrer_id

# --- –°–ø–∏—Å–∫–∏ –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ ---

async def get_participant_ids(session: AsyncSession, giveaway_id: int) -> list[int]:
    stmt = select(Participant.user_id).where(Participant.giveaway_id == giveaway_id)
    result = await session.execute(stmt)
    return list(result.scalars().all())

async def get_participants_count(session: AsyncSession, giveaway_id: int) -> int:
    stmt = select(func.count(Participant.user_id)).where(Participant.giveaway_id == giveaway_id)
    return await session.scalar(stmt)

async def get_weighted_candidates(session: AsyncSession, giveaway_id: int, limit: int = 100) -> list[int]:
    random_weight = -func.ln(func.random()) / Participant.tickets_count
    stmt = select(Participant.user_id)\
        .where(Participant.giveaway_id == giveaway_id)\
        .order_by(random_weight)\
        .limit(limit)
    result = await session.execute(stmt)
    return list(result.scalars().all())

async def get_user_participations_detailed(session: AsyncSession, user_id: int, status: str = None, limit: int = 5, offset: int = 0):
    stmt = select(Giveaway).join(Participant).where(Participant.user_id == user_id)
    if status:
        stmt = stmt.where(Giveaway.status == status)
    stmt = stmt.order_by(desc(Giveaway.finish_time)).limit(limit).offset(offset)
    result = await session.execute(stmt)
    return result.scalars().all()

async def count_user_participations(session: AsyncSession, user_id: int, status: str = None) -> int:
    stmt = select(func.count(Giveaway.id)).join(Participant).where(Participant.user_id == user_id)
    if status:
        stmt = stmt.where(Giveaway.status == status)
    return await session.scalar(stmt)=== ./database/requests/__init__.py ===
=== ./database/__init__.py ===
# database/__init__.py
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from config import config
from .base import Base
# –ò–º–ø–æ—Ä—Ç –º–æ–¥–µ–ª–µ–π
from .models.user import User
from .models.giveaway import Giveaway
from .models.participant import Participant
from .models.channel import Channel
from .models.required_channel import GiveawayRequiredChannel
from .models.winner import Winner
from .models.pending_referral import PendingReferral # <--- –ù–û–í–û–ï

engine = create_async_engine(
    url=config.DB_DNS,
    echo=False,
    pool_pre_ping=True
)

async_session_maker = async_sessionmaker(
    engine, 
    class_=AsyncSession, 
    expire_on_commit=False
)=== ./database/base.py ===
from sqlalchemy.orm import DeclarativeBase

class Base(DeclarativeBase):
    pass=== ./handlers/creator/constructor/publication.py ===
from datetime import datetime
from aiogram import Router, types, F, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
import logging

from database.requests.giveaway_repo import create_giveaway
from keyboards.inline.participation import join_keyboard
from core.tools.scheduler import scheduler
from core.logic.game_actions import finish_giveaway_task
from core.tools.formatters import format_giveaway_caption
from core.tools.timezone import to_utc, strip_tz
from handlers.creator.constructor.message_manager import get_message_manager

logger = logging.getLogger(__name__)
router = Router()

@router.callback_query(F.data == "constr_publish")
async def publish_giveaway(call: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    
    # –í–∞–ª–∏–¥–∞—Ü–∏—è
    errors = []
    if not data.get('text'): errors.append("‚Ä¢ –ù–µ —É–∫–∞–∑–∞–Ω —Ç–µ–∫—Å—Ç")
    if not data.get('main_channel'): errors.append("‚Ä¢ –ù–µ –≤—ã–±—Ä–∞–Ω –∫–∞–Ω–∞–ª")
    if not data.get('winners') or not (1 <= data['winners'] <= 50): errors.append("‚Ä¢ –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∫–æ–ª-–≤–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π")
    
    if errors:
        return await call.answer("‚ùå –û—à–∏–±–∫–∏:\n" + "\n".join(errors), show_alert=True)
    
    main_ch = data['main_channel']
    
    try:
        finish_dt_msk = datetime.fromisoformat(data['finish_time_str'])
        finish_dt_utc = to_utc(finish_dt_msk)
        finish_dt_db = strip_tz(finish_dt_utc) 
    except ValueError:
        return await call.answer("‚ùå –û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ –≤—Ä–µ–º–µ–Ω–∏", show_alert=True)
    
    bot_info = await bot.get_me()
    caption = format_giveaway_caption(data['text'], data['winners'], finish_dt_utc, 0)
    keyboard = join_keyboard(bot_info.username, 0)
    
    # 1. –ü—É–±–ª–∏–∫–∞—Ü–∏—è –≤ –∫–∞–Ω–∞–ª
    try:
        if data['media_type'] == 'photo':
            msg = await bot.send_photo(main_ch['id'], data['media_file_id'], caption=caption, reply_markup=keyboard)
        elif data['media_type'] == 'video':
            msg = await bot.send_video(main_ch['id'], data['media_file_id'], caption=caption, reply_markup=keyboard)
        else:
            msg = await bot.send_message(main_ch['id'], text=caption, reply_markup=keyboard)
    except Exception as e:
        logger.error(f"Publish failed: {e}")
        return await call.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ (–±–æ—Ç –Ω–µ –∞–¥–º–∏–Ω?): {e}", show_alert=True)

    # 2. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –ë–î
    try:
        gw_id = await create_giveaway(
            session, call.from_user.id, main_ch['id'], msg.message_id, 
            data['text'], data['winners'], finish_dt_db,
            data['media_file_id'], data['media_type'], 
            data['sponsors'], 
            is_referral=(data['ref_req'] > 0), 
            is_captcha=data['is_captcha']
        )
    except Exception as e:
        logger.critical(f"DB Error: {e}")
        # –ü—ã—Ç–∞–µ–º—Å—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å—Ç, —Ä–∞–∑ –≤ –ë–î –Ω–µ –ø–æ–ø–∞–ª–æ
        try: await bot.delete_message(main_ch['id'], msg.message_id)
        except: pass
        return await call.answer("‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ë–î", show_alert=True)

    # 3. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ (–¥–æ–±–∞–≤–ª—è–µ–º ID —Ä–æ–∑—ã–≥—Ä—ã—à–∞)
    try:
        await bot.edit_message_reply_markup(
            chat_id=main_ch['id'], 
            message_id=msg.message_id, 
            reply_markup=join_keyboard(bot_info.username, gw_id)
        )
    except: pass
    
    # 4. –§–æ—Ä–≤–∞—Ä–¥ —Å–ø–æ–Ω—Å–æ—Ä–∞–º
    for sp in data['sponsors']:
        try:
            await bot.forward_message(chat_id=sp['id'], from_chat_id=main_ch['id'], message_id=msg.message_id)
        except: pass

    # 5. –ó–∞–ø—É—Å–∫ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞
    try:
        scheduler.add_job(
            finish_giveaway_task, "date", run_date=finish_dt_utc, 
            kwargs={"giveaway_id": gw_id}, id=f"gw_{gw_id}", replace_existing=True
        )
    except Exception as e:
        logger.error(f"Scheduler error: {e}")
    
    # 6. –§–∏–Ω–∞–ª—å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
    manager = await get_message_manager(state)
    await manager.delete_all(bot, call.message.chat.id)
    
    link = main_ch['link'] if main_ch['link'] != 'private' else "–∫–∞–Ω–∞–ª"
    
    # –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    warning_text = (
        "\n\n‚ö†Ô∏è <b>–í–∞–∂–Ω–æ:</b> –ï—Å–ª–∏ –≤—ã –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ—Ç–µ –ø–æ—Å—Ç –≤ –∫–∞–Ω–∞–ª–µ –≤—Ä—É—á–Ω—É—é (–∏–∑–º–µ–Ω–∏—Ç–µ —É—Å–ª–æ–≤–∏—è –∏–ª–∏ –ø—Ä–∏–∑), "
        "–±–æ—Ç –æ–± —ç—Ç–æ–º –Ω–µ —É–∑–Ω–∞–µ—Ç. –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –æ—Å—Ç–∞–Ω–µ—Ç—Å—è —Å—Ç–∞—Ä–æ–π. –ï—Å–ª–∏ –Ω—É–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å —Ç–µ–∫—Å—Ç —Ç–æ –¥–µ–ª–∞–π—Ç–µ —ç—Ç–æ –≤ –ª–∏—á–Ω–æ–º –∫–∞–±–∏–Ω–µ—Ç–µ"
    )

    await call.message.answer(
        f"‚úÖ <b>–û–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–æ!</b>\n<a href='{link}'>–ü–µ—Ä–µ–π—Ç–∏ –∫ –ø–æ—Å—Ç—É</a>\n\n"
        f"üèÜ –ü–æ–±–µ–¥–∏—Ç–µ–ª–µ–π: {data['winners']}"
        f"{warning_text}", 
        disable_web_page_preview=True
    )
    
    await state.clear()=== ./handlers/creator/constructor/referral_selector.py ===
from aiogram import Router, types, F, Bot
from aiogram.fsm.context import FSMContext
from keyboards.inline.constructor import referral_selector_kb
from handlers.creator.constructor.structure import ConstructorState
from handlers.creator.constructor.control_message import refresh_constructor_view
from handlers.creator.constructor.message_manager import get_message_manager, update_message_manager

router = Router()

@router.callback_query(F.data == "constr_ref_menu")
async def ref_menu(call: types.CallbackQuery, state: FSMContext, bot: Bot):
    await refresh_constructor_view(
        bot, state, call.message.chat.id, 
        hint_key='referral', 
        custom_keyboard=referral_selector_kb()
    )
    await call.answer()

@router.callback_query(F.data.startswith("constr_set_ref:"))
async def set_ref(call: types.CallbackQuery, state: FSMContext, bot: Bot):
    count = int(call.data.split(":")[-1])
    await state.update_data(ref_req=count)
    
    await refresh_constructor_view(bot, state, call.message.chat.id, hint_key='publish')
    text = "–í—ã–∫–ª" if count == 0 else f"{count} –¥—Ä—É–∑–µ–π"
    await call.answer(f"‚úÖ –†–µ—Ñ. —Å–∏—Å—Ç–µ–º–∞: {text}")

@router.callback_query(F.data == "constr_set_ref_input")
async def ask_ref_input(call: types.CallbackQuery, state: FSMContext, bot: Bot):
    await state.set_state(ConstructorState.editing_referral)
    
    manager = await get_message_manager(state)
    await manager.delete_all(bot, call.message.chat.id)
    
    msg = await call.message.answer("üîó <b>–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥—Ä—É–∑–µ–π</b> (0-10):")
    manager.add_temp_message(msg)
    await update_message_manager(state, manager)

@router.message(ConstructorState.editing_referral)
async def process_ref_input(message: types.Message, state: FSMContext, bot: Bot):
    try: await message.delete()
    except: pass
    
    manager = await get_message_manager(state)
    text = message.text.strip()
    
    if not text.isdigit() or not (0 <= int(text) <= 10):
        msg = await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ –æ—Ç 0 –¥–æ 10")
        manager.add_temp_message(msg)
        await update_message_manager(state, manager)
        return
        
    await state.update_data(ref_req=int(text))
    await state.set_state(ConstructorState.init)
    
    await refresh_constructor_view(bot, state, message.chat.id, hint_key='publish')=== ./handlers/creator/constructor/channels_add.py ===
from aiogram import Router, types, F, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
import logging

from database.requests.channel_repo import add_channel
from handlers.creator.constructor.structure import ConstructorState
from handlers.creator.constructor.channels_select import show_channels_selection
from handlers.creator.constructor.message_manager import get_message_manager, update_message_manager
from handlers.creator.constructor.control_message import refresh_constructor_view

logger = logging.getLogger(__name__)
router = Router()

@router.callback_query(F.data == "add_new_channel_constr")
async def ask_channel_constr(call: types.CallbackQuery, state: FSMContext, bot: Bot):
    await state.set_state(ConstructorState.adding_channel)
    
    # –£–¥–∞–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞, —á—Ç–æ–±—ã –Ω–µ –º–µ—à–∞–ª
    manager = await get_message_manager(state)
    await manager.delete_all(bot, call.message.chat.id)
    
    kb = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_to_selector")]])
    msg = await call.message.answer(
        "üì¢ <b>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–∞</b>\n\n"
        "1. –î–æ–±–∞–≤—å—Ç–µ –±–æ—Ç–∞ –≤ –∞–¥–º–∏–Ω—ã –∫–∞–Ω–∞–ª–∞.\n"
        "2. –ü–µ—Ä–µ—à–ª–∏—Ç–µ —Å—é–¥–∞ –ø–æ—Å—Ç –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ @username.", 
        reply_markup=kb
    )
    
    # –ó–∞–ø–æ–º–∏–Ω–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–∏–∞–ª–æ–≥–∞
    manager.add_temp_message(msg)
    await update_message_manager(state, manager)

@router.callback_query(F.data == "cancel_to_selector")
async def cancel_to_selector(call: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    # –û—á–∏—â–∞–µ–º –¥–∏–∞–ª–æ–≥
    manager = await get_message_manager(state)
    await manager.delete_all(bot, call.message.chat.id)
    
    await state.set_state(ConstructorState.init)
    
    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ –º–µ–Ω—é –≤—ã–±–æ—Ä–∞ –∫–∞–Ω–∞–ª–æ–≤
    data = await state.get_data()
    mode = data.get('channel_selector_mode', 'main')
    await show_channels_selection(bot, state, session, call.from_user.id, mode, call.message.chat.id)

@router.message(ConstructorState.adding_channel)
async def process_new_channel_step1_constr(message: types.Message, state: FSMContext, bot: Bot):
    # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —é–∑–µ—Ä–∞
    try: await message.delete()
    except: pass
    
    chat_id, title, username = None, "Title", None
    
    if message.forward_from_chat:
        chat_id = message.forward_from_chat.id
        title = message.forward_from_chat.title
        username = message.forward_from_chat.username
    elif message.text and message.text.startswith("@"):
        try:
            chat = await bot.get_chat(message.text)
            chat_id = chat.id
            title = chat.title
            username = chat.username
        except: 
            pass # –û–±—Ä–∞–±–æ—Ç–∞–µ–º –Ω–∏–∂–µ
    
    manager = await get_message_manager(state)
    
    if not chat_id:
        msg = await message.answer("‚ùå –ö–∞–Ω–∞–ª –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–µ—Ä–µ—à–ª–∏—Ç–µ –ø–æ—Å—Ç –∏–ª–∏ –ø—Ä–æ–≤–µ—Ä—å—Ç–µ @username.")
        manager.add_temp_message(msg)
        await update_message_manager(state, manager)
        return

    try:
        member = await bot.get_chat_member(chat_id, bot.id)
        if member.status not in ("administrator", "creator"): 
            raise Exception("Bot is not admin")
    except: 
        msg = await message.answer("‚ùå –ë–æ—Ç –Ω–µ –∞–¥–º–∏–Ω –≤ —ç—Ç–æ–º –∫–∞–Ω–∞–ª–µ!")
        manager.add_temp_message(msg)
        await update_message_manager(state, manager)
        return

    # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Å—ã–ª–∫–∏
    generated_link = None
    try:
        invite = await bot.create_chat_invite_link(chat_id, name="RozPlay Bot")
        generated_link = invite.invite_link
    except:
        generated_link = f"https://t.me/{username}" if username else None

    await state.update_data(
        temp_channel={"id": chat_id, "title": title, "username": username},
        generated_link=generated_link
    )
    await state.set_state(ConstructorState.adding_channel_link)
    
    # –£–¥–∞–ª—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–∏–∞–ª–æ–≥–∞
    await manager.delete_all(bot, message.chat.id)
    
    text = f"‚úÖ –ö–∞–Ω–∞–ª <b>{title}</b> –Ω–∞–π–¥–µ–Ω.\n"
    kb_builder = InlineKeyboardBuilder()
    if generated_link:
        text += f"\nüîó –°—Å—ã–ª–∫–∞: {generated_link}\n–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ—ë?"
        kb_builder.button(text="‚úÖ –î–∞", callback_data="use_generated_link")
    else:
        text += "\nüîó –ü—Ä–∏—à–ª–∏—Ç–µ –∏–Ω–≤–∞–π—Ç-—Å—Å—ã–ª–∫—É –≤—Ä—É—á–Ω—É—é:"
        
    kb_builder.button(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_to_selector")
    kb_builder.adjust(1)
    
    new_msg = await message.answer(text, reply_markup=kb_builder.as_markup())
    manager.add_temp_message(new_msg)
    await update_message_manager(state, manager)

@router.callback_query(ConstructorState.adding_channel_link, F.data == "use_generated_link")
async def use_gen_link_callback(call: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    ch_data = data['temp_channel']
    link = data.get('generated_link')
    
    await add_channel(session, call.from_user.id, ch_data['id'], ch_data['title'], ch_data['username'], link)
    
    # –û—á–∏—Å—Ç–∫–∞ –∏ –≤–æ–∑–≤—Ä–∞—Ç
    manager = await get_message_manager(state)
    await manager.delete_all(bot, call.message.chat.id)
    await state.set_state(ConstructorState.init)
    
    mode = data.get('channel_selector_mode', 'main')
    await show_channels_selection(bot, state, session, call.from_user.id, mode, call.message.chat.id)

@router.message(ConstructorState.adding_channel_link)
async def process_link_text_constr(message: types.Message, state: FSMContext, session: AsyncSession, bot: Bot):
    try: await message.delete()
    except: pass
    
    link = message.text.strip()
    manager = await get_message_manager(state)

    if "t.me" not in link and not link.startswith("https://"):
        msg = await message.answer("‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—Å—ã–ª–∫–∞.")
        manager.add_temp_message(msg)
        await update_message_manager(state, manager)
        return
    
    data = await state.get_data()
    ch_data = data.get('temp_channel')
    
    await add_channel(session, message.from_user.id, ch_data['id'], ch_data['title'], ch_data['username'], link)
    
    # –û—á–∏—Å—Ç–∫–∞ –∏ –≤–æ–∑–≤—Ä–∞—Ç
    await manager.delete_all(bot, message.chat.id)
    await state.set_state(ConstructorState.init)
    
    mode = data.get('channel_selector_mode', 'main')
    await show_channels_selection(bot, state, session, message.from_user.id, mode, message.chat.id)=== ./handlers/creator/constructor/start_content.py ===
from datetime import datetime, timedelta
from aiogram import Router, types, F, Bot
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
import logging

from core.security.sanitizer import sanitize_text, get_message_html
from keyboards.inline.dashboard import start_menu_kb
from core.tools.timezone import get_now_msk
from handlers.creator.constructor.structure import ConstructorState
from handlers.creator.constructor.control_message import get_control_hint, refresh_constructor_view
from handlers.creator.constructor.message_manager import get_message_manager, update_message_manager

logger = logging.getLogger(__name__)
router = Router()

@router.callback_query(F.data == "create_gw_init")
@router.message(Command("new"))
async def start_constructor(event: types.Message | types.CallbackQuery, state: FSMContext):
    # –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä–æ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
    manager = await get_message_manager(state)
    if isinstance(event, types.CallbackQuery):
        await manager.delete_all(event.bot, event.message.chat.id)
    await state.clear()
    
    # –î–µ—Ñ–æ–ª—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    default_finish = get_now_msk() + timedelta(hours=24)
    await state.set_data({
        "text": None, "media_file_id": None, "media_type": None,
        "main_channel": None, "sponsors": [],
        "finish_time_str": default_finish.isoformat(),
        "winners": 1, "ref_req": 0, "is_captcha": False,
        "message_manager_data": {}
    })
    await state.set_state(ConstructorState.editing_content)
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é "–®–∞–≥ 1"
    hint_text = await get_control_hint('content')
    kb = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_creation")]])
    
    if isinstance(event, types.CallbackQuery):
        msg = await event.message.answer(hint_text, reply_markup=kb)
        try: await event.message.delete()
        except: pass
    else:
        msg = await event.answer(hint_text, reply_markup=kb)
    
    manager = await get_message_manager(state)
    manager.set_instruction_message(msg)
    await update_message_manager(state, manager)

@router.callback_query(F.data == "cancel_creation")
async def cancel_creation(call: types.CallbackQuery, state: FSMContext, bot: Bot):
    manager = await get_message_manager(state)
    await manager.delete_all(bot, call.message.chat.id)
    await state.clear()
    await call.message.answer("‚ùå –°–æ–∑–¥–∞–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=start_menu_kb())

@router.message(ConstructorState.editing_content)
async def receive_content(message: types.Message, state: FSMContext, bot: Bot):
    # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    try: await message.delete()
    except: pass

    manager = await get_message_manager(state)

    # 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ç–∏–ø—ã –∫–æ–Ω—Ç–µ–Ω—Ç–∞
    media_id, media_type = None, None
    
    if message.photo:
        media_id, media_type = message.photo[-1].file_id, "photo"
    elif message.video:
        media_id, media_type = message.video.file_id, "video"
    elif message.animation:
        media_id, media_type = message.animation.file_id, "animation"
    elif message.document or message.voice or message.audio or message.sticker or message.video_note:
        # –ï—Å–ª–∏ –ø—Ä–∏—Å–ª–∞–ª–∏ —Ñ–∞–π–ª, –≥–æ–ª–æ—Å–æ–≤–æ–µ, —Å—Ç–∏–∫–µ—Ä –∏–ª–∏ –∫—Ä—É–∂–æ—á–µ–∫ - —Ä—É–≥–∞–µ–º—Å—è
        err_msg = await message.answer(
            "‚ùå <b>–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç!</b>\n\n"
            "–ë–æ—Ç –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Ç–æ–ª—å–∫–æ:\n"
            "‚Ä¢ –û–±—ã—á–Ω—ã–π —Ç–µ–∫—Å—Ç\n"
            "‚Ä¢ –§–æ—Ç–æ\n"
            "‚Ä¢ –í–∏–¥–µ–æ\n"
            "‚Ä¢ GIF (–ê–Ω–∏–º–∞—Ü–∏—è)\n\n"
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–∏—à–ª–∏—Ç–µ –ø–æ—Å—Ç –≤ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–æ–º —Ñ–æ—Ä–º–∞—Ç–µ."
        )
        manager.add_temp_message(err_msg)
        await update_message_manager(state, manager)
        return

    # 2. –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç (HTML)
    html_content = get_message_html(message)
    safe_text = sanitize_text(html_content)
    
    # 3. –ñ–ï–°–¢–ö–ê–Ø –ø—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–æ–≤ Telegram
    # –ï—Å–ª–∏ –µ—Å—Ç—å –º–µ–¥–∏–∞ -> –ª–∏–º–∏—Ç 1024. –ï—Å–ª–∏ –Ω–µ—Ç -> 4096.
    limit = 1024 if media_type else 4096
    
    if len(safe_text) > limit:
        if media_type:
            text_err = (
                f"‚ùå <b>–°–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –º–µ–¥–∏–∞!</b>\n\n"
                f"Telegram –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ—Ç –ø–æ–¥–ø–∏—Å—å –∫ —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ –¥–æ <b>1024 —Å–∏–º–≤–æ–ª–æ–≤</b>.\n"
                f"–£ –≤–∞—Å: {len(safe_text)} —Å–∏–º–≤–æ–ª–æ–≤.\n\n"
                f"üìâ <b>–ß—Ç–æ –¥–µ–ª–∞—Ç—å:</b>\n"
                f"1. –°–æ–∫—Ä–∞—Ç–∏—Ç–µ —Ç–µ–∫—Å—Ç.\n"
                f"2. –ò–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –ë–ï–ó –∫–∞—Ä—Ç–∏–Ω–∫–∏ (—Ç–æ–≥–¥–∞ –ª–∏–º–∏—Ç 4096)."
            )
        else:
            text_err = (
                f"‚ùå <b>–¢–µ–∫—Å—Ç —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π!</b>\n\n"
                f"–õ–∏–º–∏—Ç Telegram: <b>4096 —Å–∏–º–≤–æ–ª–æ–≤</b>.\n"
                f"–£ –≤–∞—Å: {len(safe_text)}."
            )
            
        err_msg = await message.answer(text_err)
        manager.add_temp_message(err_msg)
        await update_message_manager(state, manager)
        return

    # 4. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—É—Å—Ç–æ—Ç—É (–µ—Å–ª–∏ –ø—Ä–∏—Å–ª–∞–ª–∏ —Ç–æ–ª—å–∫–æ –∫–∞—Ä—Ç–∏–Ω–∫—É –±–µ–∑ —Ç–µ–∫—Å—Ç–∞, –∏–ª–∏ —Ç–µ–∫—Å—Ç –ø—É—Å—Ç–æ–π)
    # –•–æ—Ç—è –ø—É—Å—Ç–∞—è –∫–∞—Ä—Ç–∏–Ω–∫–∞ –¥–æ–ø—É—Å—Ç–∏–º–∞, –Ω–æ –¥–ª—è —Ä–æ–∑—ã–≥—Ä—ã—à–∞ –Ω—É–∂–µ–Ω —Ç–µ–∫—Å—Ç —É—Å–ª–æ–≤–∏–π.
    if not safe_text and not media_type:
        err_msg = await message.answer("‚ùå –°–æ–æ–±—â–µ–Ω–∏–µ –ø—É—Å—Ç–æ–µ. –ù–∞–ø–∏—à–∏—Ç–µ —Ç–µ–∫—Å—Ç —É—Å–ª–æ–≤–∏–π —Ä–æ–∑—ã–≥—Ä—ã—à–∞.")
        manager.add_temp_message(err_msg)
        await update_message_manager(state, manager)
        return
        
    if not safe_text and media_type:
        # –ï—Å–ª–∏ –ø—Ä–∏—Å–ª–∞–ª–∏ –ø—Ä–æ—Å—Ç–æ –∫–∞—Ä—Ç–∏–Ω–∫—É –±–µ–∑ –æ–ø–∏—Å–∞–Ω–∏—è
        err_msg = await message.answer("‚ö†Ô∏è <b>–î–æ–±–∞–≤—å—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ!</b>\n\n–ü—Ä–∏—à–ª–∏—Ç–µ —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ —Å—Ä–∞–∑—É —Å —Ç–µ–∫—Å—Ç–æ–º (–≤ –ø–æ–¥–ø–∏—Å–∏), —á—Ç–æ–±—ã —É—á–∞—Å—Ç–Ω–∏–∫–∏ –∑–Ω–∞–ª–∏ —É—Å–ª–æ–≤–∏—è.")
        manager.add_temp_message(err_msg)
        await update_message_manager(state, manager)
        return
    
    # 5. –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ
    await state.update_data(text=safe_text, media_file_id=media_id, media_type=media_type)
    await state.set_state(ConstructorState.init)
    
    # 6. –ü–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∞ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
    await refresh_constructor_view(bot, state, message.chat.id, hint_key='main_channel')=== ./handlers/creator/constructor/structure.py ===
from aiogram.fsm.state import State, StatesGroup
from aiogram import types
from aiogram.exceptions import TelegramBadRequest

class ConstructorState(StatesGroup):
    init = State()
    editing_content = State()
    confirm_short_text = State() 
    adding_channel = State()
    adding_channel_link = State()
    editing_winners = State()  # –ù–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤–≤–æ–¥–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π –≤—Ä—É—á–Ω—É—é
    editing_referral = State() # –ù–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤–≤–æ–¥–∞ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤ –≤—Ä—É—á–Ω—É—é

async def safe_edit_to_text(message: types.Message, text: str, reply_markup=None):
    """
    –ë–µ–∑–æ–ø–∞—Å–Ω–æ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ä–µ–∂–∏–º.
    """
    try:
        if message.photo or message.video or message.animation or message.document:
            await message.delete()
            await message.answer(text, reply_markup=reply_markup)
        else:
            await message.edit_text(text, reply_markup=reply_markup)
    except TelegramBadRequest:
        try: await message.edit_text(text, reply_markup=reply_markup)
        except: pass
    except Exception:
        await message.answer(text, reply_markup=reply_markup)=== ./handlers/creator/constructor/message_manager.py ===
from aiogram import types, Bot
from aiogram.fsm.context import FSMContext
from typing import List, Optional
import logging

logger = logging.getLogger(__name__)

class MessageManager:
    """–ö–ª–∞—Å—Å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏ –≤ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–µ"""
    
    def __init__(self):
        self.preview_message_id = None      # ID —Å–æ–æ–±—â–µ–Ω–∏—è –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞ (–ø–æ—Å—Ç)
        self.control_message_id = None      # ID —Å–æ–æ–±—â–µ–Ω–∏—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è (–∫–Ω–æ–ø–∫–∏)
        self.instruction_message_id = None  # ID —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–µ–π (–®–∞–≥ 1)
        self.temp_messages = []             # –í—Ä–µ–º–µ–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è (–æ—à–∏–±–∫–∏, –¥–∏–∞–ª–æ–≥–∏ –≤–≤–æ–¥–∞)
    
    def set_preview_message(self, message: types.Message):
        if message:
            self.preview_message_id = message.message_id
    
    def set_control_message(self, message: types.Message):
        if message:
            self.control_message_id = message.message_id
        
    def set_instruction_message(self, message: types.Message):
        if message:
            self.instruction_message_id = message.message_id

    def add_temp_message(self, message: types.Message):
        if message:
            self.temp_messages.append(message.message_id)
    
    async def delete_all(self, bot: Bot, chat_id: int):
        """–£–¥–∞–ª—è–µ—Ç –í–°–ï —Å–æ–æ–±—â–µ–Ω–∏—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞"""
        ids_to_delete = []
        
        if self.preview_message_id: ids_to_delete.append(self.preview_message_id)
        if self.control_message_id: ids_to_delete.append(self.control_message_id)
        if self.instruction_message_id: ids_to_delete.append(self.instruction_message_id)
        ids_to_delete.extend(self.temp_messages)
        
        # –£–¥–∞–ª—è–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ ID, —á—Ç–æ–±—ã –Ω–µ —Å–ø–∞–º–∏—Ç—å –∑–∞–ø—Ä–æ—Å–∞–º–∏
        for msg_id in set(ids_to_delete):
            try:
                await bot.delete_message(chat_id, msg_id)
            except Exception:
                # –°–æ–æ–±—â–µ–Ω–∏–µ —É–∂–µ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ —Å–ª–∏—à–∫–æ–º —Å—Ç–∞—Ä–æ–µ
                pass
        
        # –û—á–∏—â–∞–µ–º –ø–∞–º—è—Ç—å
        self.clear()

    def clear(self):
        self.preview_message_id = None
        self.control_message_id = None
        self.instruction_message_id = None
        self.temp_messages = []
    
    def to_dict(self) -> dict:
        return {
            'preview_message_id': self.preview_message_id,
            'control_message_id': self.control_message_id,
            'instruction_message_id': self.instruction_message_id,
            'temp_messages': self.temp_messages
        }
    
    @classmethod
    def from_dict(cls, data: dict):
        manager = cls()
        manager.preview_message_id = data.get('preview_message_id')
        manager.control_message_id = data.get('control_message_id')
        manager.instruction_message_id = data.get('instruction_message_id')
        manager.temp_messages = data.get('temp_messages', [])
        return manager

async def get_message_manager(state: FSMContext) -> MessageManager:
    data = await state.get_data()
    if 'message_manager_data' not in data:
        manager = MessageManager()
        await state.update_data(message_manager_data=manager.to_dict())
        return manager
    return MessageManager.from_dict(data['message_manager_data'])

async def update_message_manager(state: FSMContext, manager: MessageManager):
    await state.update_data(message_manager_data=manager.to_dict())=== ./handlers/creator/constructor/settings.py ===
from aiogram import Router, types, F, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
from database.models.user import User
from handlers.creator.constructor.structure import ConstructorState
from handlers.creator.constructor.control_message import get_control_hint, refresh_constructor_view
from handlers.creator.constructor.message_manager import get_message_manager, update_message_manager
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

router = Router()

@router.callback_query(F.data == "constr_edit_content")
async def ask_new_content(call: types.CallbackQuery, state: FSMContext, bot: Bot):
    await state.set_state(ConstructorState.editing_content)
    
    # –£–¥–∞–ª—è–µ–º —Ç–µ–∫—É—â–∏–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å (–ø—Ä–µ–≤—å—é –∏ –∫–Ω–æ–ø–∫–∏)
    manager = await get_message_manager(state)
    await manager.delete_all(bot, call.message.chat.id)
    
    # –®–ª–µ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –∫ –≤–≤–æ–¥—É "–®–∞–≥ 1"
    hint_text = await get_control_hint('content')
    kb = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="constr_back_main")]])
    msg = await call.message.answer(hint_text, reply_markup=kb)
    
    # –ó–∞–ø–æ–º–∏–Ω–∞–µ–º –∫–∞–∫ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é
    manager.set_instruction_message(msg)
    await update_message_manager(state, manager)

@router.callback_query(F.data.startswith("constr_set_winners:"))
async def set_winners(call: types.CallbackQuery, state: FSMContext, bot: Bot):
    count = int(call.data.split(":")[-1])
    await state.update_data(winners=count)
    # –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º
    await refresh_constructor_view(bot, state, call.message.chat.id, hint_key='publish')
    await call.answer(f"‚úÖ –ü–æ–±–µ–¥–∏—Ç–µ–ª–µ–π: {count}")

@router.callback_query(F.data.startswith("constr_set_ref:"))
async def set_ref(call: types.CallbackQuery, state: FSMContext, bot: Bot):
    count = int(call.data.split(":")[-1])
    await state.update_data(ref_req=count)
    # –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º
    await refresh_constructor_view(bot, state, call.message.chat.id, hint_key='publish')
    await call.answer(f"‚úÖ –†–µ—Ñ–µ—Ä–∞–ª–æ–≤: {count}")

@router.callback_query(F.data == "constr_toggle_cap")
async def toggle_cap(call: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    
    if not data['is_captcha']:
        user = await session.get(User, call.from_user.id)
        if not user or not user.is_premium:
            return await call.answer("üîí –§—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ —Å Premium!", show_alert=True)
            
    await state.update_data(is_captcha=not data['is_captcha'])
    # –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º
    await refresh_constructor_view(bot, state, call.message.chat.id, hint_key='publish')
    await call.answer("‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∞")

@router.callback_query(F.data == "constr_back_main")
async def back_to_main(call: types.CallbackQuery, state: FSMContext, bot: Bot):
    await state.set_state(ConstructorState.init)
    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
    await refresh_constructor_view(bot, state, call.message.chat.id, hint_key='default')=== ./handlers/creator/constructor/winners_selector.py ===
from aiogram import Router, types, F, Bot
from aiogram.fsm.context import FSMContext
from keyboards.inline.constructor import winners_selector_kb
from handlers.creator.constructor.structure import ConstructorState
from handlers.creator.constructor.control_message import refresh_constructor_view
from handlers.creator.constructor.message_manager import get_message_manager, update_message_manager

router = Router()

@router.callback_query(F.data == "constr_winners_menu")
async def winners_menu(call: types.CallbackQuery, state: FSMContext, bot: Bot):
    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é –≤—ã–±–æ—Ä–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π (–ü—Ä–µ–≤—å—é + –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π)
    await refresh_constructor_view(
        bot, state, call.message.chat.id, 
        hint_key='winners', 
        custom_keyboard=winners_selector_kb()
    )
    await call.answer()

@router.callback_query(F.data.startswith("constr_set_winners:"))
async def set_winners(call: types.CallbackQuery, state: FSMContext, bot: Bot):
    winners_count = int(call.data.split(":")[-1])
    await state.update_data(winners=winners_count)
    
    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é (hint_key='publish' –∏–ª–∏ 'default')
    await refresh_constructor_view(bot, state, call.message.chat.id, hint_key='publish')
    await call.answer(f"‚úÖ –ü–æ–±–µ–¥–∏—Ç–µ–ª–µ–π: {winners_count}")

@router.callback_query(F.data == "constr_set_winners_input")
async def ask_winners_input(call: types.CallbackQuery, state: FSMContext, bot: Bot):
    await state.set_state(ConstructorState.editing_winners)
    
    # –£–¥–∞–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
    manager = await get_message_manager(state)
    await manager.delete_all(bot, call.message.chat.id)
    
    msg = await call.message.answer("üî¢ <b>–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π</b> (1-50):")
    manager.add_temp_message(msg)
    await update_message_manager(state, manager)

@router.message(ConstructorState.editing_winners)
async def process_winners_input(message: types.Message, state: FSMContext, bot: Bot):
    try: await message.delete()
    except: pass
    
    manager = await get_message_manager(state)
    text = message.text.strip()
    
    if not text.isdigit() or not (1 <= int(text) <= 50):
        msg = await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 50")
        manager.add_temp_message(msg)
        await update_message_manager(state, manager)
        return
        
    await state.update_data(winners=int(text))
    await state.set_state(ConstructorState.init)
    
    # –í–æ–∑–≤—Ä–∞—Ç –≤ –º–µ–Ω—é
    await refresh_constructor_view(bot, state, message.chat.id, hint_key='publish')=== ./handlers/creator/constructor/__init__.py ===
from aiogram import Router
from . import start_content, settings, channels_select, channels_add, publication, winners_selector, referral_selector

router = Router()

router.include_router(start_content.router)
router.include_router(settings.router)
router.include_router(channels_select.router)
router.include_router(channels_add.router)
router.include_router(publication.router)
router.include_router(winners_selector.router)
router.include_router(referral_selector.router)=== ./handlers/creator/constructor/control_message.py ===
from datetime import datetime
from aiogram import Router, types, Bot
from aiogram.types import InlineKeyboardMarkup
from aiogram.fsm.context import FSMContext
from keyboards.inline.constructor import constructor_main_kb
from handlers.creator.constructor.message_manager import get_message_manager, update_message_manager
import logging

logger = logging.getLogger(__name__)

# –¢–µ–∫—Å—Ç—ã –ø–æ–¥—Å–∫–∞–∑–æ–∫ (–í–æ–∑–≤—Ä–∞—â–µ–Ω—ã –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ, –ø–æ–¥—Ä–æ–±–Ω—ã–µ –≤–µ—Ä—Å–∏–∏)
CONTROL_HINTS = {
    'main_channel': (
        "üì¢ <b>–®–∞–≥ 2: –í—ã–±–æ—Ä –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞</b>\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–Ω–∞–ª, –≥–¥–µ –±—É–¥–µ—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω —Ä–æ–∑—ã–≥—Ä—ã—à.\n\n"
        "‚ö†Ô∏è <b>–í–∞–∂–Ω–æ:</b>\n"
        "‚Ä¢ –ë–æ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º\n"
        "‚Ä¢ –≠—Ç–æ –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª –¥–ª—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤\n"
        "‚Ä¢ –ò–∑ –Ω–µ–≥–æ –±—É–¥—É—Ç —Ä–µ–ø–æ—Å—Ç–∏—Ç—å—Å—è —Å–ø–æ–Ω—Å–æ—Ä—ã\n\n"
        "–ù–∞–∂–º–∏—Ç–µ <b>–ö–∞–Ω–∞–ª—ã</b> –¥–ª—è –≤—ã–±–æ—Ä–∞."
    ),
    
    'sponsors': (
        "ü§ù <b>–®–∞–≥ 3: –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–ø–æ–Ω—Å–æ—Ä–æ–≤</b>\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–Ω–∞–ª—ã, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è —É—á–∞—Å—Ç–Ω–∏–∫–∞–º.\n\n"
        "‚úÖ <b>–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:</b>\n"
        "‚Ä¢ –£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –æ—Ö–≤–∞—Ç\n"
        "‚Ä¢ –ü–æ–≤—ã—à–∞–µ—Ç –∏–Ω—Ç–µ—Ä–µ—Å –∫ —Ä–æ–∑—ã–≥—Ä—ã—à—É\n"
        "‚Ä¢ –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥–æ 20 –∫–∞–Ω–∞–ª–æ–≤\n\n"
        "–ù–∞–∂–º–∏—Ç–µ <b>–°–ø–æ–Ω—Å–æ—Ä—ã</b> –¥–ª—è –≤—ã–±–æ—Ä–∞."
    ),
    
    'time': (
        "‚è≥ <b>–®–∞–≥ 4: –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è</b>\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ, —á–µ—Ä–µ–∑ —Å–∫–æ–ª—å–∫–æ —á–∞—Å–æ–≤ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è —Ä–æ–∑—ã–≥—Ä—ã—à.\n\n"
        "üìÖ <b>–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:</b>\n"
        "‚Ä¢ –ú–∏–Ω–∏–º—É–º: 1 —á–∞—Å\n"
        "‚Ä¢ –û–ø—Ç–∏–º–∞–ª—å–Ω–æ: 24-72 —á–∞—Å–∞\n"
        "‚Ä¢ –ú–∞–∫—Å–∏–º—É–º: 30 –¥–Ω–µ–π\n\n"
        "–ù–∞–∂–º–∏—Ç–µ <b>–ò—Ç–æ–≥–∏</b> –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏."
    ),
    
    'winners': (
        "üèÜ <b>–®–∞–≥ 5: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π</b>\n\n"
        "–£–∫–∞–∂–∏—Ç–µ, —Å–∫–æ–ª—å–∫–æ —á–µ–ª–æ–≤–µ–∫ –ø–æ–ª—É—á–∞—Ç –ø—Ä–∏–∑.\n\n"
        "üí° <b>–°–æ–≤–µ—Ç—ã:</b>\n"
        "‚Ä¢ 1-3 –ø–æ–±–µ–¥–∏—Ç–µ–ª—è - –¥–ª—è –Ω–µ–±–æ–ª—å—à–∏—Ö –ø—Ä–∏–∑–æ–≤\n"
        "‚Ä¢ 5-10 –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π - –¥–ª—è —Å—Ä–µ–¥–Ω–∏—Ö –ø—Ä–∏–∑–æ–≤\n"
        "‚Ä¢ 20+ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π - –¥–ª—è –∫—Ä—É–ø–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π\n\n"
        "–ù–∞–∂–º–∏—Ç–µ <b>–ü–æ–±–µ–¥–∏—Ç–µ–ª–∏</b> –¥–ª—è –≤—ã–±–æ—Ä–∞."
    ),
    
    'referral': (
        "üîó <b>–®–∞–≥ 6: –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞</b>\n\n"
        "–ù–∞—Å—Ç—Ä–æ–π—Ç–µ –±–æ–Ω—É—Å—ã –∑–∞ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –¥—Ä—É–∑–µ–π.\n\n"
        "üéÅ <b>–ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç:</b>\n"
        "‚Ä¢ –ó–∞ –∫–∞–∂–¥–æ–≥–æ –¥—Ä—É–≥–∞ +1 –±–∏–ª–µ—Ç\n"
        "‚Ä¢ –ú–æ–∂–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ª–∏–º–∏—Ç (1-10 –¥—Ä—É–∑–µ–π)\n"
        "‚Ä¢ –ü–æ–≤—ã—à–∞–µ—Ç –≤–æ–≤–ª–µ—á–µ–Ω–Ω–æ—Å—Ç—å\n\n"
        "–ù–∞–∂–º–∏—Ç–µ <b>–†–µ—Ñ</b> –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏."
    ),
    
    'captcha': (
        "üõ° <b>–®–∞–≥ 7: –ó–∞—â–∏—Ç–∞ –æ—Ç –±–æ—Ç–æ–≤</b>\n\n"
        "–í–∫–ª—é—á–∏—Ç–µ –∫–∞–ø—á—É –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç –Ω–∞–∫—Ä—É—Ç–∫–∏.\n\n"
        "üîí <b>–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:</b>\n"
        "‚Ä¢ –û—Ç—Å–µ–∏–≤–∞–µ—Ç 99% –±–æ—Ç–æ–≤\n"
        "‚Ä¢ –¢–æ–ª—å–∫–æ Premium –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏\n"
        "‚Ä¢ –ü–æ–≤—ã—à–∞–µ—Ç –∫–∞—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤\n\n"
        "–ù–∞–∂–º–∏—Ç–µ <b>–ö–∞–ø—á–∞</b> –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è."
    ),
    
    'content': (
        "‚úèÔ∏è <b>–®–∞–≥ 1: –¢–µ–∫—Å—Ç –∏ –º–µ–¥–∏–∞</b>\n\n"
        "–ò–∑–º–µ–Ω–∏—Ç–µ —Ç–µ–∫—Å—Ç –æ–ø–∏—Å–∞–Ω–∏—è –∏–ª–∏ –¥–æ–±–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ.\n\n"
        "üìù <b>–°–æ–≤–µ—Ç—ã:</b>\n"
        "‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ (–∂–∏—Ä–Ω—ã–π, –∫—É—Ä—Å–∏–≤)\n"
        "‚Ä¢ –î–æ–±–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –¥–ª—è –ª—É—á—à–µ–≥–æ –≤–æ—Å–ø—Ä–∏—è—Ç–∏—è\n"
        "‚Ä¢ –£–∫–∞–∂–∏—Ç–µ —É—Å–ª–æ–≤–∏—è —É—á–∞—Å—Ç–∏—è\n\n"
        "–ù–∞–∂–º–∏—Ç–µ <b>–ò–∑–º–µ–Ω–∏—Ç—å –¢–µ–∫—Å—Ç/–ú–µ–¥–∏–∞</b> –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
    ),
    
    'publish': (
        "‚úÖ <b>–ì–æ—Ç–æ–≤–æ –∫ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏!</b>\n\n"
        "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã:\n"
        "‚Ä¢ –¢–µ–∫—Å—Ç —Ä–æ–∑—ã–≥—Ä—ã—à–∞\n"
        "‚Ä¢ –ö–∞–Ω–∞–ª –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏\n"
        "‚Ä¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π\n"
        "‚Ä¢ –í—Ä–µ–º—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è\n\n"
        "üéØ <b>–í–∞–∂–Ω–æ:</b>\n"
        "‚Ä¢ –ü–æ—Å–ª–µ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è –Ω–µ–≤–æ–∑–º–æ–∂–Ω—ã\n"
        "‚Ä¢ –†–æ–∑—ã–≥—Ä—ã—à –Ω–∞—á–Ω–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏\n"
        "‚Ä¢ –ü–æ–±–µ–¥–∏—Ç–µ–ª–∏ –æ–ø—Ä–µ–¥–µ–ª—è—Ç—Å—è –ø–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏\n\n"
        "–ù–∞–∂–º–∏—Ç–µ <b>–û–ü–£–ë–õ–ò–ö–û–í–ê–¢–¨</b> –¥–ª—è –∑–∞–ø—É—Å–∫–∞."
    ),
    
    'default': (
        "üéØ <b>–ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π</b>\n\n"
        "–ù–∞—Å—Ç—Ä–æ–π—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ä–æ–∑—ã–≥—Ä—ã—à–∞:\n\n"
        "1Ô∏è‚É£ <b>–ö–∞–Ω–∞–ª:</b> –ì–¥–µ –æ–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å\n"
        "2Ô∏è‚É£ <b>–°–ø–æ–Ω—Å–æ—Ä—ã:</b> –ù–∞ —á—Ç–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è\n"
        "3Ô∏è‚É£ <b>–ò—Ç–æ–≥–∏:</b> –ö–æ–≥–¥–∞ –∑–∞–≤–µ—Ä—à–∏—Ç—å\n"
        "4Ô∏è‚É£ <b>–ü–æ–±–µ–¥–∏—Ç–µ–ª–∏:</b> –°–∫–æ–ª—å–∫–æ —á–µ–ª–æ–≤–µ–∫\n"
        "5Ô∏è‚É£ <b>–†–µ—Ñ:</b> –ó–∞ –¥—Ä—É–∑–µ–π –±–æ–Ω—É—Å\n"
        "6Ô∏è‚É£ <b>–ö–∞–ø—á–∞:</b> –ó–∞—â–∏—Ç–∞ –æ—Ç –±–æ—Ç–æ–≤\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏!"
    )
}

async def get_control_hint(key: str) -> str:
    return CONTROL_HINTS.get(key, CONTROL_HINTS['default'])

async def refresh_constructor_view(
    bot: Bot, 
    state: FSMContext, 
    chat_id: int, 
    hint_key: str = 'default',
    custom_keyboard: InlineKeyboardMarkup = None
):
    """
    –ü–æ–ª–Ω–æ—Å—Ç—å—é –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ—Ç –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å:
    1. –£–¥–∞–ª—è–µ—Ç —Å—Ç–∞—Ä—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è (–ü—Ä–µ–≤—å—é –∏ –ö–æ–Ω—Ç—Ä–æ–ª—å).
    2. –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –Ω–æ–≤–æ–µ –ü—Ä–µ–≤—å—é (–ø–æ—Å—Ç).
    3. –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –Ω–æ–≤—ã–π –ö–æ–Ω—Ç—Ä–æ–ª—å (–∫–Ω–æ–ø–∫–∏ —Å –ø–æ–¥—Ä–æ–±–Ω–æ–π –ø–æ–¥—Å–∫–∞–∑–∫–æ–π).
    """
    manager = await get_message_manager(state)
    
    # 1. –£–¥–∞–ª—è–µ–º –í–°–Å —Å—Ç–∞—Ä–æ–µ
    await manager.delete_all(bot, chat_id)
    
    data = await state.get_data()
    
    # 2. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ü–†–ï–í–¨–Æ (–ü–æ—Å—Ç)
    try:
        finish_dt = datetime.fromisoformat(data['finish_time_str'])
        date_str = finish_dt.strftime('%d.%m %H:%M –ú–°–ö')
    except:
        date_str = "..."
        
    caption = f"{data['text']}\n\n<i>(–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä. –ò—Ç–æ–≥–∏: {date_str})</i>"
    
    try:
        if data['media_type'] == 'photo': 
            preview_msg = await bot.send_photo(chat_id, data['media_file_id'], caption=caption)
        elif data['media_type'] == 'video': 
            preview_msg = await bot.send_video(chat_id, data['media_file_id'], caption=caption)
        elif data['media_type'] == 'animation': 
            preview_msg = await bot.send_animation(chat_id, data['media_file_id'], caption=caption)
        else: 
            preview_msg = await bot.send_message(chat_id, text=caption, disable_web_page_preview=True)
            
        manager.set_preview_message(preview_msg)
    except Exception as e:
        logger.error(f"Failed to send preview: {e}")
        # –ï—Å–ª–∏ –º–µ–¥–∏–∞ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ –æ—à–∏–±–∫–∞, —à–ª–µ–º —Ç–µ–∫—Å—Ç
        preview_msg = await bot.send_message(chat_id, text=f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –º–µ–¥–∏–∞ (—Ñ–∞–π–ª —É—Å—Ç–∞—Ä–µ–ª).\n\n{caption}")
        manager.set_preview_message(preview_msg)

    # 3. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ö–û–ù–¢–†–û–õ–¨ (–ö–Ω–æ–ø–∫–∏ + –ü–æ–¥—Ä–æ–±–Ω–∞—è –ø–æ–¥—Å–∫–∞–∑–∫–∞)
    hint_text = await get_control_hint(hint_key)
    
    if custom_keyboard:
        # –ï—Å–ª–∏ –º—ã –≤ –ø–æ–¥–º–µ–Ω—é, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–µ–¥–∞–Ω–Ω—É—é –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
        kb = custom_keyboard
    else:
        # –ò–Ω–∞—á–µ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
        winners = data.get('winners', 1)
        ref_req = data.get('ref_req', 0)
        is_cap = data.get('is_captcha', False)
        has_main = bool(data.get('main_channel'))
        sponsors_len = len(data.get('sponsors', []))
        
        kb = constructor_main_kb(
            "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –≤—Ä–µ–º—è", winners, ref_req, is_cap, has_main, sponsors_len
        )
    
    control_msg = await bot.send_message(chat_id, hint_text, reply_markup=kb)
    manager.set_control_message(control_msg)
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤—ã–µ ID
    await update_message_manager(state, manager)=== ./handlers/creator/constructor/channels_select.py ===
from aiogram import Router, types, F, Bot
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
import logging

from database.requests.channel_repo import get_user_channels
from keyboards.inline.constructor import channel_selection_kb
from handlers.creator.constructor.control_message import refresh_constructor_view

logger = logging.getLogger(__name__)
router = Router()

async def show_channels_selection(
    bot: Bot,
    state: FSMContext, 
    session: AsyncSession, 
    user_id: int, 
    mode: str, 
    chat_id: int
):
    """
    –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –º–µ–Ω—é –≤—ã–±–æ—Ä–∞ –∫–∞–Ω–∞–ª–æ–≤ —á–µ—Ä–µ–∑ refresh_constructor_view.
    """
    data = await state.get_data()
    
    # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤ –∏–∑ –ë–î
    channels = await get_user_channels(session, user_id)
    
    if mode == 'main':
        sel = [data['main_channel']['id']] if data.get('main_channel') else []
        hint_key = 'main_channel'
    else:
        # –î–ª—è —Å–ø–æ–Ω—Å–æ—Ä–æ–≤ –∏—Å–∫–ª—é—á–∞–µ–º —É–∂–µ –≤—ã–±—Ä–∞–Ω–Ω—ã–π –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª
        main_id = data['main_channel']['id'] if data.get('main_channel') else None
        channels = [ch for ch in channels if ch.channel_id != main_id]
        
        sel = [s['id'] for s in data.get('sponsors', [])]
        hint_key = 'sponsors'
    
    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
    kb = channel_selection_kb(channels, mode, sel)
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å (–ü—Ä–µ–≤—å—é + –ö–Ω–æ–ø–∫–∏ –≤—ã–±–æ—Ä–∞ –∫–∞–Ω–∞–ª–æ–≤)
    await refresh_constructor_view(bot, state, chat_id, hint_key=hint_key, custom_keyboard=kb)

# --- –•–ï–ù–î–õ–ï–†–´ ---

@router.callback_query(F.data == "constr_select_main")
async def select_main_menu(call: types.CallbackQuery, session: AsyncSession, state: FSMContext, bot: Bot):
    await state.update_data(channel_selector_mode="main")
    await show_channels_selection(bot, state, session, call.from_user.id, "main", call.message.chat.id)
    await call.answer()

@router.callback_query(F.data == "constr_select_sponsors")
async def select_sponsors_menu(call: types.CallbackQuery, session: AsyncSession, state: FSMContext, bot: Bot):
    await state.update_data(channel_selector_mode="sponsor")
    await show_channels_selection(bot, state, session, call.from_user.id, "sponsor", call.message.chat.id)
    await call.answer()

@router.callback_query(F.data.startswith("constr_set_ch:"))
async def set_channel(call: types.CallbackQuery, state: FSMContext, bot: Bot, session: AsyncSession):
    _, mode, ch_id_str = call.data.split(":")
    chat_id = int(ch_id_str)
    
    from database.requests.channel_repo import get_user_channels
    user_chs = await get_user_channels(session, call.from_user.id)
    target_ch = next((ch for ch in user_chs if ch.channel_id == chat_id), None)
    
    if not target_ch: 
        return await call.answer("‚ùå –ö–∞–Ω–∞–ª –Ω–µ –Ω–∞–π–¥–µ–Ω!", show_alert=True)

    # –§–æ—Ä–º–∏—Ä—É–µ–º –æ–±—ä–µ–∫—Ç –¥–∞–Ω–Ω—ã—Ö –∫–∞–Ω–∞–ª–∞
    link = target_ch.invite_link or (f"@{target_ch.username}" if target_ch.username else "private")
    channel_info = {
        'id': chat_id, 
        'title': target_ch.title, 
        'link': link,
        'db_id': target_ch.id
    }
    
    data = await state.get_data()
    sponsors = data.get('sponsors', [])

    if mode == "main":
        # –õ–æ–≥–∏–∫–∞ –¥–ª—è –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞
        if data.get('main_channel') and data['main_channel']['id'] == chat_id:
            await state.update_data(main_channel=None) # –°–Ω—è—Ç—å –≤—ã–±–æ—Ä
        else:
            # –ï—Å–ª–∏ –±—ã–ª –≤ —Å–ø–æ–Ω—Å–æ—Ä–∞—Ö - —É–±—Ä–∞—Ç—å
            if any(s['id'] == chat_id for s in sponsors):
                sponsors = [s for s in sponsors if s['id'] != chat_id]
                await state.update_data(sponsors=sponsors)
            
            await state.update_data(main_channel=channel_info)
            
        # –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–¥ (–æ—Å—Ç–∞–µ–º—Å—è –≤ –º–µ–Ω—é –≤—ã–±–æ—Ä–∞ main)
        await show_channels_selection(bot, state, session, call.from_user.id, "main", call.message.chat.id)
        
    else:  # mode == "sponsor"
        # –õ–æ–≥–∏–∫–∞ –¥–ª—è —Å–ø–æ–Ω—Å–æ—Ä–æ–≤
        if any(s['id'] == chat_id for s in sponsors):
            sponsors = [s for s in sponsors if s['id'] != chat_id] # –£–¥–∞–ª–∏—Ç—å
            await state.update_data(sponsors=sponsors)
        else:
            main_ch = data.get('main_channel')
            if main_ch and main_ch['id'] == chat_id:
                return await call.answer("‚ùå –≠—Ç–æ –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª!", show_alert=True)
            
            sponsors.append(channel_info) # –î–æ–±–∞–≤–∏—Ç—å
            await state.update_data(sponsors=sponsors)
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–¥ (–æ—Å—Ç–∞–µ–º—Å—è –≤ –º–µ–Ω—é –≤—ã–±–æ—Ä–∞ sponsors)
        await show_channels_selection(bot, state, session, call.from_user.id, "sponsor", call.message.chat.id)=== ./handlers/creator/time_picker.py ===
from aiogram import Router, types, F, Bot
from aiogram.fsm.context import FSMContext
from core.tools.timezone import get_now_msk
from datetime import datetime
from keyboards.inline.calendar_kb import generate_calendar, time_picker_kb
from handlers.creator.constructor.control_message import refresh_constructor_view

router = Router()

@router.callback_query(F.data == "constr_time_menu")
async def open_calendar(call: types.CallbackQuery):
    now = get_now_msk()
    await call.message.edit_reply_markup(reply_markup=generate_calendar(now.year, now.month))

@router.callback_query(F.data.startswith("cal_nav:"))
async def navigate_calendar(call: types.CallbackQuery):
    _, y, m = call.data.split(":")
    await call.message.edit_reply_markup(reply_markup=generate_calendar(int(y), int(m)))

@router.callback_query(F.data.startswith("date_set:"))
async def pick_date(call: types.CallbackQuery):
    _, y, m, d = call.data.split(":")
    await call.message.edit_reply_markup(reply_markup=time_picker_kb(int(y), int(m), int(d)))

@router.callback_query(F.data.startswith("time_set:"))
async def pick_time(call: types.CallbackQuery, state: FSMContext, bot: Bot):
    _, y, m, d, h, mn = call.data.split(":")
    
    try:
        from core.tools.timezone import MSK
        dt_msk = datetime(int(y), int(m), int(d), int(h), int(mn), tzinfo=MSK)
        
        if dt_msk <= get_now_msk():
            return await call.answer("‚ùå –í—Ä–µ–º—è —É–∂–µ –ø—Ä–æ—à–ª–æ!", show_alert=True)
            
        await state.update_data(finish_time_str=dt_msk.isoformat())
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å: —É–¥–∞–ª—è–µ–º –∫–∞–ª–µ–Ω–¥–∞—Ä—å (—ç—Ç–æ —Å—Ç–∞—Ä–æ–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ) –∏ —Ä–∏—Å—É–µ–º –∑–∞–Ω–æ–≤–æ
        await refresh_constructor_view(bot, state, call.message.chat.id, hint_key='publish')
        
    except ValueError:
        await call.answer("–û—à–∏–±–∫–∞ –¥–∞—Ç—ã")=== ./handlers/creator/__init__.py ===
# handlers/creator/__init__.py - –µ—Å–ª–∏ —Ñ–∞–π–ª —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –æ—Å—Ç–∞–≤—å—Ç–µ –µ–≥–æ –ø—É—Å—Ç—ã–º –∏–ª–∏:
from aiogram import Router

router = Router()
# –ù–∏–∫–∞–∫–∏—Ö –∏–º–ø–æ—Ä—Ç–æ–≤!=== ./handlers/super_admin/list_view.py ===
# handlers/super_admin/list_view.py
from aiogram import Router, F
from aiogram.types import CallbackQuery
from keyboards.callback_data import AdminAction
from keyboards.inline.admin_panel import build_manage_menu

router = Router()

# –õ–æ–≤–∏–º callback —Å action="manage"
@router.callback_query(AdminAction.filter(F.action == "manage"))
async def show_gw_options(call: CallbackQuery, callback_data: AdminAction):
    # –¢—É—Ç —É–∂–µ –ø—Ä–æ—à–ª–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ HMAC –≤ Middleware, —Ç–∞–∫ —á—Ç–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ
    gw_id = callback_data.id
    admin_id = call.from_user.id
    
    kb = build_manage_menu(gw_id, admin_id)
    await call.message.edit_text(f"‚öôÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–æ–∑—ã–≥—Ä—ã—à–µ–º #{gw_id}", reply_markup=kb)=== ./handlers/super_admin/user_manage.py ===
from aiogram import Router, types, F
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import update

from database.models.user import User
from filters.is_admin import IsAdmin

router = Router()

class AdminUserState(StatesGroup):
    waiting_for_id_prem = State()

@router.callback_query(IsAdmin(), F.data == "admin_find_user")
async def ask_user_id(call: types.CallbackQuery, state: FSMContext):
    await call.message.answer("üÜî –í–≤–µ–¥–∏—Ç–µ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –≤—ã–¥–∞—á–∏/—Å–Ω—è—Ç–∏—è Premium:")
    await state.set_state(AdminUserState.waiting_for_id_prem)
    await call.answer()

@router.message(IsAdmin(), AdminUserState.waiting_for_id_prem)
async def toggle_premium(message: types.Message, state: FSMContext, session: AsyncSession):
    try:
        target_id = int(message.text)
    except ValueError:
        return await message.answer("‚ùå –≠—Ç–æ –Ω–µ —á–∏—Å–ª–æ.")

    user = await session.get(User, target_id)
    if not user:
        return await message.answer("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ.")

    # –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Å—Ç–∞—Ç—É—Å
    new_status = not user.is_premium
    user.is_premium = new_status
    await session.commit()
    
    status_str = "‚úÖ –í–´–î–ê–ù" if new_status else "‚ùå –°–ù–Ø–¢"
    await message.answer(f"Premium –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {target_id} —É—Å–ø–µ—à–Ω–æ {status_str}.")
    await state.clear()=== ./handlers/super_admin/menu_main.py ===
from aiogram import Router, types, F
from aiogram.filters import Command
from sqlalchemy import func, select
from sqlalchemy.ext.asyncio import AsyncSession

from filters.is_admin import IsAdmin
from database.models.user import User
from database.models.giveaway import Giveaway
from keyboards.builders import simple_menu 

router = Router()

@router.message(IsAdmin(), Command("admin"))
async def admin_dashboard(message: types.Message, session: AsyncSession):
    # –°–±–æ—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    total_users = await session.scalar(select(func.count(User.user_id)))
    premium_users = await session.scalar(select(func.count(User.user_id)).where(User.is_premium == True))
    active_gws = await session.scalar(select(func.count(Giveaway.id)).where(Giveaway.status == "active"))
    finished_gws = await session.scalar(select(func.count(Giveaway.id)).where(Giveaway.status == "finished"))

    text = (
        f"üëë <b>–ü–∞–Ω–µ–ª—å –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞</b>\n\n"
        f"üë• <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏:</b> {total_users}\n"
        f"üåü <b>Premium:</b> {premium_users}\n"
        f"üé∞ <b>–†–æ–∑—ã–≥—Ä—ã—à–∏:</b>\n"
        f" ‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã–µ: {active_gws}\n"
        f" ‚Ä¢ –ó–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ: {finished_gws}\n\n"
        f"–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:"
    )
    
    # –ë–∏–ª–¥–µ—Ä –∫–Ω–æ–ø–æ–∫ (–Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —ç—Ç–∏ callback'–∏ –≤ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏)
    from aiogram.utils.keyboard import InlineKeyboardBuilder
    kb = InlineKeyboardBuilder()
    kb.button(text="üì¢ –†–∞—Å—Å—ã–ª–∫–∞", callback_data="admin_broadcast")
    kb.button(text="üë§ –ù–∞–π—Ç–∏ —é–∑–µ—Ä–∞", callback_data="admin_find_user")
    kb.button(text="üìã –°–ø–∏—Å–æ–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö GW", callback_data="admin_list_active")
    kb.adjust(2, 1)

    await message.answer(text, reply_markup=kb.as_markup())=== ./handlers/super_admin/manage_item.py ===
# handlers/super_admin/manage_item.py
from aiogram import Router, Bot, F
from aiogram.types import CallbackQuery
from keyboards.callback_data import AdminAction
from core.logic.game_actions import finish_giveaway_task

router = Router()

@router.callback_query(AdminAction.filter(F.action == "finish"))
async def force_finish(call: CallbackQuery, callback_data: AdminAction, bot: Bot):
    await call.answer("–ó–∞–ø—É—Å–∫–∞—é –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ...", show_alert=False)
    # –í—ã–∑—ã–≤–∞–µ–º –æ–±—â—É—é –ª–æ–≥–∏–∫—É
    await finish_giveaway_task(callback_data.id, bot)
    await call.message.edit_text(f"‚úÖ –†–æ–∑—ã–≥—Ä—ã—à #{callback_data.id} –∑–∞–≤–µ—Ä—à–µ–Ω –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ.")

@router.callback_query(AdminAction.filter(F.action == "delete"))
async def delete_gw(call: CallbackQuery, callback_data: AdminAction):
    # –õ–æ–≥–∏–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∏–∑ –ë–î (–Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –º–µ—Ç–æ–¥ –≤ repo)
    # await delete_giveaway(session, callback_data.id)
    await call.message.edit_text("üóë –†–æ–∑—ã–≥—Ä—ã—à —É–¥–∞–ª–µ–Ω (soft delete).")=== ./handlers/super_admin/broadcast.py ===
import asyncio
import logging
from aiogram import Router, types, F, Bot
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from aiogram.utils.keyboard import InlineKeyboardBuilder
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from database.models.user import User
from filters.is_admin import IsAdmin

router = Router()
logger = logging.getLogger(__name__)

class BroadcastState(StatesGroup):
    waiting_for_post = State()
    confirm = State()

@router.callback_query(IsAdmin(), F.data == "admin_broadcast")
async def start_broadcast(call: types.CallbackQuery, state: FSMContext):
    await call.message.answer(
        "üì¢ <b>–†–∞—Å—Å—ã–ª–∫–∞</b>\n\n"
        "–ü—Ä–∏—à–ª–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ (—Ç–µ–∫—Å—Ç, —Ñ–æ—Ç–æ, –≤–∏–¥–µ–æ –∏–ª–∏ —Ä–µ–ø–æ—Å—Ç), –∫–æ—Ç–æ—Ä–æ–µ –Ω—É–∂–Ω–æ —Ä–∞–∑–æ—Å–ª–∞—Ç—å –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º."
    )
    await state.set_state(BroadcastState.waiting_for_post)
    await call.answer()

@router.message(IsAdmin(), BroadcastState.waiting_for_post)
async def receive_post(message: types.Message, state: FSMContext):
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º ID —Å–æ–æ–±—â–µ–Ω–∏—è –∏ —á–∞—Ç–∞, —á—Ç–æ–±—ã –ø–æ—Ç–æ–º —Å–¥–µ–ª–∞—Ç—å copy_message
    await state.update_data(msg_id=message.message_id, chat_id=message.chat.id)
    
    kb = InlineKeyboardBuilder()
    kb.button(text="‚úÖ –û—Ç–ø—Ä–∞–≤–∏—Ç—å", callback_data="broadcast_go")
    kb.button(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="admin_cancel")
    kb.adjust(2)
    
    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∞–¥–º–∏–Ω—É, –∫–∞–∫ —ç—Ç–æ –±—É–¥–µ—Ç –≤—ã–≥–ª—è–¥–µ—Ç—å (–∫–æ–ø–∏—è)
    try:
        await message.copy_to(message.chat.id)
    except Exception as e:
        await message.answer(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞: {e}")
        return

    await message.answer("üëÜ –í—ã—à–µ –ø—Ä–µ–≤—å—é —Å–æ–æ–±—â–µ–Ω–∏—è.\n–ù–∞—á–∏–Ω–∞–µ–º —Ä–∞—Å—Å—ã–ª–∫—É?", reply_markup=kb.as_markup())
    await state.set_state(BroadcastState.confirm)

@router.callback_query(IsAdmin(), F.data == "admin_cancel")
async def cancel_broadcast(call: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await call.message.edit_text("‚ùå –†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.")

@router.callback_query(IsAdmin(), BroadcastState.confirm, F.data == "broadcast_go")
async def run_broadcast(call: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    msg_id = data['msg_id']
    from_chat_id = data['chat_id']
    admin_id = call.from_user.id
    
    await call.message.edit_text("üöÄ <b>–†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–ø—É—â–µ–Ω–∞ –≤ —Ñ–æ–Ω–æ–≤–æ–º —Ä–µ–∂–∏–º–µ!</b>\n–Ø —Å–æ–æ–±—â—É, –∫–æ–≥–¥–∞ –∑–∞–∫–æ–Ω—á—É.")
    await state.clear()
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º –∑–∞–¥–∞—á—É –≤ —Ñ–æ–Ω–µ, —á—Ç–æ–±—ã –±–æ—Ç –Ω–µ –∑–∞–≤–∏—Å
    # –ü–µ—Ä–µ–¥–∞–µ–º session, –Ω–æ –≤–Ω—É—Ç—Ä–∏ –∑–∞–¥–∞—á–∏ –ª—É—á—à–µ —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç—É –∞–∫–∫—É—Ä–∞—Ç–Ω–æ
    # –í –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ, —Ç–∞–∫ –∫–∞–∫ session –ø—Ä–∏–≤—è–∑–∞–Ω–∞ –∫ middleware, –ª—É—á—à–µ –≤—ã–≥—Ä—É–∑–∏—Ç—å ID —é–∑–µ—Ä–æ–≤ —Å—Ä–∞–∑—É
    
    # 1. –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ ID –ø–æ–ª—É—á–∞—Ç–µ–ª–µ–π —Å—Ä–∞–∑—É (—á—Ç–æ–±—ã –Ω–µ –¥–µ—Ä–∂–∞—Ç—å —Å–µ—Å—Å–∏—é –æ—Ç–∫—Ä—ã—Ç–æ–π –≤ —Ñ–æ–Ω–æ–≤–æ–π –∑–∞–¥–∞—á–µ –¥–æ–ª–≥–æ)
    result = await session.execute(select(User.user_id))
    user_ids = result.scalars().all()
    
    # 2. –°–æ–∑–¥–∞–µ–º —Ñ–æ–Ω–æ–≤—É—é –∑–∞–¥–∞—á—É
    asyncio.create_task(broadcast_task(bot, user_ids, from_chat_id, msg_id, admin_id))

async def broadcast_task(bot: Bot, user_ids: list[int], from_chat_id: int, msg_id: int, admin_id: int):
    """
    –§–æ–Ω–æ–≤–∞—è –∑–∞–¥–∞—á–∞ —Ä–∞—Å—Å—ã–ª–∫–∏.
    """
    logger.info(f"Starting broadcast to {len(user_ids)} users.")
    
    count = 0
    blocked = 0
    errors = 0
    
    for uid in user_ids:
        try:
            await bot.copy_message(chat_id=uid, from_chat_id=from_chat_id, message_id=msg_id)
            count += 1
        except Exception as e:
            # –û—à–∏–±–∫–∏ Telegram API (–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –±–æ—Ç–∞, —É–¥–∞–ª–µ–Ω–Ω—ã–π –∞–∫–∫–∞—É–Ω—Ç –∏ —Ç.–¥.)
            err_str = str(e).lower()
            if "blocked" in err_str or "user is deactivated" in err_str:
                blocked += 1
            else:
                errors += 1
                logger.debug(f"Broadcast error for {uid}: {e}")
        
        # –ü–∞—É–∑–∞ –∫–∞–∂–¥—ã–µ 20 —Å–æ–æ–±—â–µ–Ω–∏–π, —á—Ç–æ–±—ã –Ω–µ —Å–ª–æ–≤–∏—Ç—å FloodWait
        # –∏ –æ—Ç–¥–∞—Ç—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ Event Loop –¥—Ä—É–≥–∏–º –∑–∞–¥–∞—á–∞–º –±–æ—Ç–∞
        if (count + blocked + errors) % 20 == 0:
            await asyncio.sleep(0.5)
            
    # –û—Ç—á–µ—Ç –∞–¥–º–∏–Ω—É
    report_text = (
        f"üèÅ <b>–†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n"
        f"‚úÖ –£—Å–ø–µ—à–Ω–æ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {count}\n"
        f"üö´ –ë–æ—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω: {blocked}\n"
        f"‚ö†Ô∏è –î—Ä—É–≥–∏–µ –æ—à–∏–±–∫–∏: {errors}\n"
        f"üë• –í—Å–µ–≥–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ: {len(user_ids)}"
    )
    
    try:
        await bot.send_message(admin_id, report_text)
    except Exception as e:
        logger.error(f"Failed to send broadcast report to admin: {e}")=== ./handlers/super_admin/rig_winner.py ===
# handlers/super_admin/rig_winner.py
from aiogram import Router, F, types
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from sqlalchemy.ext.asyncio import AsyncSession

from keyboards.callback_data import AdminAction
from database.requests.giveaway_repo import set_predetermined_winner

router = Router()

class RigState(StatesGroup):
    waiting_for_id = State()

@router.callback_query(AdminAction.filter(F.action == "rig"))
async def start_rigging(call: types.CallbackQuery, callback_data: AdminAction, state: FSMContext):
    await state.update_data(gw_id=callback_data.id)
    await state.set_state(RigState.waiting_for_id)
    await call.message.answer(
        f"üïµÔ∏è‚Äç‚ôÇÔ∏è <b>–†–µ–∂–∏–º –±–æ–≥–∞</b> (–†–æ–∑—ã–≥—Ä—ã—à #{callback_data.id})\n"
        f"–ü—Ä–∏—à–ª–∏—Ç–µ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä—ã–π –î–û–õ–ñ–ï–ù –ø–æ–±–µ–¥–∏—Ç—å.\n"
        f"‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ–±—è–∑–∞–Ω –Ω–∞–∂–∞—Ç—å –∫–Ω–æ–ø–∫—É —É—á–∞—Å—Ç–∏—è, –∏–Ω–∞—á–µ —ç—Ç–æ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç!"
    )
    await call.answer()

@router.message(RigState.waiting_for_id)
async def set_winner_id(message: types.Message, state: FSMContext, session: AsyncSession):
    try:
        winner_id = int(message.text)
    except ValueError:
        return await message.answer("‚ùå –ù—É–∂–µ–Ω —á–∏—Å–ª–æ–≤–æ–π ID.")

    data = await state.get_data()
    gw_id = data['gw_id']

    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º "–∂—É—á–∫–∞" –≤ –ë–î
    await set_predetermined_winner(session, gw_id, winner_id)
    
    await message.answer(f"‚úÖ <b>–ì–æ—Ç–æ–≤–æ!</b>\n–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å `{winner_id}` –ø–æ–±–µ–¥–∏—Ç –≤ —Ä–æ–∑—ã–≥—Ä—ã—à–µ #{gw_id} (–µ—Å–ª–∏ –±—É–¥–µ—Ç —É—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å).")
    await state.clear()=== ./handlers/participant/join.py ===
from aiogram import Router, Bot, types, F
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from database.models.participant import Participant
from database.models.giveaway import Giveaway
from database.requests.giveaway_repo import get_giveaway_by_id, get_required_channels
from database.requests.participant_repo import (
    add_participant, 
    increment_ticket, 
    is_circular_referral, 
    is_participant_active,
    add_pending_referral, # <---
    get_pending_referral  # <---
)
from keyboards.inline.participation import check_subscription_kb
from core.logic.ticket_gen import get_unique_ticket
from core.services.ref_service import create_ref_link
from core.services.checker_service import is_user_subscribed

router = Router()

class JoinState(StatesGroup):
    captcha = State()
    subscribing = State()

@router.callback_query(F.data == "broken_link_alert")
async def broken_link_handler(call: types.CallbackQuery):
    await call.answer("‚ö†Ô∏è –°—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞–Ω–∞–ª –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞–π—Ç–∏ –µ–≥–æ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –∏–ª–∏ —Å–æ–æ–±—â–∏—Ç–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.", show_alert=True)

async def try_join_giveaway(
    message_or_call: types.Message | types.CallbackQuery, 
    gw_id: int, 
    session: AsyncSession, 
    bot: Bot, 
    state: FSMContext,
    referrer_id: int = None
):
    if isinstance(message_or_call, types.CallbackQuery):
        message = message_or_call.message
        user = message_or_call.from_user
        await message_or_call.answer()
    else:
        message = message_or_call
        user = message_or_call.from_user

    gw = await get_giveaway_by_id(session, gw_id)
    if not gw or gw.status != 'active':
        return await message.answer("üòî <b>–£–≤—ã, —ç—Ç–æ—Ç —Ä–æ–∑—ã–≥—Ä—ã—à —É–∂–µ –∑–∞–≤–µ—Ä—à–µ–Ω.</b>")

    if user.id == gw.owner_id:
        return await message.answer("‚ö†Ô∏è –í—ã –æ—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä —ç—Ç–æ–≥–æ —Ä–æ–∑—ã–≥—Ä—ã—à–∞.")

    existing_stmt = select(Participant).where(
        Participant.user_id == user.id,
        Participant.giveaway_id == gw_id
    )
    existing = await session.scalar(existing_stmt)
    
    bot_username = (await bot.get_me()).username

    if existing:
        text = (
            f"üëã <b>–¢—ã —É–∂–µ –≤ –∏–≥—Ä–µ!</b>\n\n"
            f"üé´ –¢–≤–æ–π –±–∏–ª–µ—Ç: <code>{existing.ticket_code}</code>\n"
            f"‚ö°Ô∏è –®–∞–Ω—Å–æ–≤ –Ω–∞ –ø–æ–±–µ–¥—É: <b>{existing.tickets_count}</b>"
        )
        if gw.is_referral_enabled:
            token = await create_ref_link(user.id)
            ref_link = f"https://t.me/{bot_username}?start=gw_{gw_id}_{token}"
            text += f"\n\nüîó –¢–≤–æ—è —Ä–µ—Ñ. —Å—Å—ã–ª–∫–∞:\n<code>{ref_link}</code>"
        
        try: await message.answer(text, disable_web_page_preview=True)
        except: pass
        return

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ—Ñ–µ—Ä–∞–ª–∞ –≤ –ë–î (–Ω–∞–¥–µ–∂–Ω–æ)
    if referrer_id:
        await add_pending_referral(session, user.id, referrer_id, gw_id)
    
    await state.update_data(gw_id=gw_id)

    if gw.is_captcha_enabled:
        await state.set_state(JoinState.captcha)
        kb = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="ü§ñ –Ø –Ω–µ —Ä–æ–±–æ—Ç", callback_data="captcha_solved")]
        ])
        await message.answer("üõ° <b>–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –±–æ—Ç–∞</b>\n–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ.", reply_markup=kb)
        return

    await check_subscriptions_step(message, user.id, gw, session, bot, state)

@router.callback_query(JoinState.captcha, F.data == "captcha_solved")
async def captcha_solved(call: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    gw_id = data.get("gw_id")
    gw = await get_giveaway_by_id(session, gw_id)
    
    if not gw:
        await call.answer("–û—à–∏–±–∫–∞")
        return await state.clear()

    await call.message.delete()
    await check_subscriptions_step(call.message, call.from_user.id, gw, session, bot, state)

async def check_subscriptions_step(message: types.Message, user_id: int, gw: Giveaway, session: AsyncSession, bot: Bot, state: FSMContext, force_check: bool = False):
    reqs = await get_required_channels(session, gw.id)
    
    channels_status = []
    all_subscribed = True

    # 1. –û—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª
    try:
        is_sub = await is_user_subscribed(bot, gw.channel_id, user_id, force_check=force_check)
        
        chat = await bot.get_chat(gw.channel_id)
        # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ —Å—Å—ã–ª–∫–∏
        link = chat.invite_link or (f"https://t.me/{chat.username}" if chat.username else None)
        
        channels_status.append({
            'title': f"üì¢ {chat.title}", 
            'link': link,
            'is_subscribed': is_sub
        })
        if not is_sub: all_subscribed = False
            
    except Exception:
        pass 

    # 2. –°–ø–æ–Ω—Å–æ—Ä—ã
    for r in reqs:
        is_sub = await is_user_subscribed(bot, r.channel_id, user_id, force_check=force_check)
        
        # –£ —Å–ø–æ–Ω—Å–æ—Ä–æ–≤ —Å—Å—ã–ª–∫–∞ —Ö—Ä–∞–Ω–∏—Ç—Å—è –≤ –ë–î, –Ω–æ –ø—Ä–æ–≤–µ—Ä–∏–º –Ω–∞ None
        link = r.channel_link if r.channel_link and len(r.channel_link) > 5 else None
        
        channels_status.append({
            'title': r.channel_title,
            'link': link,
            'is_subscribed': is_sub
        })
        if not is_sub: all_subscribed = False

    if not all_subscribed:
        await state.set_state(JoinState.subscribing)
        text = "üîí <b>–î–ª—è —É—á–∞—Å—Ç–∏—è –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –∑–∞–¥–∞–Ω–∏—è:</b>\n(–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫–∏, –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –∏ –ø—Ä–æ–≤–µ—Ä—å—Ç–µ)"
        
        kb = check_subscription_kb(gw.id, channels_status)
        
        try:
            await message.edit_text(text, reply_markup=kb)
        except:
            await message.answer(text, reply_markup=kb)
    else:
        try: await message.delete()
        except: pass
        
        await finalize_registration(message, user_id, gw, session, bot, state)

@router.callback_query(F.data.startswith("check_sub:"))
async def on_check_subscription_btn(call: types.CallbackQuery, session: AsyncSession, bot: Bot, state: FSMContext):
    gw_id = int(call.data.split(":")[-1])
    gw = await get_giveaway_by_id(session, gw_id)
    
    if not gw or gw.status != 'active':
        return await call.message.edit_text("‚ùå –†–æ–∑—ã–≥—Ä—ã—à –∑–∞–≤–µ—Ä—à–µ–Ω.")

    await check_subscriptions_step(call.message, call.from_user.id, gw, session, bot, state, force_check=True)
    await call.answer()

async def finalize_registration(
    message: types.Message, 
    user_id: int, 
    gw: Giveaway, 
    session: AsyncSession, 
    bot: Bot, 
    state: FSMContext
):
    # –î–æ—Å—Ç–∞–µ–º —Ä–µ—Ñ–µ—Ä–µ—Ä–∞ –∏–∑ –ë–î (–Ω–∞–¥–µ–∂–Ω–æ)
    referrer_id = await get_pending_referral(session, user_id, gw.id)
    
    final_referrer = None
    
    if gw.is_referral_enabled and referrer_id:
        if referrer_id == user_id:
            referrer_id = None
        elif await is_circular_referral(session, user_id, referrer_id, gw.id):
            referrer_id = None
        elif not await is_participant_active(session, referrer_id, gw.id):
            referrer_id = None
        else:
            final_referrer = referrer_id

    ticket = await get_unique_ticket(session, gw.id)
    is_new = await add_participant(session, user_id, gw.id, final_referrer, ticket)
    
    if not is_new:
        p = await session.scalar(select(Participant).where(Participant.user_id==user_id, Participant.giveaway_id==gw.id))
        ticket = p.ticket_code if p else "ERROR"
    else:
        if final_referrer:
            await increment_ticket(session, final_referrer, gw.id)
            try:
                await bot.send_message(final_referrer, f"üë§ –ü–æ –≤–∞—à–µ–π —Å—Å—ã–ª–∫–µ –≤ —Ä–æ–∑—ã–≥—Ä—ã—à–µ #{gw.id} –Ω–æ–≤—ã–π —É—á–∞—Å—Ç–Ω–∏–∫! (+1 –±–∏–ª–µ—Ç)")
            except: pass

    text = (
        f"üéâ <b>–ü–û–ó–î–†–ê–í–õ–Ø–ï–ú, –í–´ –í –ò–ì–†–ï!</b>\n\n"
        f"üé´ –¢–≤–æ–π –±–∏–ª–µ—Ç: <code>{ticket}</code>"
    )

    if gw.is_referral_enabled:
        bot_username = (await bot.get_me()).username
        token = await create_ref_link(user_id)
        ref_link = f"https://t.me/{bot_username}?start=gw_{gw.id}_{token}"
        text += (
            f"\n\nüöÄ <b>–£–≤–µ–ª–∏—á—å —à–∞–Ω—Å—ã –Ω–∞ –ø–æ–±–µ–¥—É!</b>\n"
            f"–ü—Ä–∏–≥–ª–∞—Å–∏ –¥—Ä—É–∑–µ–π –ø–æ —ç—Ç–æ–π —Å—Å—ã–ª–∫–µ –∏ –ø–æ–ª—É—á–∏ +1 –±–∏–ª–µ—Ç –∑–∞ –∫–∞–∂–¥–æ–≥–æ:\n"
            f"<code>{ref_link}</code>"
        )
    
    try:
        await message.edit_text(text, disable_web_page_preview=True)
    except:
        await message.answer(text, disable_web_page_preview=True)
        
    await state.clear()=== ./handlers/common/start.py ===
from aiogram import Router, types, Bot
from aiogram.filters import CommandStart, CommandObject
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from database.requests.user_repo import register_user
from database.models.winner import Winner
# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –≥–ª–∞–≤–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –≤—Ö–æ–¥–∞ (–æ–Ω–∞ —Ç–µ–ø–µ—Ä—å –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è try_join_giveaway)
from handlers.participant.join import try_join_giveaway 
from core.services.ref_service import resolve_ref_link

router = Router()

@router.message(CommandStart())
async def cmd_start(
    message: types.Message, 
    command: CommandObject, 
    session: AsyncSession, 
    bot: Bot, 
    state: FSMContext
):
    # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —é–∑–µ—Ä–∞ (–∏–º—è, username) –≤ –±–∞–∑–µ users
    await register_user(session, message.from_user.id, message.from_user.username, message.from_user.full_name)

    args = command.args
    if not args:
        return await message.answer(f"üëã –ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}!")

    # 1. –ü—Ä–æ—Å–º–æ—Ç—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ (res_ID)
    if args.startswith("res_"):
        try: gw_id = int(args.replace("res_", ""))
        except: return
        
        stmt = select(Winner).where(Winner.giveaway_id == gw_id)
        winners = (await session.execute(stmt)).scalars().all()
        
        if not winners:
            return await message.answer("üòî –ü–æ–±–µ–¥–∏—Ç–µ–ª–µ–π –Ω–µ—Ç –∏–ª–∏ —Ä–æ–∑—ã–≥—Ä—ã—à –µ—â–µ –∏–¥–µ—Ç.")
            
        text = "üèÜ <b>–°–ø–∏—Å–æ–∫ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π:</b>\n"
        is_winner = False
        for i, w in enumerate(winners, 1):
            if w.user_id == message.from_user.id: is_winner = True
            try:
                c = await bot.get_chat(w.user_id)
                name = f"@{c.username}" if c.username else c.full_name
                text += f"{i}. {name}\n"
            except:
                text += f"{i}. ID {w.user_id}\n"
        
        if is_winner: text = "üéâ <b>–í–´ –í–´–ò–ì–†–ê–õ–ò!</b> üéâ\n\n" + text
        return await message.answer(text)

    # 2. –£—á–∞—Å—Ç–∏–µ –≤ —Ä–æ–∑—ã–≥—Ä—ã—à–µ (gw_ID_TOKEN)
    if args.startswith("gw_"):
        clean_args = args.replace("gw_", "")
        parts = clean_args.split("_")
        
        try:
            gw_id = int(parts[0])
        except ValueError:
            return await message.answer("‚ùå –°—Å—ã–ª–∫–∞ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∞.")

        referrer_id = None
        # –ï—Å–ª–∏ –µ—Å—Ç—å –≤—Ç–æ—Ä–∞—è —á–∞—Å—Ç—å (—Ç–æ–∫–µ–Ω —Ä–µ—Ñ–µ—Ä–∞–ª–∞)
        if len(parts) > 1:
            token = parts[1]
            candidate_id = await resolve_ref_link(token)
            
            # –ë–∞–∑–æ–≤–∞—è –∑–∞—â–∏—Ç–∞: –Ω–µ–ª—å–∑—è –ø—Ä–∏–≥–ª–∞—Å–∏—Ç—å —Å–∞–º–æ–≥–æ —Å–µ–±—è
            if candidate_id and candidate_id != message.from_user.id:
                referrer_id = candidate_id

        # –ü–µ—Ä–µ–¥–∞–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤ –ª–æ–≥–∏–∫—É –≤—Ö–æ–¥–∞
        await try_join_giveaway(message, gw_id, session, bot, state, referrer_id)=== ./handlers/__init__.py ===
=== ./handlers/user/my_channels.py ===
import logging
from aiogram import Router, types, F, Bot
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from sqlalchemy.ext.asyncio import AsyncSession

from database.requests.channel_repo import add_channel, get_user_channels, delete_channel_by_id
from keyboards.inline.dashboard import channels_list_kb, back_to_dash, skip_link_kb

router = Router()
logger = logging.getLogger(__name__)

class ChannelState(StatesGroup):
    waiting_for_forward = State()
    waiting_for_link = State()

async def show_channels_list_msg(message_or_call, session: AsyncSession, user_id: int):
    channels = await get_user_channels(session, user_id)
    text = "üì¢ <b>–ú–æ–∏ –∫–∞–Ω–∞–ª—ã</b>\n\n–°–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤, –≥–¥–µ –±–æ—Ç —è–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º."
    kb = channels_list_kb(channels)
    
    if isinstance(message_or_call, types.CallbackQuery):
        await message_or_call.message.edit_text(text, reply_markup=kb)
    else:
        await message_or_call.answer(text, reply_markup=kb)

@router.callback_query(F.data == "my_channels")
async def show_channels(call: types.CallbackQuery, session: AsyncSession):
    await show_channels_list_msg(call, session, call.from_user.id)

@router.callback_query(F.data == "add_new_channel")
async def ask_channel(call: types.CallbackQuery, state: FSMContext):
    await state.set_state(ChannelState.waiting_for_forward)
    await call.message.edit_text(
        "‚ûï <b>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–∞ (–®–∞–≥ 1/2)</b>\n\n"
        "1. –î–æ–±–∞–≤—å—Ç–µ –±–æ—Ç–∞ –≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –∫–∞–Ω–∞–ª–∞.\n"
        "2. –ü–µ—Ä–µ—à–ª–∏—Ç–µ —Å—é–¥–∞ –ª—é–±–æ–π –ø–æ—Å—Ç –∏–∑ –∫–∞–Ω–∞–ª–∞ (–∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ @username).",
        reply_markup=back_to_dash()
    )

@router.message(ChannelState.waiting_for_forward)
async def process_channel_step1(message: types.Message, state: FSMContext, bot: Bot):
    chat_id = None
    title = "No Title"
    username = None

    if message.forward_from_chat:
        chat_id = message.forward_from_chat.id
        title = message.forward_from_chat.title
        username = message.forward_from_chat.username
    elif message.text and message.text.startswith("@"):
        try:
            chat = await bot.get_chat(message.text)
            chat_id = chat.id
            title = chat.title
            username = chat.username
        except:
            await message.answer("‚ùå –ù–µ –º–æ–≥—É –Ω–∞–π—Ç–∏ –∫–∞–Ω–∞–ª. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ @username.")
            return

    if not chat_id:
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–∞–Ω–∞–ª.")
        return

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤
    try:
        member = await bot.get_chat_member(chat_id, bot.id)
        if member.status not in ("administrator", "creator"):
            await message.answer("‚ùå –ë–æ—Ç –Ω–µ –∞–¥–º–∏–Ω! –î–∞–π—Ç–µ –ø—Ä–∞–≤–∞ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
            return
    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞: {e}")
        return

    # --- –ù–û–í–û–ï: –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–ª—É—á–∏—Ç—å —Å—Å—ã–ª–∫—É –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è ---
    invite_link = None
    if username:
        invite_link = f"https://t.me/{username}"
    else:
        # –ï—Å–ª–∏ –∫–∞–Ω–∞–ª –ø—Ä–∏–≤–∞—Ç–Ω—ã–π, –ø—Ä–æ–±—É–µ–º —Å–æ–∑–¥–∞—Ç—å –∏–ª–∏ –ø–æ–ª—É—á–∏—Ç—å —Å—Å—ã–ª–∫—É
        try:
            # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º —ç–∫—Å–ø–æ—Ä—Ç (–µ—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å)
            invite_link = await bot.export_chat_invite_link(chat_id)
        except:
            try:
                # –ï—Å–ª–∏ –Ω–µ –≤—ã—à–ª–æ, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é
                link_obj = await bot.create_chat_invite_link(chat_id, name="Giveaway Bot")
                invite_link = link_obj.invite_link
            except Exception as e:
                logger.warning(f"Could not generate link for {chat_id}: {e}")

    await state.update_data(temp_channel={
        "id": chat_id, 
        "title": title, 
        "username": username,
        "auto_link": invite_link
    })
    
    await state.set_state(ChannelState.waiting_for_link)
    
    text = f"‚úÖ –ö–∞–Ω–∞–ª <b>{title}</b> –Ω–∞–π–¥–µ–Ω!\n"
    if invite_link:
        text += f"üîó –°—Å—ã–ª–∫–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞: {invite_link}\n\n–ù–∞–∂–º–∏—Ç–µ ¬´–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å¬ª, —á—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ—ë, –∏–ª–∏ –ø—Ä–∏—à–ª–∏—Ç–µ —Å–≤–æ—é."
    else:
        text += "\nüîó <b>–®–∞–≥ 2/2:</b> –Ø –Ω–µ —Å–º–æ–≥ –ø–æ–ª—É—á–∏—Ç—å —Å—Å—ã–ª–∫—É (–∫–∞–Ω–∞–ª –ø—Ä–∏–≤–∞—Ç–Ω—ã–π?). –ü—Ä–∏—à–ª–∏—Ç–µ –∏–Ω–≤–∞–π—Ç-—Å—Å—ã–ª–∫—É –≤—Ä—É—á–Ω—É—é."

    await message.answer(text, reply_markup=skip_link_kb("settings"))

@router.message(ChannelState.waiting_for_link)
async def process_link_text(message: types.Message, state: FSMContext, session: AsyncSession):
    link = message.text.strip()
    if "t.me" not in link and not link.startswith("https://"):
        await message.answer("‚ùå –≠—Ç–æ –Ω–µ –ø–æ—Ö–æ–∂–µ –Ω–∞ —Å—Å—ã–ª–∫—É.")
        return

    data = await state.get_data()
    ch_data = data['temp_channel']
    
    await add_channel(session, message.from_user.id, ch_data['id'], ch_data['title'], ch_data['username'], link)
    
    await message.answer(f"‚úÖ –ö–∞–Ω–∞–ª <b>{ch_data['title']}</b> —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω!")
    await state.clear()
    await show_channels_list_msg(message, session, message.from_user.id)

@router.callback_query(ChannelState.waiting_for_link, F.data == "skip_link_settings")
async def process_link_skip(call: types.CallbackQuery, state: FSMContext, session: AsyncSession):
    data = await state.get_data()
    ch_data = data['temp_channel']
    
    final_link = ch_data.get('auto_link')
    if not final_link:
        return await call.answer("‚ùå –°—Å—ã–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, –ø—Ä–∏—à–ª–∏—Ç–µ –≤—Ä—É—á–Ω—É—é.", show_alert=True)

    await add_channel(session, call.from_user.id, ch_data['id'], ch_data['title'], ch_data['username'], final_link)
    
    await call.message.delete()
    await call.message.answer(f"‚úÖ –ö–∞–Ω–∞–ª <b>{ch_data['title']}</b> —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω!")
    await state.clear()
    await show_channels_list_msg(call.message, session, call.from_user.id)

@router.callback_query(F.data.startswith("del_ch_"))
async def delete_ch(call: types.CallbackQuery, session: AsyncSession):
    try:
        ch_id = int(call.data.split("_")[-1])
        await delete_channel_by_id(session, ch_id, call.from_user.id)
        await call.answer("üóë –ö–∞–Ω–∞–ª —É–¥–∞–ª–µ–Ω.")
        await show_channels(call, session)
    except Exception as e:
        logger.error(f"Error deleting channel: {e}")
        await call.answer("–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è", show_alert=True)=== ./handlers/user/dashboard.py ===
from aiogram import Router, types, Bot, F
from aiogram.filters import CommandStart, CommandObject
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.exceptions import TelegramBadRequest # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∏—Å–∫–ª—é—á–µ–Ω–∏–µ

from database.requests.user_repo import register_user
from keyboards.inline.dashboard import start_menu_kb, cabinet_kb
from handlers.common.start import cmd_start as deep_link_logic

router = Router()

@router.message(CommandStart())
async def smart_dashboard(
    message: types.Message, 
    command: CommandObject, 
    session: AsyncSession, 
    bot: Bot,
    state: FSMContext
):
    # DeepLink (—Ä–µ—Ñ–∫–∏ –∏ —É—á–∞—Å—Ç–∏–µ)
    if command.args and (command.args.startswith("gw_") or command.args.startswith("res_")):
        await deep_link_logic(message, command, session, bot, state)
        return

    # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è
    await register_user(session, message.from_user.id, message.from_user.username, message.from_user.full_name)
    
    text = (
        f"üëã <b>–ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}!</b>\n"
        f"–≠—Ç–æ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞ –¥–ª—è –ø—Ä–æ–≤–µ–¥–µ–Ω–∏—è —á–µ—Å—Ç–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π.\n\n"
        f"–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:"
    )

    await message.answer(text, reply_markup=start_menu_kb())

@router.callback_query(F.data == "dashboard_home")
async def back_home(call: types.CallbackQuery):
    try:
        await call.message.edit_text(
            "üëã <b>–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", 
            reply_markup=start_menu_kb()
        )
    except TelegramBadRequest:
        # –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å - –ø—Ä–æ—Å—Ç–æ –æ—Ç–≤–µ—á–∞–µ–º –Ω–∞ callback, —á—Ç–æ–±—ã —É–±—Ä–∞—Ç—å —á–∞—Å–∏–∫–∏
        await call.answer()

@router.callback_query(F.data == "cabinet_hub")
async def open_cabinet(call: types.CallbackQuery, session: AsyncSession):
    text = (
        "üë§ <b>–ö–∞–±–∏–Ω–µ—Ç –æ—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä–∞</b>\n\n"
        f"üÜî ID: <code>{call.from_user.id}</code>\n"
        "üìä –ó–¥–µ—Å—å –≤—ã —É–ø—Ä–∞–≤–ª—è–µ—Ç–µ –∫–∞–Ω–∞–ª–∞–º–∏ –∏ –ø–æ–¥–ø–∏—Å–∫–æ–π."
    )
    try:
        await call.message.edit_text(text, reply_markup=cabinet_kb())
    except TelegramBadRequest:
        await call.answer()=== ./handlers/user/premium.py ===
from aiogram import Router, types, F, Bot
from aiogram.types import LabeledPrice, PreCheckoutQuery
from sqlalchemy.ext.asyncio import AsyncSession
from database.models.user import User
from keyboards.inline.dashboard import premium_shop_kb

router = Router()

@router.callback_query(F.data == "premium_shop")
async def show_shop(call: types.CallbackQuery, session: AsyncSession):
    user = await session.get(User, call.from_user.id)
    status_text = "‚úÖ <b>–£ –≤–∞—Å –∞–∫—Ç–∏–≤–µ–Ω Premium!</b>" if user.is_premium else "‚ùå –£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏."
    
    text = (
        "üß© <b>–ü–ª–∞—Ç–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏</b>\n\n"
        f"–í–∞—à —Å—Ç–∞—Ç—É—Å: {status_text}\n\n"
        "<b>üõ° –ó–∞—â–∏—Ç–∞ –æ—Ç –±–æ—Ç–æ–≤ (–ö–∞–ø—á–∞)</b>\n"
        "–ó–∞—Å—Ç–∞–≤–ª—è–µ—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –ø—Ä–æ–π—Ç–∏ –ø—Ä–æ–≤–µ—Ä–∫—É –ø–µ—Ä–µ–¥ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–µ–π. "
        "–û—Ç—Å–µ–∏–≤–∞–µ—Ç 99% –Ω–∞–∫—Ä—É—Ç–∫–∏.\n\n"
        "–°—Ç–æ–∏–º–æ—Å—Ç—å: <b>50 ‚≠êÔ∏è Stars</b>"
    )
    await call.message.edit_text(text, reply_markup=premium_shop_kb())

@router.callback_query(F.data == "buy_captcha")
async def buy_process(call: types.CallbackQuery, bot: Bot):
    await bot.send_invoice(
        chat_id=call.from_user.id,
        title="Premium –ü–æ–¥–ø–∏—Å–∫–∞",
        description="–ê–∫—Ç–∏–≤–∞—Ü–∏—è –ö–∞–ø—á–∏ (–ó–∞—â–∏—Ç–∞ –æ—Ç –±–æ—Ç–æ–≤)",
        payload="buy_premium_captcha", 
        currency="XTR", 
        prices=[LabeledPrice(label="Premium", amount=50)], 
        provider_token="" # –í–ê–ñ–ù–û: –î–ª—è Telegram Stars –ø–æ–ª–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø—É—Å—Ç—ã–º!
    )
    await call.answer()

@router.pre_checkout_query()
async def on_pre_checkout(pre_checkout_query: PreCheckoutQuery, bot: Bot):
    await bot.answer_pre_checkout_query(pre_checkout_query.id, ok=True)

@router.message(F.successful_payment)
async def on_successful_payment(message: types.Message, session: AsyncSession):
    payment = message.successful_payment
    
    if payment.invoice_payload == "buy_premium_captcha":
        user = await session.get(User, message.from_user.id)
        if user:
            user.is_premium = True
            await session.commit()
            
            await message.answer(
                "üéâ <b>–û–ø–ª–∞—Ç–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ!</b>\n"
                "–§—É–Ω–∫—Ü–∏—è ¬´–ö–∞–ø—á–∞¬ª —Ç–µ–ø–µ—Ä—å –¥–æ—Å—Ç—É–ø–Ω–∞ –≤ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–µ.\n\n"
            )=== ./handlers/user/__init__.py ===
=== ./handlers/user/my_giveaways.py ===
import logging
from aiogram import Router, types, Bot, F
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import delete

from database.requests.giveaway_repo import get_giveaways_by_owner, get_giveaway_by_id, count_giveaways_by_status
from database.models.giveaway import Giveaway
from database.models.winner import Winner
from database.models.participant import Participant
from database.models.required_channel import GiveawayRequiredChannel
from keyboards.inline.dashboard import my_giveaways_hub_kb, giveaways_list_kb, active_gw_manage_kb, finished_gw_manage_kb
from core.logic.game_actions import finish_giveaway_task
from keyboards.inline.participation import join_keyboard
from core.tools.formatters import format_giveaway_caption

router = Router()
logger = logging.getLogger(__name__)

# --- –•–ê–ë ---
@router.callback_query(F.data == "my_giveaways_hub")
async def show_gw_hub(call: types.CallbackQuery, session: AsyncSession):
    user_id = call.from_user.id
    
    active_count = await count_giveaways_by_status(session, user_id, "active")
    finished_count = await count_giveaways_by_status(session, user_id, "finished")
    
    await call.message.edit_text(
        "üìÇ <b>–ò—Å—Ç–æ—Ä–∏—è —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π</b>\n–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:", 
        reply_markup=my_giveaways_hub_kb(active_count, finished_count)
    )

# --- –°–ü–ò–°–ö–ò ---
@router.callback_query(F.data.startswith("gw_list:"))
async def show_gw_list(call: types.CallbackQuery, session: AsyncSession):
    status = call.data.split(":")[1]
    user_id = call.from_user.id
    
    # –ü–æ–ª—É—á–∞–µ–º –¢–û–õ–¨–ö–û —Ä–æ–∑—ã–≥—Ä—ã—à–∏ —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    gws = await get_giveaways_by_owner(session, user_id, limit=50)
    filtered = [g for g in gws if g.status == status]
    
    if not filtered:
        return await call.answer("üì≠ –í —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø—É—Å—Ç–æ.", show_alert=True)
    
    title = "–ê–∫—Ç—É–∞–ª—å–Ω—ã–µ" if status == 'active' else "–ó–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ"
    await call.message.edit_text(
        f"üìÇ <b>{title} —Ä–æ–∑—ã–≥—Ä—ã—à–∏</b>",
        reply_markup=giveaways_list_kb(filtered, status)
    )

# --- –£–ü–†–ê–í–õ–ï–ù–ò–ï (–ú–µ–Ω—é) ---
@router.callback_query(F.data.startswith("gw_manage:"))
async def manage_gw(call: types.CallbackQuery, session: AsyncSession, bot: Bot):
    gw_id = int(call.data.split(":")[1])
    gw = await get_giveaway_by_id(session, gw_id)
    
    if not gw: 
        return await call.answer("–†–æ–∑—ã–≥—Ä—ã—à –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
    
    # –ó–ê–©–ò–¢–ê: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ –≤–ª–∞–¥–µ–ª–µ—Ü
    if gw.owner_id != call.from_user.id:
        return await call.answer("‚õî –í—ã –Ω–µ —è–≤–ª—è–µ—Ç–µ—Å—å —Å–æ–∑–¥–∞—Ç–µ–ª–µ–º —ç—Ç–æ–≥–æ —Ä–æ–∑—ã–≥—Ä—ã—à–∞!", show_alert=True)
    
    stats_info = f"üèÜ –ü—Ä–∏–∑: {gw.prize_text}\nüìÖ –§–∏–Ω–∏—à: {gw.finish_time.strftime('%d.%m %H:%M')}"
    
    if gw.status == "active":
        await call.message.edit_text(f"üü¢ <b>–ê–∫—Ç–∏–≤–Ω—ã–π —Ä–æ–∑—ã–≥—Ä—ã—à #{gw.id}</b>\n\n{stats_info}", reply_markup=active_gw_manage_kb(gw.id))
    else:
        link = None
        try:
            chat = await bot.get_chat(gw.channel_id)
            if chat.username: link = f"https://t.me/{chat.username}/{gw.message_id}"
        except Exception as e: 
            logger.warning(f"Failed to get link for GW {gw_id}: {e}")
        
        await call.message.edit_text(f"‚ö´Ô∏è <b>–ó–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–π —Ä–æ–∑—ã–≥—Ä—ã—à #{gw.id}</b>\n\n{stats_info}", reply_markup=finished_gw_manage_kb(gw.id, link))

# --- –î–ï–ô–°–¢–í–ò–Ø ---

# 1. –†–ï–ü–û–°–¢
@router.callback_query(F.data.startswith("gw_act:repost:"))
async def repost_gw(call: types.CallbackQuery, session: AsyncSession, bot: Bot):
    gw_id = int(call.data.split(":")[2])
    gw = await get_giveaway_by_id(session, gw_id)
    
    if not gw: 
        return await call.answer("–†–æ–∑—ã–≥—Ä—ã—à –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
        
    # –ó–ê–©–ò–¢–ê: –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–ª–∞–¥–µ–ª—å—Ü–∞
    if gw.owner_id != call.from_user.id:
        return await call.answer("‚õî –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω!", show_alert=True)
        
    if gw.status != 'active': 
        return await call.answer("–†–æ–∑—ã–≥—Ä—ã—à —É–∂–µ –∑–∞–≤–µ—Ä—à–µ–Ω", show_alert=True)
    
    # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –ø–æ—Å—Ç (–ø—ã—Ç–∞–µ–º—Å—è)
    try:
        await bot.delete_message(gw.channel_id, gw.message_id)
    except Exception as e:
        logger.warning(f"Could not delete old message for GW {gw_id}: {e}")

    bot_info = await bot.get_me()
    kb = join_keyboard(bot_info.username, gw.id)
    
    from database.requests.participant_repo import get_participants_count
    from core.tools.timezone import to_utc
    
    count = await get_participants_count(session, gw_id)
    caption = format_giveaway_caption(gw.prize_text, gw.winners_count, to_utc(gw.finish_time), count)
    
    try:
        if gw.media_file_id and gw.media_type:
            if gw.media_type == 'photo':
                msg = await bot.send_photo(gw.channel_id, gw.media_file_id, caption=caption, reply_markup=kb)
            elif gw.media_type == 'video':
                msg = await bot.send_video(gw.channel_id, gw.media_file_id, caption=caption, reply_markup=kb)
            else:
                msg = await bot.send_message(gw.channel_id, text=caption, reply_markup=kb)
        else:
             msg = await bot.send_message(gw.channel_id, text=caption, reply_markup=kb)
        
        gw.message_id = msg.message_id
        await session.commit()
        await call.answer("‚úÖ –ü–æ—Å—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω –ø–æ–≤—Ç–æ—Ä–Ω–æ!", show_alert=True)
    except Exception as e:
        logger.error(f"Failed to repost GW {gw_id}: {e}")
        await call.answer(f"–û—à–∏–±–∫–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏: {e}", show_alert=True)

# 2. –ó–ê–í–ï–†–®–ï–ù–ò–ï
@router.callback_query(F.data.startswith("gw_act:finish:"))
async def finish_gw_now(call: types.CallbackQuery, session: AsyncSession):
    gw_id = int(call.data.split(":")[2])
    
    # –°–Ω–∞—á–∞–ª–∞ –ø–æ–ª—É—á–∞–µ–º —Ä–æ–∑—ã–≥—Ä—ã—à –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∞–≤
    gw = await get_giveaway_by_id(session, gw_id)
    
    if not gw:
        return await call.answer("–†–æ–∑—ã–≥—Ä—ã—à –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
        
    # –ó–ê–©–ò–¢–ê: –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–ª–∞–¥–µ–ª—å—Ü–∞
    if gw.owner_id != call.from_user.id:
        return await call.answer("‚õî –í—ã –Ω–µ –º–æ–∂–µ—Ç–µ –∑–∞–≤–µ—Ä—à–∏—Ç—å —á—É–∂–æ–π —Ä–æ–∑—ã–≥—Ä—ã—à!", show_alert=True)
    
    await call.answer("–ó–∞–≤–µ—Ä—à–∞—é...", show_alert=False)
    # –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞—Å–∫—É
    await finish_giveaway_task(gw_id)
    await call.message.edit_text("‚úÖ –†–æ–∑—ã–≥—Ä—ã—à –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω.")

# 3. –£–î–ê–õ–ï–ù–ò–ï
@router.callback_query(F.data.startswith("gw_act:delete:"))
async def delete_gw(call: types.CallbackQuery, session: AsyncSession, bot: Bot):
    gw_id = int(call.data.split(":")[2])
    gw = await get_giveaway_by_id(session, gw_id)
    
    if not gw:
        return await call.answer("–†–æ–∑—ã–≥—Ä—ã—à –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)

    # –ó–ê–©–ò–¢–ê: –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–ª–∞–¥–µ–ª—å—Ü–∞
    if gw.owner_id != call.from_user.id:
        return await call.answer("‚õî –í—ã –Ω–µ –º–æ–∂–µ—Ç–µ —É–¥–∞–ª–∏—Ç—å —á—É–∂–æ–π —Ä–æ–∑—ã–≥—Ä—ã—à!", show_alert=True)
        
    # –ü—ã—Ç–∞–µ–º—Å—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å—Ç –∏–∑ –∫–∞–Ω–∞–ª–∞
    try:
        await bot.delete_message(gw.channel_id, gw.message_id)
    except Exception as e:
        logger.warning(f"Message delete failed for GW {gw_id}: {e}")
    
    # –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–æ–Ω–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ –∏–∑ –ë–î
    try:
        # –£–¥–∞–ª—è–µ–º –∑–∞–≤–∏—Å–∏–º—ã–µ –∑–∞–ø–∏—Å–∏
        await session.execute(delete(Winner).where(Winner.giveaway_id == gw_id))
        await session.execute(delete(Participant).where(Participant.giveaway_id == gw_id))
        await session.execute(delete(GiveawayRequiredChannel).where(GiveawayRequiredChannel.giveaway_id == gw_id))
        # –£–¥–∞–ª—è–µ–º —Å–∞–º —Ä–æ–∑—ã–≥—Ä—ã—à
        await session.delete(gw)
        await session.commit()
        await call.answer("üóë –†–æ–∑—ã–≥—Ä—ã—à —É–¥–∞–ª–µ–Ω.", show_alert=True)
    except Exception as e:
        logger.error(f"DB Delete failed for GW {gw_id}: {e}")
        await session.rollback()
        await call.answer("‚ùå –û—à–∏–±–∫–∞ –ë–î –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏.", show_alert=True)
        
    await show_gw_hub(call, session)=== ./handlers/user/my_participations.py ===
import math
from aiogram import Router, types, F, Bot
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from database.models.winner import Winner
from database.requests.participant_repo import get_user_participations_detailed, count_user_participations
from database.requests.giveaway_repo import get_giveaway_by_id, get_giveaways_by_owner, count_giveaways_by_owner
from database.requests.user_repo import get_user_stats
from keyboards.inline.user_panel import giveaways_hub_kb, universal_list_kb, participation_details_kb, detail_back_kb

router = Router()

# 1. –•–ê–ë (–ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ –†–ê–ó–î–ï–õ–ê)
@router.callback_query(F.data.in_({"my_participations", "giveaways_hub"}))
async def show_hub(call: types.CallbackQuery, session: AsyncSession):
    user_id = call.from_user.id
    
    stats = await get_user_stats(session, user_id)
    has_created = (stats['active'] + stats['finished']) > 0
    
    active_count = await count_user_participations(session, user_id, "active")
    finished_count = await count_user_participations(session, user_id, "finished")
    
    # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ (–æ—Å–æ–±–µ–Ω–Ω–æ –µ—Å–ª–∏ —Ç–∞–º –±—ã–ª–∞ –∫–∞—Ä—Ç–∏–Ω–∫–∞)
    try: await call.message.delete()
    except: pass

    await call.message.answer(
        "üéÅ <b>–†–∞–∑–¥–µ–ª: –†–æ–∑—ã–≥—Ä—ã—à–∏</b>\n\n"
        "–ó–¥–µ—Å—å –æ—Ç–æ–±—Ä–∞–∂–∞—é—Ç—Å—è —Ä–æ–∑—ã–≥—Ä—ã—à–∏, –≤ –∫–æ—Ç–æ—Ä—ã—Ö –≤—ã –ø—Ä–∏–Ω–∏–º–∞–µ—Ç–µ —É—á–∞—Å—Ç–∏–µ.",
        reply_markup=giveaways_hub_kb(has_created, active_count, finished_count)
    )

# 2. –°–ü–ò–°–û–ö –£–ß–ê–°–¢–ò–ô
@router.callback_query(F.data.startswith("part_list:"))
async def show_participation_list(call: types.CallbackQuery, session: AsyncSession):
    parts = call.data.split(":")
    status = parts[1]
    page = int(parts[2])
    
    limit = 5
    offset = page * limit
    user_id = call.from_user.id
    
    giveaways = await get_user_participations_detailed(session, user_id, status, limit, offset)
    total_count = await count_user_participations(session, user_id, status)
    
    if total_count == 0:
        return await call.answer("üì≠ –ó–¥–µ—Å—å –ø–æ–∫–∞ –ø—É—Å—Ç–æ.", show_alert=True)
        
    total_pages = math.ceil(total_count / limit)
    status_text = "–í –∫–æ—Ç–æ—Ä—ã—Ö —É—á–∞—Å—Ç–≤—É—é" if status == 'active' else "–ó–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ (–£—á–∞—Å—Ç–∏–µ)"
    prefix = f"part_list:{status}"
    
    won_ids = set()
    if status == 'finished' and giveaways:
        gw_ids = [gw.id for gw in giveaways]
        stmt = select(Winner.giveaway_id).where(
            Winner.giveaway_id.in_(gw_ids),
            Winner.user_id == user_id
        )
        result = await session.execute(stmt)
        won_ids = set(result.scalars().all())
    
    try: await call.message.delete()
    except: pass

    await call.message.answer(
        f"üìÇ <b>{status_text}</b>\n–°—Ç—Ä–∞–Ω–∏—Ü–∞ {page+1} –∏–∑ {total_pages}",
        reply_markup=universal_list_kb(giveaways, page, total_pages, prefix, won_ids=won_ids)
    )

# 3. –°–ü–ò–°–û–ö –°–û–ó–î–ê–ù–ù–´–•
@router.callback_query(F.data.startswith("created_list:"))
async def show_created_list(call: types.CallbackQuery, session: AsyncSession):
    page = int(call.data.split(":")[1])
    limit = 5
    offset = page * limit
    user_id = call.from_user.id
    
    giveaways = await get_giveaways_by_owner(session, user_id, limit, offset)
    total_count = await count_giveaways_by_owner(session, user_id)
    
    if total_count == 0:
        return await call.answer("üì≠ –í—ã –µ—â–µ –Ω–µ —Å–æ–∑–¥–∞–≤–∞–ª–∏ —Ä–æ–∑—ã–≥—Ä—ã—à–∏.", show_alert=True)
        
    total_pages = math.ceil(total_count / limit)
    
    try: await call.message.delete()
    except: pass

    await call.message.answer(
        f"üìÇ <b>–ú–æ–∏ —Ä–æ–∑—ã–≥—Ä—ã—à–∏ (–°–æ–∑–¥–∞–Ω–Ω—ã–µ)</b>\n–°—Ç—Ä–∞–Ω–∏—Ü–∞ {page+1} –∏–∑ {total_pages}",
        reply_markup=universal_list_kb(giveaways, page, total_pages, "created_list", won_ids=set())
    )

# 4. –ü–†–û–°–ú–û–¢–† –î–ï–¢–ê–õ–ï–ô (–£–ß–ê–°–¢–ò–ï)
@router.callback_query(F.data.startswith("part_view:"))
async def view_participation(call: types.CallbackQuery, session: AsyncSession, bot: Bot):
    gw_id = int(call.data.split(":")[-1])
    gw = await get_giveaway_by_id(session, gw_id)
    if not gw: return await call.answer("–ù–µ –Ω–∞–π–¥–µ–Ω–æ")

    user_id = call.from_user.id
    
    try: await call.message.delete()
    except: pass

    # 1. –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç (–∫–∞—Ä—Ç–∏–Ω–∫—É/–≤–∏–¥–µ–æ) –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ–º
    try:
        await bot.copy_message(
            chat_id=user_id,
            from_chat_id=gw.channel_id,
            message_id=gw.message_id,
            reply_markup=None
        )
    except Exception:
        pass # –ï—Å–ª–∏ –ø–æ—Å—Ç —É–¥–∞–ª–µ–Ω –∏–ª–∏ –±–æ—Ç –Ω–µ –∏–º–µ–µ—Ç –¥–æ—Å—Ç—É–ø–∞, –ø—Ä–æ—Å—Ç–æ –∏–¥–µ–º –¥–∞–ª—å—à–µ

    # 2. –°—Ç–∞—Ç—É—Å
    if gw.status == 'active':
        st_text = "‚è≥ –ê–∫—Ç–∏–≤–µ–Ω"
        res_text = "ü§û –í—ã —É—á–∞—Å—Ç–≤—É–µ—Ç–µ"
    else:
        st_text = "üèÅ –ó–∞–≤–µ—Ä—à–µ–Ω"
        winner_check = await session.scalar(
            select(Winner).where(Winner.giveaway_id == gw.id, Winner.user_id == user_id)
        )
        if winner_check:
            res_text = "üèÜ <b>–í–´ –í–´–ò–ì–†–ê–õ–ò!</b>"
        else:
            res_text = "‚ùå –í—ã –Ω–µ –≤—ã–∏–≥—Ä–∞–ª–∏"

    # 3. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Å—ã–ª–∫–∏ (–£–ù–ò–§–ò–¶–ò–†–û–í–ê–ù–ù–ê–Ø –õ–û–ì–ò–ö–ê)
    post_link = None
    try:
        chat = await bot.get_chat(gw.channel_id)
        
        if chat.username:
            # –ü—É–±–ª–∏—á–Ω—ã–π –∫–∞–Ω–∞–ª: t.me/username/id
            post_link = f"https://t.me/{chat.username}/{gw.message_id}"
        else:
            # –ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–∞–Ω–∞–ª: t.me/c/clean_id/id
            # ID –ø—Ä–∏–≤–∞—Ç–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤ –Ω–∞—á–∏–Ω–∞—é—Ç—Å—è —Å -100, –¥–ª—è —Å—Å—ã–ª–∫–∏ —ç—Ç–æ –Ω—É–∂–Ω–æ —É–±—Ä–∞—Ç—å
            clean_id = str(gw.channel_id).replace("-100", "")
            post_link = f"https://t.me/c/{clean_id}/{gw.message_id}"
            
    except Exception:
        # –ï—Å–ª–∏ –±–æ—Ç –∫–∏–∫–Ω—É—Ç –∏ –Ω–µ –º–æ–∂–µ—Ç –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ –æ —á–∞—Ç–µ, —Å—Å—ã–ª–∫–∞ –±—É–¥–µ—Ç None
        pass

    await call.message.answer(
        f"üìã <b>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± —É—á–∞—Å—Ç–∏–∏</b>\n\n"
        f"üéÅ –ü—Ä–∏–∑: <b>{gw.prize_text}</b>\n"
        f"–°—Ç–∞—Ç—É—Å: {st_text}\n"
        f"{res_text}",
        reply_markup=participation_details_kb(post_link)
    )

# 5. –ü–†–û–°–ú–û–¢–† –î–ï–¢–ê–õ–ï–ô (–°–û–ó–î–ê–ù–ù–´–ô)
@router.callback_query(F.data.startswith("view_created:"))
async def view_created(call: types.CallbackQuery, session: AsyncSession, bot: Bot):
    gw_id = int(call.data.split(":")[-1])
    gw = await get_giveaway_by_id(session, gw_id)
    if not gw: return await call.answer("–ù–µ –Ω–∞–π–¥–µ–Ω–æ")
    
    try: await call.message.delete()
    except: pass

    try:
        await bot.copy_message(
            chat_id=call.from_user.id,
            from_chat_id=gw.channel_id,
            message_id=gw.message_id,
            reply_markup=None
        )
    except: pass
    
    await call.message.answer(
        f"üì¢ <b>–í–∞—à —Ä–æ–∑—ã–≥—Ä—ã—à #{gw.id}</b>\n\n"
        f"üìù –ü—Ä–∏–∑: {gw.prize_text}\n"
        f"üë• –ü–æ–±–µ–¥–∏—Ç–µ–ª–µ–π: {gw.winners_count}\n"
        f"üìÖ –§–∏–Ω–∏—à: {gw.finish_time.strftime('%Y-%m-%d %H:%M')}\n"
        f"‚öôÔ∏è –°—Ç–∞—Ç—É—Å: {gw.status}",
        reply_markup=detail_back_kb()
    )

@router.callback_query(F.data == "ignore")
async def ignore(call: types.CallbackQuery): 
    await call.answer()
=== ./keyboards/inline/calendar_kb.py ===
import calendar
from datetime import datetime
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from core.tools.timezone import get_now_msk

MONTHS = ["", "–Ø–Ω–≤–∞—Ä—å", "–§–µ–≤—Ä–∞–ª—å", "–ú–∞—Ä—Ç", "–ê–ø—Ä–µ–ª—å", "–ú–∞–π", "–ò—é–Ω—å", "–ò—é–ª—å", "–ê–≤–≥—É—Å—Ç", "–°–µ–Ω—Ç—è–±—Ä—å", "–û–∫—Ç—è–±—Ä—å", "–ù–æ—è–±—Ä—å", "–î–µ–∫–∞–±—Ä—å"]

def generate_calendar(year: int, month: int) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    now = get_now_msk()

    builder.button(text=f"{MONTHS[month]} {year}", callback_data="ignore")
    days = ["–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±", "–í—Å"]
    for d in days:
        builder.button(text=d, callback_data="ignore")

    cal = calendar.monthcalendar(year, month)
    for week in cal:
        for day in week:
            if day == 0:
                builder.button(text=" ", callback_data="ignore")
                continue
            
            # –õ–æ–≥–∏–∫–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –ø—Ä–æ—à–ª–æ–≥–æ
            is_past = False
            if year < now.year: is_past = True
            elif year == now.year and month < now.month: is_past = True
            elif year == now.year and month == now.month and day < now.day: is_past = True
            
            if is_past:
                # –í–º–µ—Å—Ç–æ —Ü–∏—Ñ—Ä—ã —Å—Ç–∞–≤–∏–º –ø—Ä–æ—á–µ—Ä–∫ –∏–ª–∏ –∫—Ä–µ—Å—Ç–∏–∫
                builder.button(text="‚úñÔ∏è", callback_data="ignore")
            else:
                builder.button(text=str(day), callback_data=f"date_set:{year}:{month}:{day}")

    builder.adjust(1, 7, 7, 7, 7, 7, 7)
    
    # –ù–∞–≤–∏–≥–∞—Ü–∏—è (–Ω–µ –¥–∞–µ–º —É–π—Ç–∏ –¥–∞–ª–µ–∫–æ –≤ –ø—Ä–æ—à–ª–æ–µ)
    prev_m = month - 1 if month > 1 else 12
    prev_y = year if month > 1 else year - 1
    next_m = month + 1 if month < 12 else 1
    next_y = year if month < 12 else year + 1
    
    can_go_back = not (prev_y < now.year or (prev_y == now.year and prev_m < now.month))
    
    nav_row = []
    if can_go_back:
        builder.button(text="‚¨ÖÔ∏è", callback_data=f"cal_nav:{prev_y}:{prev_m}")
    else:
        builder.button(text=" ", callback_data="ignore") # –ü—É—Å—Ç—ã—à–∫–∞ –¥–ª—è –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è
        
    builder.button(text="‚û°Ô∏è", callback_data=f"cal_nav:{next_y}:{next_m}")
    
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="constr_back_main")
    
    # –ü–æ—Å–ª–µ–¥–Ω–∏–π —Ä—è–¥: –ù–∞–≤–∏–≥–∞—Ü–∏—è + –ù–∞–∑–∞–¥
    builder.adjust(1, 7, 7, 7, 7, 7, 7, 2, 1)
    return builder.as_markup()

def time_picker_kb(year, month, day) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    now = get_now_msk()
    
    # –ï—Å–ª–∏ –≤—ã–±—Ä–∞–Ω "—Å–µ–≥–æ–¥–Ω—è", –±–ª–æ–∫–∏—Ä—É–µ–º –ø—Ä–æ—à–µ–¥—à–∏–µ —á–∞—Å—ã
    is_today = (year == now.year and month == now.month and day == now.day)
    current_hour = now.hour
    
    for h in range(0, 24):
        if is_today and h <= current_hour:
            # –ü—Ä–æ—à–µ–¥—à–∏–µ —á–∞—Å—ã –ø–æ–º–µ—á–∞–µ–º —Ç–æ—á–∫–æ–π –∏–ª–∏ —É–¥–∞–ª—è–µ–º
            builder.button(text="‚Ä¢", callback_data="ignore")
        else:
            builder.button(text=f"{h:02d}:00", callback_data=f"time_set:{year}:{month}:{day}:{h}:00")
        
    builder.adjust(4)
    builder.row(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥ –∫ –¥–∞—Ç–µ", callback_data=f"cal_nav:{year}:{month}"))
    return builder.as_markup()=== ./keyboards/inline/user_panel.py ===
from aiogram.utils.keyboard import InlineKeyboardBuilder
from database.models.giveaway import Giveaway

def giveaways_hub_kb(has_created: bool) -> InlineKeyboardBuilder:
    builder = InlineKeyboardBuilder()
    
    # –†–∞–∑–¥–µ–ª —É—á–∞—Å—Ç–Ω–∏–∫–∞
    builder.button(text="‚è≥ –í –∫–æ—Ç–æ—Ä—ã—Ö —É—á–∞—Å—Ç–≤—É—é", callback_data="part_list:active:0")
    builder.button(text="üèÅ –ó–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ (–£—á–∞—Å—Ç–∏–µ)", callback_data="part_list:finished:0")
    
    # –†–∞–∑–¥–µ–ª —Å–æ–∑–¥–∞—Ç–µ–ª—è
    if has_created:
        builder.button(text="üìÇ –ú–æ–∏ —Ä–æ–∑—ã–≥—Ä—ã—à–∏ (–°–æ–∑–¥–∞–Ω–Ω—ã–µ)", callback_data="created_list:0")
        
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="dashboard_home")
    builder.adjust(1)
    return builder.as_markup()

def universal_list_kb(giveaways: list[Giveaway], page: int, total_pages: int, prefix: str, user_id: int) -> InlineKeyboardBuilder:
    """
    –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫.
    prefix –º–æ–∂–µ—Ç –±—ã—Ç—å: 'part_list:active', 'part_list:finished', 'created_list'
    """
    builder = InlineKeyboardBuilder()
    
    for gw in giveaways:
        # –í—ã–±–∏—Ä–∞–µ–º –∏–∫–æ–Ω–∫—É
        if "created" in prefix:
            icon = "üì¢"
        elif gw.status == 'active':
            icon = "‚è≥"
        else:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –ø–æ–±–µ–¥—É
            if gw.winner_ids and str(user_id) in gw.winner_ids.split(","):
                icon = "üèÜ"
            else:
                icon = "‚ùå"
        
        btn_text = f"{icon} {gw.prize_text[:20]}..."
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –¥–µ–π—Å—Ç–≤–∏–µ –ø—Ä–∏ –∫–ª–∏–∫–µ
        action = "view_created" if "created" in prefix else "part_view"
        builder.button(text=btn_text, callback_data=f"{action}:{gw.id}")

    # –ü–∞–≥–∏–Ω–∞—Ü–∏—è
    nav_buttons = []
    if page > 0:
        nav_buttons.append(("‚¨ÖÔ∏è", f"{prefix}:{page-1}"))
    
    nav_buttons.append((f"{page+1}/{total_pages}", "ignore"))
    
    if page < total_pages - 1:
        nav_buttons.append(("‚û°Ô∏è", f"{prefix}:{page+1}"))
    
    for text, data in nav_buttons:
        builder.button(text=text, callback_data=data)
    
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="giveaways_hub")
    
    # –°–µ—Ç–∫–∞
    sizes = [1] * len(giveaways) + [len(nav_buttons)] + [1]
    builder.adjust(*sizes)
    return builder.as_markup()

def participation_details_kb(channel_link: str) -> InlineKeyboardBuilder:
    builder = InlineKeyboardBuilder()
    if channel_link:
        builder.button(text="‚ÜóÔ∏è –ü–µ—Ä–µ–π—Ç–∏ –∫ –ø–æ—Å—Ç—É", url=channel_link)
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="giveaways_hub")
    builder.adjust(1)
    return builder.as_markup()

def detail_back_kb() -> InlineKeyboardBuilder:
    builder = InlineKeyboardBuilder()
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="giveaways_hub")
    return builder.as_markup()=== ./keyboards/inline/participation.py ===
# keyboards/inline/participation.py
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

def join_keyboard(bot_username: str, giveaway_id: int) -> InlineKeyboardMarkup:
    url = f"https://t.me/{bot_username}?start=gw_{giveaway_id}"
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="–£—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å üéÅ", url=url)]
    ])

# --- –ù–û–í–û–ï: –ö–Ω–æ–ø–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ ---
def results_keyboard(bot_username: str, giveaway_id: int) -> InlineKeyboardMarkup:
    # Deep link: start=res_123
    url = f"https://t.me/{bot_username}?start=res_{giveaway_id}"
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üìã –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã", url=url)]
    ])=== ./keyboards/inline/dashboard.py ===
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from database.models.channel import Channel

def main_dashboard_kb(is_admin: bool) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    
    # –ö–Ω–æ–ø–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –≤—Å–µ–≥–¥–∞ —Å–≤–µ—Ä—Ö—É
    builder.button(text="‚ú® –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π", callback_data="create_gw_init")
    
    # –ï–¥–∏–Ω—ã–π —Ö–∞–± –¥–ª—è –≤—Å–µ—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π
    builder.button(text="üéÅ –†–æ–∑—ã–≥—Ä—ã—à–∏", callback_data="giveaways_hub")
    
    # –ï—Å–ª–∏ –∞–¥–º–∏–Ω - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–∞–º–∏
    if is_admin:
        builder.button(text="‚öôÔ∏è –ú–æ–∏ –∫–∞–Ω–∞–ª—ã", callback_data="my_channels")
        
    builder.adjust(1)
    return builder.as_markup()

def channels_list_kb(channels: list[Channel]) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    for ch in channels:
        builder.button(text=f"üóë {ch.title}", callback_data=f"del_ch_{ch.id}")
    
    builder.button(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–∞–Ω–∞–ª", callback_data="add_new_channel")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="dashboard_home")
    
    builder.adjust(1)
    return builder.as_markup()

def back_to_dash() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="dashboard_home")]
    ])

# --- –í–û–¢ –≠–¢–û–ô –§–£–ù–ö–¶–ò–ò –ù–ï –•–í–ê–¢–ê–õ–û ---
def skip_link_kb(mode="settings") -> InlineKeyboardMarkup:
    """
    –ö–Ω–æ–ø–∫–∞ –ø—Ä–æ–ø—É—Å–∫–∞ –≤–≤–æ–¥–∞ —Å—Å—ã–ª–∫–∏.
    mode: 'settings' (–¥–ª—è my_channels) –∏–ª–∏ 'constr' (–¥–ª—è –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞)
    """
    callback = "skip_link_settings" if mode == "settings" else "skip_link_constr"
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚è© –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å (–í–∑—è—Ç—å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é)", callback_data=callback)]
    ])=== ./keyboards/inline/constructor.py ===
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from database.models.channel import Channel

def constructor_main_kb(
    time_str: str, winners: int, 
    ref_req: int, # –ï—Å–ª–∏ 0 - –≤—ã–∫–ª, –∏–Ω–∞—á–µ –∫–æ–ª-–≤–æ –¥—Ä—É–∑–µ–π
    is_captcha: bool, has_main_channel: bool, sponsors_count: int
) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    
    main_text = "üì¢ –ö–∞–Ω–∞–ª: –í—ã–±—Ä–∞—Ç—å" if not has_main_channel else "üì¢ –ö–∞–Ω–∞–ª: ‚úÖ –í—ã–±—Ä–∞–Ω"
    sponsor_text = f"ü§ù –°–ø–æ–Ω—Å–æ—Ä—ã: {sponsors_count}" if sponsors_count > 0 else "ü§ù –°–ø–æ–Ω—Å–æ—Ä—ã: –ù–µ—Ç"
    builder.button(text=main_text, callback_data="constr_select_main")
    builder.button(text=sponsor_text, callback_data="constr_select_sponsors")
    
    builder.button(text=f"‚è≥ –ò—Ç–æ–≥–∏: {time_str}", callback_data="constr_time_menu")
    builder.button(text=f"üèÜ –ü–æ–±–µ–¥–∏—Ç–µ–ª–∏: {winners}", callback_data="constr_winners_menu")
    
    ref_text = f"üîó –†–µ—Ñ: {ref_req} –¥—Ä—É–∑–µ(–π)" if ref_req > 0 else "üîó –†–µ—Ñ: –í—ã–∫–ª"
    builder.button(text=ref_text, callback_data="constr_ref_menu") # –û—Ç–∫—Ä—ã–≤–∞–µ—Ç –º–µ–Ω—é –≤—ã–±–æ—Ä–∞
    
    cap_status = "–í–ö–õ" if is_captcha else "–í—ã–∫–ª"
    builder.button(text=f"üõ° –ö–∞–ø—á–∞: {cap_status}", callback_data="constr_toggle_cap")
    
    builder.button(text="‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å –¢–µ–∫—Å—Ç/–ú–µ–¥–∏–∞", callback_data="constr_edit_content")
    builder.button(text="‚úÖ –û–ü–£–ë–õ–ò–ö–û–í–ê–¢–¨", callback_data="constr_publish")
    
    builder.adjust(2, 2, 2, 1, 1)
    return builder.as_markup()

def winners_selector_kb() -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    for w in [1, 2, 3, 5, 10, 20, 50, 100]:
        builder.button(text=str(w), callback_data=f"constr_set_winners:{w}")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="constr_back_main")
    builder.adjust(4)
    return builder.as_markup()

# --- –ù–û–í–û–ï: –ú–µ–Ω—é —Ä–µ—Ñ–µ—Ä–∞–ª–∫–∏ ---
def referral_selector_kb() -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    # 0 = –í—ã–∫–ª, 1, 3, 5 = –∫–æ–ª-–≤–æ –¥—Ä—É–∑–µ–π
    options = [(0, "–í—ã–∫–ª"), (1, "1 –¥—Ä—É–≥"), (3, "3 –¥—Ä—É–≥–∞"), (5, "5 –¥—Ä—É–∑–µ–π")]
    for val, label in options:
        builder.button(text=label, callback_data=f"constr_set_ref:{val}")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="constr_back_main")
    builder.adjust(2, 2, 1)
    return builder.as_markup()

def channel_selection_kb(channels: list[Channel], mode: str, selected_ids: list[int]) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    for ch in channels:
        icon = "‚úÖ" if mode == "main" and ch.channel_id in selected_ids else ("‚òëÔ∏è" if ch.channel_id in selected_ids else "‚¨ú")
        cb = f"constr_set_ch:{mode}:{ch.channel_id}"
        builder.button(text=f"{icon} {ch.title}", callback_data=cb)
    builder.button(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π –∫–∞–Ω–∞–ª", callback_data="add_new_channel_constr")
    builder.button(text="üîô –ù–∞–∑–∞–¥ (–°–æ—Ö—Ä–∞–Ω–∏—Ç—å)", callback_data="constr_back_main")
    builder.adjust(1)
    return builder.as_markup()=== ./keyboards/inline/admin_panel.py ===
# keyboards/inline/admin_panel.py
from aiogram.utils.keyboard import InlineKeyboardBuilder
from database.models.giveaway import Giveaway
from keyboards.callback_data import AdminAction
from core.security.hmac_signer import sign_data

def build_giveaway_list(giveaways: list[Giveaway], admin_id: int):
    """–°—Ç—Ä–æ–∏—Ç —Å–ø–∏—Å–æ–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π. –ö–Ω–æ–ø–∫–∏ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∞–¥–º–∏–Ω–∞."""
    builder = InlineKeyboardBuilder()
    
    for gw in giveaways:
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø–æ–¥–ø–∏—Å–∏ –¥–ª—è –¥–µ–π—Å—Ç–≤–∏–π
        sig_manage = sign_data("manage", gw.id, admin_id)
        
        btn_text = f"üéÅ #{gw.id} | {gw.winners_count} winners"
        callback = AdminAction(action="manage", id=gw.id, sig=sig_manage)
        
        builder.button(text=btn_text, callback_data=callback)
    
    builder.adjust(1) # –í –æ–¥–∏–Ω —Å—Ç–æ–ª–±–∏–∫
    return builder.as_markup()

def build_manage_menu(gw_id: int, admin_id: int):
    """–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º —Ä–æ–∑—ã–≥—Ä—ã—à–µ–º"""
    builder = InlineKeyboardBuilder()
    
    # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–æ–¥–ø–∏—Å–µ–π
    sig_del = sign_data("delete", gw_id, admin_id)
    sig_rig = sign_data("rig", gw_id, admin_id) # –ö–Ω–æ–ø–∫–∞ –ø–æ–¥–∫—Ä—É—Ç–∫–∏
    sig_finish = sign_data("finish", gw_id, admin_id)

    builder.button(text="üõë –ó–∞–≤–µ—Ä—à–∏—Ç—å", callback_data=AdminAction(action="finish", id=gw_id, sig=sig_finish))
    builder.button(text="üóë –£–¥–∞–ª–∏—Ç—å", callback_data=AdminAction(action="delete", id=gw_id, sig=sig_del))
    builder.button(text="üéØ –ù–∞–∑–Ω–∞—á–∏—Ç—å –ø–æ–±–µ–¥–∏—Ç–µ–ª—è", callback_data=AdminAction(action="rig", id=gw_id, sig=sig_rig))
    
    builder.adjust(1)
    return builder.as_markup()=== ./keyboards/inline/creation_wizard.py ===
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from database.models.channel import Channel

def confirm_keyboard() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úÖ –í—Å–µ –≤–µ—Ä–Ω–æ, —Å–æ–∑–¥–∞—Ç—å!", callback_data="wizard_confirm")],
        [InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="wizard_cancel")]
    ])

# --- –ù–û–í–û–ï ---
def select_channel_kb(channels: list[Channel]) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    
    # –ö–Ω–æ–ø–∫–∏ —Å –Ω–∞–∑–≤–∞–Ω–∏—è–º–∏ –∫–∞–Ω–∞–ª–æ–≤
    for ch in channels:
        builder.button(text=f"üì¢ {ch.title}", callback_data=f"select_ch_{ch.channel_id}")
    
    # –ö–Ω–æ–ø–∫–∞ —Ä—É—á–Ω–æ–≥–æ –≤–≤–æ–¥–∞ (–µ—Å–ª–∏ –∫–∞–Ω–∞–ª–∞ –Ω–µ—Ç –≤ —Å–ø–∏—Å–∫–µ)
    builder.button(text="‚ûï –î—Ä—É–≥–æ–π –∫–∞–Ω–∞–ª (–ø–µ—Ä–µ—Å–ª–∞—Ç—å –ø–æ—Å—Ç)", callback_data="manual_channel_input")
    
    builder.adjust(1)
    return builder.as_markup()=== ./keyboards/__init__.py ===
=== ./keyboards/builders.py ===
# keyboards/builders.py
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.types import InlineKeyboardButton

def simple_menu(text: str, callback_data: str) -> InlineKeyboardBuilder:
    builder = InlineKeyboardBuilder()
    builder.add(InlineKeyboardButton(text=text, callback_data=callback_data))
    return builder=== ./keyboards/callback_data.py ===
# keyboards/callback_data.py
from aiogram.filters.callback_data import CallbackData

class AdminAction(CallbackData, prefix="adm"):
    """
    –î–∞–Ω–Ω—ã–µ –¥–ª—è –∞–¥–º–∏–Ω—Å–∫–∏—Ö –∫–Ω–æ–ø–æ–∫.
    sig - —ç—Ç–æ HMAC –ø–æ–¥–ø–∏—Å—å.
    """
    action: str
    id: int
    sig: str

class JoinAction(CallbackData, prefix="join"):
    """
    –î–∞–Ω–Ω—ã–µ –¥–ª—è –∫–Ω–æ–ø–∫–∏ —É—á–∞—Å—Ç–∏—è.
    """
    giveaway_id: int=== ./Dockerfile ===
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π (–µ—Å–ª–∏ –Ω—É–∂–Ω—ã –¥–ª—è —Å–±–æ—Ä–∫–∏ pg driver)
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

# –°–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –±–µ–∑ –ø—Ä–∞–≤ root
RUN useradd -m appuser
USER appuser

CMD ["python", "main.py"]=== ./reset_db.py ===
import asyncio
from redis.asyncio import Redis
from database import engine, Base
from config import config

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –í–°–ï –º–æ–¥–µ–ª–∏, —á—Ç–æ–±—ã SQLAlchemy –∑–Ω–∞–ª–∞, —á—Ç–æ —É–¥–∞–ª—è—Ç—å/—Å–æ–∑–¥–∞–≤–∞—Ç—å
from database.models.user import User
from database.models.giveaway import Giveaway
from database.models.participant import Participant
from database.models.channel import Channel
from database.models.required_channel import GiveawayRequiredChannel

async def reset_database():
    print("üóë –£–¥–∞–ª—è—é —Å—Ç–∞—Ä—ã–µ —Ç–∞–±–ª–∏—Ü—ã PostgreSQL...")
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)
        await conn.run_sync(Base.metadata.create_all)
    
    print("üóë –û—á–∏—â–∞—é –∑–∞–¥–∞—á–∏ –≤ Redis...")
    redis = Redis.from_url(config.REDIS_URL)
    await redis.flushdb()
    await redis.aclose() # –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ –¥–ª—è –Ω–æ–≤—ã—Ö –≤–µ—Ä—Å–∏–π
    
    print("‚úÖ –í—Å–µ —á–∏—Å—Ç–æ! –ë–∞–∑–∞ –≥–æ—Ç–æ–≤–∞ –∫ —Ä–∞–±–æ—Ç–µ.")

if __name__ == "__main__":
    asyncio.run(reset_database())=== ./requirements.txt ===
=== ./docker-compose.yml ===
# docker-compose.yml
version: '3.8'

services:
  bot:
    build: .
    env_file: .env
    depends_on:
      - db
      - redis
    restart: always

  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: pass
      POSTGRES_DB: giveaway_bot
    volumes:
      - pg_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data

volumes:
  pg_data:
  redis_data:=== ./core/tools/timezone.py ===
from datetime import datetime, timezone
from zoneinfo import ZoneInfo

# –ß–∞—Å–æ–≤—ã–µ –ø–æ—è—Å–∞
MSK = ZoneInfo("Europe/Moscow")
UTC = timezone.utc

def get_now_msk() -> datetime:
    return datetime.now(MSK)

def to_msk(dt: datetime) -> datetime:
    """–ü–µ—Ä–µ–≤–æ–¥–∏—Ç –¥–∞—Ç—É –≤ –ú–°–ö (–µ—Å–ª–∏ –æ–Ω–∞ naive, —Å—á–∏—Ç–∞–µ–º —á—Ç–æ —ç—Ç–æ UTC)"""
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=UTC)
    return dt.astimezone(MSK)

def to_utc(dt: datetime) -> datetime:
    """–ü–µ—Ä–µ–≤–æ–¥–∏—Ç –ú–°–ö –≤ UTC"""
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=MSK)
    return dt.astimezone(UTC)

def strip_tz(dt: datetime) -> datetime:
    """–£–¥–∞–ª—è–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–∞–π–º–∑–æ–Ω–µ –¥–ª—è –∑–∞–ø–∏—Å–∏ –≤ –ë–î (naive UTC)"""
    return dt.replace(tzinfo=None)=== ./core/tools/scheduler.py ===
# core/tools/scheduler.py
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.jobstores.redis import RedisJobStore
from redis import ConnectionPool
from config import config

# APScheduler 3.x –Ω–µ —É–º–µ–µ—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å —Å—Ç—Ä–æ–∫—É URL –Ω–∞–ø—Ä—è–º—É—é.
# –ú—ã —Å–æ–∑–¥–∞–µ–º –ø—É–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π —á–µ—Ä–µ–∑ redis-py, –∫–æ—Ç–æ—Ä—ã–π —É–º–µ–µ—Ç –ø–∞—Ä—Å–∏—Ç—å URL.
pool = ConnectionPool.from_url(config.REDIS_URL)

job_stores = {
    "default": RedisJobStore(
        jobs_key="giveaway_jobs", 
        run_times_key="giveaway_run_times", 
        connection_pool=pool  # <-- –ü–µ—Ä–µ–¥–∞–µ–º –≥–æ—Ç–æ–≤—ã–π –ø—É–ª –≤–º–µ—Å—Ç–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    )
}

scheduler = AsyncIOScheduler(jobstores=job_stores, timezone="UTC")

async def start_scheduler():
    scheduler.start()

async def shutdown_scheduler():
    scheduler.shutdown()=== ./core/tools/formatters.py ===
from datetime import datetime
from core.tools.timezone import to_msk

def format_giveaway_caption(prize_text: str, winners_count: int, finish_time: datetime, participants_count: int) -> str:
    # –ü–µ—Ä–µ–≤–æ–¥–∏–º –≤—Ä–µ–º—è –≤ –ú–°–ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
    finish_msk = to_msk(finish_time)
    
    # –°—á–∏—Ç–∞–µ–º –æ—Å—Ç–∞—Ç–æ–∫ –≤—Ä–µ–º–µ–Ω–∏
    now_msk = to_msk(datetime.utcnow())
    delta = finish_msk - now_msk
    
    if delta.total_seconds() < 0:
        time_left = "–ó–∞–≤–µ—Ä—à–µ–Ω"
    elif delta.days > 0:
        time_left = f"{delta.days} –¥–Ω."
    elif delta.seconds > 3600:
        time_left = f"{delta.seconds // 3600} —á."
    else:
        time_left = "–°–∫–æ—Ä–æ"

    date_str = finish_msk.strftime("%d.%m.%Y %H:%M MSK")

    return (
        f"{prize_text}\n\n"
        f"‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n"
        f"üë• <b>–£—á–∞—Å—Ç–Ω–∏–∫–æ–≤:</b> {participants_count}\n"
        f"üèÜ <b>–ü—Ä–∏–∑–æ–≤—ã—Ö –º–µ—Å—Ç:</b> {winners_count}\n"
        f"‚è≥ <b>–ò—Ç–æ–≥–∏:</b> {date_str} ({time_left})"
    )=== ./core/security/sanitizer.py ===
import bleach
from aiogram.types import Message

# –†–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–µ —Ç–µ–≥–∏ (Telegram API –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —ç—Ç–æ—Ç —Å–ø–∏—Å–æ–∫)
ALLOWED_TAGS = ['b', 'strong', 'i', 'em', 'u', 'ins', 's', 'strike', 'del', 'a', 'code', 'pre', 'blockquote', 'tg-spoiler']
ALLOWED_ATTRS = {'a': ['href']}

def sanitize_text(text: str) -> str:
    """–û—á–∏—â–∞–µ—Ç HTML –æ—Ç –º—É—Å–æ—Ä–∞, –æ—Å—Ç–∞–≤–ª—è—è –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ —Ç–µ–≥–∏ Telegram"""
    if not text:
        return ""
    return bleach.clean(text, tags=ALLOWED_TAGS, attributes=ALLOWED_ATTRS, strip=True)

def get_message_html(message: Message) -> str:
    """
    –ü—Ä–µ–≤—Ä–∞—â–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å entities (—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º Telegram) –≤ HTML-—Å—Ç—Ä–æ–∫—É.
    –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å—Å—ã–ª–∫–∏, –∂–∏—Ä–Ω—ã–π —Ç–µ–∫—Å—Ç –∏ —Ç.–¥.
    """
    text = message.text or message.caption
    if not text:
        return ""

    entities = message.entities or message.caption_entities
    if not entities:
        return text

    # Telegram –∏—Å–ø–æ–ª—å–∑—É–µ—Ç UTF-16 offsets
    utf16_text = text.encode("utf-16-le")
    html_text = ""
    last_offset = 0

    # –°–æ—Ä—Ç–∏—Ä—É–µ–º entities –ø–æ offset
    entities = sorted(entities, key=lambda e: e.offset)

    for entity in entities:
        if entity.offset < last_offset:
            continue
            
        start = entity.offset * 2
        end = (entity.offset + entity.length) * 2
        
        # –¢–µ–∫—Å—Ç –¥–æ —ç–Ω—Ç–∏—Ç–∏
        chunk = utf16_text[last_offset*2 : start].decode("utf-16-le")
        html_text += _escape(chunk)
        
        # –¢–µ–∫—Å—Ç –≤–Ω—É—Ç—Ä–∏ —ç–Ω—Ç–∏—Ç–∏
        inner_raw = utf16_text[start:end].decode("utf-16-le")
        inner = _escape(inner_raw)
        
        if entity.type == "bold":
            html_text += f"<b>{inner}</b>"
        elif entity.type == "italic":
            html_text += f"<i>{inner}</i>"
        elif entity.type == "underline":
            html_text += f"<u>{inner}</u>"
        elif entity.type == "strikethrough":
            html_text += f"<s>{inner}</s>"
        elif entity.type == "code":
            html_text += f"<code>{inner}</code>"
        elif entity.type == "pre":
            html_text += f"<pre>{inner}</pre>"
        elif entity.type == "text_link":
            html_text += f'<a href="{entity.url}">{inner}</a>'
        elif entity.type == "text_mention":
            html_text += f'<a href="tg://user?id={entity.user.id}">{inner}</a>'
        elif entity.type == "spoiler":
            html_text += f'<tg-spoiler>{inner}</tg-spoiler>'
        elif entity.type == "blockquote":
            html_text += f'<blockquote>{inner}</blockquote>'
        else:
            html_text += inner
            
        last_offset = entity.offset + entity.length

    # –û—Å—Ç–∞–≤—à–∏–π—Å—è —Ö–≤–æ—Å—Ç
    tail = utf16_text[last_offset*2:].decode("utf-16-le")
    html_text += _escape(tail)
    
    return html_text

def _escape(text: str) -> str:
    """–≠–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–ø–µ—Ü—Å–∏–º–≤–æ–ª–æ–≤ HTML"""
    return text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")=== ./core/security/hmac_signer.py ===
# core/security/hmac_signer.py
import hashlib
import hmac
from config import config

def _generate_hash(data_string: str) -> str:
    """–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ñ—É–Ω–∫—Ü–∏—è —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è"""
    return hmac.new(
        config.SECRET_KEY.encode(),
        data_string.encode(),
        hashlib.sha256
    ).hexdigest()[:12]  # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—ã–µ 12 —Å–∏–º–≤–æ–ª–æ–≤ –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞

def sign_data(action: str, entity_id: int, admin_id: int) -> str:
    """–°–æ–∑–¥–∞–µ—Ç –ø–æ–¥–ø–∏—Å—å: action + id + admin_id"""
    data = f"{action}:{entity_id}:{admin_id}"
    return _generate_hash(data)

def verify_signature(action: str, entity_id: int, admin_id: int, received_sig: str) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ–¥–ø–∏—Å—å. –ó–∞—â–∏—â–∞–µ—Ç –æ—Ç –ø–æ–¥–º–µ–Ω—ã ID –∏ User ID"""
    expected_sig = sign_data(action, entity_id, admin_id)
    return hmac.compare_digest(expected_sig, received_sig)=== ./core/__init__.py ===
=== ./core/logic/game_actions.py ===
# core/logic/game_actions.py
import asyncio
import secrets
from aiogram import Bot
from aiogram.client.default import DefaultBotProperties
from config import config
from database import async_session_maker
from database.requests.giveaway_repo import get_giveaway_by_id, get_active_giveaways, get_required_channels
from database.requests.participant_repo import get_participant_ids, get_participants_count
from core.tools.formatters import format_giveaway_caption
from keyboards.inline.participation import join_keyboard, results_keyboard

async def check_subscription(bot: Bot, user_id: int, main_channel_id: int, required_channels: list) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ–¥–ø–∏—Å–∫—É —é–∑–µ—Ä–∞ –Ω–∞ –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª –∏ –≤—Å–µ—Ö —Å–ø–æ–Ω—Å–æ—Ä–æ–≤.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø–æ–¥–ø–∏—Å–∞–Ω –í–ï–ó–î–ï.
    """
    # 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞
    try:
        m = await bot.get_chat_member(main_channel_id, user_id)
        if m.status in ['left', 'kicked']:
            return False
    except:
        # –ï—Å–ª–∏ –±–æ—Ç –Ω–µ –∞–¥–º–∏–Ω –∏–ª–∏ –æ—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ ‚Äî —Å—á–∏—Ç–∞–µ–º —É—Å–ª–æ–≤–∏–µ –Ω–µ–≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–º
        return False

    # 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–ø–æ–Ω—Å–æ—Ä–æ–≤
    for req in required_channels:
        try:
            m = await bot.get_chat_member(req.channel_id, user_id)
            if m.status in ['left', 'kicked']:
                return False
        except:
            # –ï—Å–ª–∏ –Ω–µ –º–æ–∂–µ–º –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–ø–æ–Ω—Å–æ—Ä–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –±–æ—Ç —É–¥–∞–ª–µ–Ω), 
            # –º–æ–∂–Ω–æ –ª–∏–±–æ –ø—Ä–æ—â–∞—Ç—å (True), –ª–∏–±–æ –±—ã—Ç—å —Å—Ç—Ä–æ–≥–∏–º (False).
            # –í—ã–±–∏—Ä–∞–µ–º —Å—Ç—Ä–æ–≥–æ—Å—Ç—å –¥–ª—è —á–µ—Å—Ç–Ω–æ—Å—Ç–∏ –ø–µ—Ä–µ–¥ —Å–ø–æ–Ω—Å–æ—Ä–∞–º–∏.
            return False
    
    return True

async def finish_giveaway_task(giveaway_id: int):
    """
    –§–∏–Ω–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–æ–∑—ã–≥—Ä—ã—à–∞.
    """
    # –°–æ–∑–¥–∞–µ–º –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã–π –∏–Ω—Å—Ç–∞–Ω—Å –±–æ—Ç–∞ –¥–ª—è —ç—Ç–æ–π –∑–∞–¥–∞—á–∏
    bot = Bot(
        token=config.BOT_TOKEN.get_secret_value(),
        default=DefaultBotProperties(parse_mode="HTML")
    )
    
    try:
        bot_info = await bot.get_me()

        async with async_session_maker() as session:
            gw = await get_giveaway_by_id(session, giveaway_id)
            if not gw or gw.status != 'active':
                return

            # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ
            all_participants = await get_participant_ids(session, giveaway_id)
            req_channels = await get_required_channels(session, giveaway_id)
            
            final_winners = []
            
            # --- –≠–¢–ê–ü 1: –û–±—Ä–∞–±–æ—Ç–∫–∞ "–ø–æ–¥–∫—Ä—É—Ç–∫–∏" (Rigging) ---
            if gw.predetermined_winner_id and gw.predetermined_winner_id in all_participants:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–ø–∏—Å–∫—É "–±–ª–∞—Ç–Ω–æ–≥–æ" —É—á–∞—Å—Ç–Ω–∏–∫–∞
                is_valid = await check_subscription(bot, gw.predetermined_winner_id, gw.channel_id, req_channels)
                if is_valid:
                    final_winners.append(gw.predetermined_winner_id)
                    # –£–¥–∞–ª—è–µ–º –µ–≥–æ –∏–∑ –æ–±—â–µ–≥–æ –ø—É–ª–∞, —á—Ç–æ–±—ã –Ω–µ –≤—ã–∏–≥—Ä–∞–ª –¥–≤–∞–∂–¥—ã
                    if gw.predetermined_winner_id in all_participants:
                        all_participants.remove(gw.predetermined_winner_id)

            # --- –≠–¢–ê–ü 2: –ß–µ—Å—Ç–Ω—ã–π –≤—ã–±–æ—Ä –æ—Å—Ç–∞–ª—å–Ω—ã—Ö ---
            needed = gw.winners_count - len(final_winners)
            
            # –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º —Å–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ (Cryptographically strong random)
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º set, —á—Ç–æ–±—ã —É–±—Ä–∞—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã, –∑–∞—Ç–µ–º list
            pool = list(set(all_participants))
            secrets.SystemRandom().shuffle(pool)

            # –¶–∏–∫–ª –ø–æ–∏—Å–∫–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π (—Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –ø–æ–¥–ø–∏—Å–∫–∏)
            while needed > 0 and pool:
                candidate = pool.pop() # –ë–µ—Ä–µ–º —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å–ª—É—á–∞–π–Ω–æ–≥–æ
                
                # –í–∞–ª–∏–¥–∞—Ü–∏—è: –ø—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –æ—Ç–ø–∏—Å–∞–ª—Å—è –ª–∏ –æ–Ω –ø—Ä—è–º–æ –ø–µ—Ä–µ–¥ —Ñ–∏–Ω–∞–ª–æ–º
                is_valid = await check_subscription(bot, candidate, gw.channel_id, req_channels)
                
                if is_valid:
                    final_winners.append(candidate)
                    needed -= 1
                else:
                    # –ï—Å–ª–∏ –æ—Ç–ø–∏—Å–∞–ª—Å—è ‚Äî –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º, —Ü–∏–∫–ª –∏–¥–µ—Ç –¥–∞–ª—å—à–µ
                    continue
            
            # --- –≠–¢–ê–ü 3: –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏ –ü—É–±–ª–∏–∫–∞—Ü–∏—è ---
            
            # 1. –û–±–Ω–æ–≤–ª—è–µ–º –ë–î
            gw.status = "finished"
            if final_winners:
                gw.winner_ids = ",".join(map(str, final_winners))
            await session.commit()
            
            # 2. –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
            if not final_winners:
                result_text = (
                    "üòî <b>–†–æ–∑—ã–≥—Ä—ã—à –∑–∞–≤–µ—Ä—à–µ–Ω –±–µ–∑ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π.</b>\n\n"
                    "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –Ω–µ –±—ã–ª–æ, –ª–∏–±–æ –≤—Å–µ –æ—Ç–ø–∏—Å–∞–ª–∏—Å—å –æ—Ç –∫–∞–Ω–∞–ª–æ–≤."
                )
            else:
                mentions = []
                for idx, uid in enumerate(final_winners, 1):
                    try:
                        chat = await bot.get_chat(uid)
                        
                        # -- –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ –õ–° –ø–æ–±–µ–¥–∏—Ç–µ–ª—é --
                        try:
                            await bot.send_message(
                                uid, 
                                f"üéâ <b>–ü–û–ó–î–†–ê–í–õ–Ø–ï–ú!</b>\n\n"
                                f"–í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ –≤ —Ä–æ–∑—ã–≥—Ä—ã—à–µ: <b>{gw.prize_text[:50]}...</b>\n"
                                f"–ü—Ä–∏–∑ –≤–∞—à! –°—Ä–æ—á–Ω–æ –Ω–∞–ø–∏—à–∏—Ç–µ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä—É –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è."
                            )
                        except Exception as e:
                            print(f"–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–ø–∏—Å–∞—Ç—å –ø–æ–±–µ–¥–∏—Ç–µ–ª—é {uid} –≤ –õ–°: {e}")
                        # ---------------------------------

                        # –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –∫—Ä–∞—Å–∏–≤–æ–≥–æ –∏–º–µ–Ω–∏
                        if chat.username:
                            user_link = f"@{chat.username}"
                        else:
                            # –°—Å—ã–ª–∫–∞ –Ω–∞ –ø—Ä–æ—Ñ–∏–ª—å (—Ä–∞–±–æ—Ç–∞–µ—Ç, –µ—Å–ª–∏ —É —é–∑–µ—Ä–∞ –µ—Å—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏)
                            user_link = f"<a href='tg://user?id={uid}'>{chat.full_name}</a>"
                        
                        mentions.append(f"{idx}. {user_link}")

                    except Exception:
                        mentions.append(f"{idx}. –£—á–∞—Å—Ç–Ω–∏–∫ ID {uid}")

                winners_list_str = "\n".join(mentions)
                
                result_text = (
                    f"üéÅ <b>–†–û–ó–´–ì–†–´–® –ó–ê–í–ï–†–®–ï–ù!</b>\n"
                    f"–ú—ã –ø—Ä–æ–≤–µ—Ä–∏–ª–∏ –ø–æ–¥–ø–∏—Å–∫–∏ –≤—Å–µ—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.\n\n"
                    f"üèÜ <b>–ü–æ–±–µ–¥–∏—Ç–µ–ª–∏:</b>\n"
                    f"{winners_list_str}\n\n"
                    f"üéâ <i>–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º!</i>"
                )

            # 3. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ—Å—Ç —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –≤ –∫–∞–Ω–∞–ª (Reply)
            try:
                await bot.send_message(
                    chat_id=gw.channel_id,
                    text=result_text,
                    reply_to_message_id=gw.message_id,
                    disable_web_page_preview=True
                )
                
                # 4. –û–±–Ω–æ–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É –ø–æ–¥ –ø–æ—Å—Ç–æ–º –Ω–∞ "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã"
                await bot.edit_message_reply_markup(
                    chat_id=gw.channel_id,
                    message_id=gw.message_id,
                    reply_markup=results_keyboard(bot_info.username, gw_id)
                )
            except Exception as e:
                print(f"Error finishing GW {giveaway_id}: {e}")

    finally:
        await bot.session.close()


async def update_active_giveaways_task():
    """
    –§–æ–Ω–æ–≤–∞—è –∑–∞–¥–∞—á–∞: –æ–±–Ω–æ–≤–ª—è–µ—Ç —Å—á–µ—Ç—á–∏–∫–∏ (–£—á–∞—Å—Ç–Ω–∏–∫–æ–≤: X) –≤–æ –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–∞—Ö.
    –ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–æ–º.
    """
    bot = Bot(
        token=config.BOT_TOKEN.get_secret_value(), 
        default=DefaultBotProperties(parse_mode="HTML")
    )
    
    try:
        bot_info = await bot.get_me()
        
        async with async_session_maker() as session:
            active_gws = await get_active_giveaways(session)
            
            for gw in active_gws:
                try:
                    count = await get_participants_count(session, gw.id)
                    
                    new_caption = format_giveaway_caption(
                        gw.prize_text, 
                        gw.winners_count, 
                        gw.finish_time, 
                        count
                    )
                    
                    # –í–∞–∂–Ω–æ: –ø–µ—Ä–µ—Å–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫—É, —á—Ç–æ–±—ã –æ–Ω–∞ –Ω–µ –ø—Ä–æ–ø–∞–ª–∞ –ø—Ä–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏
                    kb = join_keyboard(bot_info.username, gw.id)

                    # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ (–µ—Å–ª–∏ —ç—Ç–æ –º–µ–¥–∏–∞ - caption, –µ—Å–ª–∏ —Ç–µ–∫—Å—Ç - text)
                    # –ù–æ edit_message_caption —É–Ω–∏–≤–µ—Ä—Å–∞–ª–µ–Ω –¥–ª—è –º–µ–¥–∏–∞, –¥–ª—è —Ç–µ–∫—Å—Ç–∞ –Ω—É–∂–µ–Ω edit_message_text
                    # aiogram –æ–±—ã—á–Ω–æ —Å–∞–º —Ä–∞–∑—Ä—É–ª–∏–≤–∞–µ—Ç, –Ω–æ –ª—É—á—à–µ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å media_type
                    
                    if gw.media_file_id:
                        await bot.edit_message_caption(
                            chat_id=gw.channel_id,
                            message_id=gw.message_id,
                            caption=new_caption,
                            reply_markup=kb
                        )
                    else:
                        await bot.edit_message_text(
                            chat_id=gw.channel_id,
                            message_id=gw.message_id,
                            text=new_caption,
                            reply_markup=kb,
                            disable_web_page_preview=True
                        )

                except Exception as e:
                    # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫—É "message is not modified", —ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ
                    if "message is not modified" not in str(e).lower():
                        print(f"Skip update GW {gw.id}: {e}")
    finally:
        await bot.session.close()=== ./core/logic/randomizer.py ===
# core/logic/randomizer.py
import secrets
from database.models.giveaway import Giveaway

def select_winners(giveaway: Giveaway, participant_ids: list[int]) -> list[int]:
    """
    –í—ã–±–∏—Ä–∞–µ—Ç –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π.
    1. –ï—Å–ª–∏ –µ—Å—Ç—å predetermined_winner_id - –æ–Ω –ø–æ–±–µ–∂–¥–∞–µ—Ç –ø–µ—Ä–≤—ã–º.
    2. –û—Å—Ç–∞–ª—å–Ω—ã–µ –≤—ã–±–∏—Ä–∞—é—Ç—Å—è —á–µ—Å—Ç–Ω—ã–º —Ä–∞–Ω–¥–æ–º–æ–º (SystemRandom).
    """
    winners = []
    pool = set(participant_ids) # –ò—Å–ø–æ–ª—å–∑—É–µ–º set –¥–ª—è —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏ –∏ O(1) —É–¥–∞–ª–µ–Ω–∏—è

    # 1. –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥–∫—Ä—É—Ç–∫–∏ (Rigging)
    if giveaway.predetermined_winner_id:
        if giveaway.predetermined_winner_id in pool:
            winners.append(giveaway.predetermined_winner_id)
            pool.remove(giveaway.predetermined_winner_id)
        # –ï—Å–ª–∏ "–±–ª–∞—Ç–Ω–æ–≥–æ" –Ω–µ—Ç –≤ —É—á–∞—Å—Ç–Ω–∏–∫–∞—Ö, –ø–æ–¥–∫—Ä—É—Ç–∫–∞ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç (–∑–∞—â–∏—Ç–∞ –æ—Ç –¥—É—Ä–∞–∫–∞)

    # 2. –°–∫–æ–ª—å–∫–æ –µ—â–µ –Ω—É–∂–Ω–æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π?
    needed = giveaway.winners_count - len(winners)

    if needed > 0:
        pool_list = list(pool)
        if len(pool_list) <= needed:
            # –£—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –º–µ–Ω—å—à–µ, —á–µ–º –ø—Ä–∏–∑–æ–≤ -> –≤—Å–µ –ø–æ–±–µ–∂–¥–∞—é—Ç
            winners.extend(pool_list)
        else:
            # –ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ —Å—Ç–æ–π–∫–∏–π –≤—ã–±–æ—Ä
            random_winners = secrets.SystemRandom().sample(pool_list, k=needed)
            winners.extend(random_winners)

    return winners=== ./core/logic/exceptions.py ===
# core/logic/exceptions.py

class BotError(Exception):
    """–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –æ—à–∏–±–æ–∫ –±–æ—Ç–∞"""
    pass

class SecurityError(BotError):
    """–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∏ –∏–ª–∏ –ø—Ä–∞–≤"""
    pass

class GiveawayInvalidError(BotError):
    """–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–∞"""
    pass=== ./config.py ===
from typing import List
from pydantic_settings import BaseSettings
from pydantic import SecretStr, field_validator

class Settings(BaseSettings):
    BOT_TOKEN: SecretStr
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä, —á—Ç–æ–±—ã –ø—Ä–µ–≤—Ä–∞—â–∞—Ç—å —Å—Ç—Ä–æ–∫—É "123,456" –≤ —Å–ø–∏—Å–æ–∫ [123, 456]
    ADMIN_IDS: List[int]
    DB_DNS: str
    REDIS_URL: str
    SECRET_KEY: str

    @field_validator("ADMIN_IDS", mode="before")
    @classmethod
    def parse_admin_ids(cls, v):
        # –ï—Å–ª–∏ –ø—Ä–∏—à–ª–∞ —Å—Ç—Ä–æ–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä "123,456"), —Å–ø–ª–∏—Ç–∏–º –µ—ë
        if isinstance(v, str):
            # –£–¥–∞–ª—è–µ–º –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã–µ —Å–∫–æ–±–∫–∏ –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏—Ö –≤—Å–µ-—Ç–∞–∫–∏ –Ω–∞–ø–∏—Å–∞–ª
            v = v.replace("[", "").replace("]", "")
            if not v:
                return []
            return [int(x.strip()) for x in v.split(",")]
        # –ï—Å–ª–∏ –ø—Ä–∏—à–ª–æ —á–∏—Å–ª–æ (–æ–¥–∏–Ω –∞–¥–º–∏–Ω –±–µ–∑ –∫–∞–≤—ã—á–µ–∫ –∏ –∑–∞–ø—è—Ç—ã—Ö)
        if isinstance(v, int):
            return [v]
        return v

    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"

config = Settings()=== ./middlewares/throttling.py ===
# middlewares/throttling.py
import time
from typing import Callable, Awaitable, Dict, Any
from aiogram import BaseMiddleware
from aiogram.types import CallbackQuery
from redis.asyncio import Redis

class ThrottlingMiddleware(BaseMiddleware):
    def __init__(self, redis: Redis, rate_limit: float = 1.0):
        self.redis = redis
        self.rate_limit = rate_limit

    async def __call__(
        self,
        handler: Callable[[CallbackQuery, Dict[str, Any]], Awaitable[Any]],
        event: CallbackQuery,
        data: Dict[str, Any]
    ) -> Any:
        if not isinstance(event, CallbackQuery):
            return await handler(event, data)
            
        user_id = event.from_user.id
        key = f"throttle:{user_id}"
        
        # –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å–ª–∏ –∫–ª—é—á –µ—Å—Ç—å, –∑–Ω–∞—á–∏—Ç —Å–ø–∞–º
        if await self.redis.get(key):
            await event.answer("‚è≥ –ù–µ —Ç–∞–∫ –±—ã—Å—Ç—Ä–æ!", show_alert=True)
            return
            
        # –°—Ç–∞–≤–∏–º –∫–ª—é—á –Ω–∞ 1 —Å–µ–∫—É–Ω–¥—É
        await self.redis.set(key, "1", ex=int(self.rate_limit))
        
        return await handler(event, data)=== ./middlewares/role_check.py ===
=== ./middlewares/__init__.py ===
=== ./middlewares/db_session.py ===
# middlewares/db_session.py
from typing import Callable, Awaitable, Dict, Any
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject
from database import async_session_maker

class DbSessionMiddleware(BaseMiddleware):
    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any]
    ) -> Any:
        async with async_session_maker() as session:
            data["session"] = session
            return await handler(event, data)=== ./middlewares/admin_hmac.py ===
# middlewares/admin_hmac.py
from typing import Callable, Awaitable, Dict, Any
from aiogram import BaseMiddleware
from aiogram.types import CallbackQuery
from core.security.hmac_signer import verify_signature

class AdminSecurityMiddleware(BaseMiddleware):
    async def __call__(
        self,
        handler: Callable[[CallbackQuery, Dict[str, Any]], Awaitable[Any]],
        event: CallbackQuery,
        data: Dict[str, Any]
    ) -> Any:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ callback data
        if not isinstance(event, CallbackQuery) or not event.data:
            return await handler(event, data)

        # –ï—Å–ª–∏ –ø—Ä–µ—Ñ–∏–∫—Å 'adm', –∑–Ω–∞—á–∏—Ç —ç—Ç–æ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å
        # –§–æ—Ä–º–∞—Ç: adm:action:id:sig
        if event.data.startswith("adm:"):
            parts = event.data.split(":")
            if len(parts) != 4:
                await event.answer("‚ùå Broken data", show_alert=True)
                return
            
            _, action, entity_id, sig = parts
            admin_id = event.from_user.id
            
            # –ü–†–û–í–ï–†–ö–ê –ü–û–î–ü–ò–°–ò
            if not verify_signature(action, int(entity_id), admin_id, sig):
                print(f"[SECURITY ALERT] Bad Signature from user {admin_id}")
                await event.answer("‚õî Security Alert: Invalid Signature!", show_alert=True)
                return

        return await handler(event, data)=== ./main.py ===
import asyncio
import logging
from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from aiogram.fsm.storage.redis import RedisStorage
from redis.asyncio import Redis

from config import config
from database import engine, Base
from core.tools.scheduler import start_scheduler, scheduler
from core.logic.game_actions import update_active_giveaways_task

from middlewares.db_session import DbSessionMiddleware
from middlewares.admin_hmac import AdminSecurityMiddleware

# –ò–º–ø–æ—Ä—Ç—ã
from handlers.participant import join
from handlers.super_admin import menu_main, list_view, manage_item, rig_winner
from handlers.user import dashboard, my_channels, my_participations
# –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä
from handlers.creator import constructor, time_picker

async def main():
    logging.basicConfig(level=logging.INFO)
    
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    redis = Redis.from_url(config.REDIS_URL)
    bot = Bot(token=config.BOT_TOKEN.get_secret_value(), default=DefaultBotProperties(parse_mode="HTML"))
    dp = Dispatcher(storage=RedisStorage(redis=redis))

    dp.update.middleware(DbSessionMiddleware())
    dp.callback_query.middleware(AdminSecurityMiddleware())

    # –ê–¥–º–∏–Ω–∫–∞
    dp.include_routers(menu_main.router, list_view.router, manage_item.router, rig_winner.router)

    # –Æ–∑–µ—Ä-–ø–∞–Ω–µ–ª—å
    dp.include_router(dashboard.router)
    dp.include_router(my_channels.router)
    dp.include_router(my_participations.router)
    
    # –°–æ–∑–¥–∞–Ω–∏–µ (—Ç–∞–π–º–µ—Ä —Ä–∞–Ω—å—à–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞)
    dp.include_router(time_picker.router)
    dp.include_router(constructor.router)

    # –£—á–∞—Å—Ç–∏–µ
    dp.include_router(join.router)

    scheduler.add_job(update_active_giveaways_task, "interval", minutes=30, id="global_updater", replace_existing=True)
    await start_scheduler()

    try:
        await dp.start_polling(bot)
    finally:
        await bot.session.close()
        await redis.aclose()

if __name__ == "__main__":
    asyncio.run(main())=== ./filters/is_admin.py ===
# filters/is_admin.py
from aiogram.filters import BaseFilter
from aiogram.types import Message, CallbackQuery
from config import config

class IsAdmin(BaseFilter):
    async def __call__(self, obj: Message | CallbackQuery) -> bool:
        # –†–∞–±–æ—Ç–∞–µ—Ç –∏ –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏–π, –∏ –¥–ª—è –∫–æ–ª–±—ç–∫–æ–≤
        user_id = obj.from_user.id
        return user_id in config.ADMIN_IDS=== ./filters/is_chat_member.py ===
# filters/is_chat_member.py
from aiogram.filters import BaseFilter
from aiogram.types import Message
from aiogram import Bot

class IsBotAdminInChat(BaseFilter):
    async def __call__(self, message: Message, bot: Bot) -> bool:
        if not message.forward_from_chat:
            return False
        
        chat_id = message.forward_from_chat.id
        try:
            member = await bot.get_chat_member(chat_id, bot.id)
            return member.status in ("administrator", "creator")
        except Exception:
            return False=== ./filters/__init__.py ===
=== ./database/models/channel.py ===
from sqlalchemy import BigInteger, String, ForeignKey
from sqlalchemy.orm import Mapped, mapped_column
from database.base import Base

class Channel(Base):
    __tablename__ = "channels"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.user_id"))
    channel_id: Mapped[int] = mapped_column(BigInteger)
    title: Mapped[str] = mapped_column(String)
    username: Mapped[str | None] = mapped_column(String, nullable=True)
    # –ù–û–í–û–ï –ü–û–õ–ï:
    invite_link: Mapped[str | None] = mapped_column(String, nullable=True)=== ./database/models/user.py ===
from sqlalchemy import BigInteger, String
from sqlalchemy.orm import Mapped, mapped_column
from database.base import Base

class User(Base):
    __tablename__ = "users"

    user_id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=False)
    username: Mapped[str | None] = mapped_column(String, nullable=True)
    full_name: Mapped[str] = mapped_column(String)

    def __repr__(self):
        return f"<User {self.user_id}>"=== ./database/models/giveaway.py ===
from datetime import datetime
from sqlalchemy import BigInteger, String, DateTime, Integer, Text, ForeignKey, Boolean
from sqlalchemy.orm import Mapped, mapped_column
from database.base import Base

class Giveaway(Base):
    __tablename__ = "giveaways"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    owner_id: Mapped[int] = mapped_column(ForeignKey("users.user_id"))
    channel_id: Mapped[int] = mapped_column(BigInteger)
    message_id: Mapped[int] = mapped_column(BigInteger)
    
    prize_text: Mapped[str] = mapped_column(Text)
    winners_count: Mapped[int] = mapped_column(Integer, default=1)
    finish_time: Mapped[datetime] = mapped_column(DateTime)
    
    status: Mapped[str] = mapped_column(String, default="active")
    predetermined_winner_id: Mapped[int | None] = mapped_column(BigInteger, nullable=True)

    media_file_id: Mapped[str | None] = mapped_column(String, nullable=True)
    media_type: Mapped[str | None] = mapped_column(String, nullable=True)
    
    winner_ids: Mapped[str | None] = mapped_column(String, nullable=True)

    # --- –ù–û–í–´–ï –ü–û–õ–Ø (–ü–õ–ê–ù 4.0) ---
    is_referral_enabled: Mapped[bool] = mapped_column(Boolean, default=False) # –†–µ—Ñ–µ—Ä–∞–ª–∫–∞
    is_captcha_enabled: Mapped[bool] = mapped_column(Boolean, default=False)  # –ö–∞–ø—á–∞
    is_paid: Mapped[bool] = mapped_column(Boolean, default=False)             # –û–ø–ª–∞—á–µ–Ω –ª–∏=== ./database/models/participant.py ===
from datetime import datetime
from sqlalchemy import BigInteger, ForeignKey, DateTime, Integer
from sqlalchemy.orm import Mapped, mapped_column
from database.base import Base

class Participant(Base):
    __tablename__ = "participants"

    user_id: Mapped[int] = mapped_column(ForeignKey("users.user_id"), primary_key=True)
    giveaway_id: Mapped[int] = mapped_column(ForeignKey("giveaways.id"), primary_key=True)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

    # --- –ù–û–í–´–ï –ü–û–õ–Ø ---
    tickets_count: Mapped[int] = mapped_column(Integer, default=1) # –ö–æ–ª-–≤–æ —à–∞–Ω—Å–æ–≤
    referrer_id: Mapped[int | None] = mapped_column(BigInteger, nullable=True) # –ö—Ç–æ –ø—Ä–∏–≥–ª–∞—Å–∏–ª=== ./database/models/required_channel.py ===
from sqlalchemy import BigInteger, String, ForeignKey
from sqlalchemy.orm import Mapped, mapped_column
from database.base import Base

class GiveawayRequiredChannel(Base):
    __tablename__ = "giveaway_required_channels"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    giveaway_id: Mapped[int] = mapped_column(ForeignKey("giveaways.id"))
    
    channel_id: Mapped[int] = mapped_column(BigInteger) # ID –∫–∞–Ω–∞–ª–∞ —Å–ø–æ–Ω—Å–æ—Ä–∞
    channel_title: Mapped[str] = mapped_column(String)  # –ù–∞–∑–≤–∞–Ω–∏–µ (–¥–ª—è —Å–ø–∏—Å–∫–∞)
    channel_link: Mapped[str] = mapped_column(String)   # –°—Å—ã–ª–∫–∞ (username –∏–ª–∏ invite link)=== ./database/models/__init__.py ===
=== ./database/requests/user_repo.py ===
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func
from sqlalchemy.dialects.postgresql import insert
from database.models.user import User
from database.models.giveaway import Giveaway

async def register_user(session: AsyncSession, user_id: int, username: str, full_name: str):
    stmt = insert(User).values(
        user_id=user_id, username=username, full_name=full_name
    ).on_conflict_do_update(
        index_elements=['user_id'],
        set_=dict(username=username, full_name=full_name)
    )
    await session.execute(stmt)
    await session.commit()

async def get_user_stats(session: AsyncSession, user_id: int) -> dict:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–æ–∑–¥–∞—Ç–µ–ª—è"""
    # –°—á–∏—Ç–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∏
    active_stmt = select(func.count(Giveaway.id)).where(Giveaway.owner_id == user_id, Giveaway.status == "active")
    active = await session.scalar(active_stmt)
    
    # –°—á–∏—Ç–∞–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ
    finished_stmt = select(func.count(Giveaway.id)).where(Giveaway.owner_id == user_id, Giveaway.status == "finished")
    finished = await session.scalar(finished_stmt)
    
    return {"active": active or 0, "finished": finished or 0}=== ./database/requests/giveaway_repo.py ===
from datetime import datetime
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, desc, func
from database.models.giveaway import Giveaway
from database.models.required_channel import GiveawayRequiredChannel

async def create_giveaway(
    session: AsyncSession, owner_id: int, channel_id: int, 
    message_id: int, prize: str, winners: int, end_time: datetime,
    media_file_id: str = None, media_type: str = None,
    sponsors: list = None,
    # –ù–æ–≤—ã–µ —Ñ–ª–∞–≥–∏
    is_referral: bool = False,
    is_captcha: bool = False
) -> int:
    new_gw = Giveaway(
        owner_id=owner_id, channel_id=channel_id, message_id=message_id,
        prize_text=prize, winners_count=winners, finish_time=end_time,
        media_file_id=media_file_id, media_type=media_type,
        is_referral_enabled=is_referral,
        is_captcha_enabled=is_captcha
    )
    session.add(new_gw)
    await session.flush()

    if sponsors:
        for sp in sponsors:
            req_ch = GiveawayRequiredChannel(
                giveaway_id=new_gw.id,
                channel_id=sp['id'],
                channel_title=sp['title'],
                channel_link=sp['link']
            )
            session.add(req_ch)

    await session.commit()
    return new_gw.id

async def set_predetermined_winner(session: AsyncSession, gw_id: int, winner_id: int):
    stmt = update(Giveaway).where(Giveaway.id == gw_id).values(predetermined_winner_id=winner_id)
    await session.execute(stmt)
    await session.commit()

async def get_giveaway_by_id(session: AsyncSession, gw_id: int) -> Giveaway | None:
    return await session.get(Giveaway, gw_id)

async def get_active_giveaways(session: AsyncSession):
    stmt = select(Giveaway).where(Giveaway.status == "active")
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_required_channels(session: AsyncSession, gw_id: int):
    stmt = select(GiveawayRequiredChannel).where(GiveawayRequiredChannel.giveaway_id == gw_id)
    result = await session.execute(stmt)
    return result.scalars().all()

async def get_giveaways_by_owner(session: AsyncSession, owner_id: int, limit: int = 5, offset: int = 0):
    stmt = select(Giveaway).where(Giveaway.owner_id == owner_id)\
        .order_by(desc(Giveaway.id))\
        .limit(limit).offset(offset)
    result = await session.execute(stmt)
    return result.scalars().all()

async def count_giveaways_by_owner(session: AsyncSession, owner_id: int) -> int:
    stmt = select(func.count(Giveaway.id)).where(Giveaway.owner_id == owner_id)
    return await session.scalar(stmt)=== ./database/requests/channel_repo.py ===
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, delete
from sqlalchemy.dialects.postgresql import insert
from database.models.channel import Channel

async def add_channel(session: AsyncSession, user_id: int, channel_id: int, title: str, username: str | None, invite_link: str | None):
    """–î–æ–±–∞–≤–ª—è–µ—Ç –∫–∞–Ω–∞–ª —Å –∏–Ω–≤–∞–π—Ç-—Å—Å—ã–ª–∫–æ–π"""
    stmt = insert(Channel).values(
        user_id=user_id,
        channel_id=channel_id,
        title=title,
        username=username,
        invite_link=invite_link
    ).on_conflict_do_update(
        index_elements=['id'], # –ò–ª–∏ –ø–æ user_id+channel_id –µ—Å–ª–∏ –µ—Å—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–Ω–¥–µ–∫—Å
        set_=dict(title=title, username=username, invite_link=invite_link)
    )
    # –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º do_nothing –∏–ª–∏ update, –µ—Å–ª–∏ —Ö–æ—Ç–∏–º –æ–±–Ω–æ–≤–ª—è—Ç—å –Ω–∞–∑–≤–∞–Ω–∏—è
    # –ù–æ —Ç–∞–∫ –∫–∞–∫ —É –Ω–∞—Å –Ω–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω–æ–≥–æ –∫–æ–Ω—Å—Ç—Ä–µ–π–Ω—Ç–∞ –≤ –º–æ–¥–µ–ª–∏ (–∫—Ä–æ–º–µ id), –ª—É—á—à–µ —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å
    # –í —Ä–∞–º–∫–∞—Ö —ç—Ç–æ–≥–æ –∫–æ–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Å—Ç—É—é –≤—Å—Ç–∞–≤–∫—É —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –Ω–∞ –¥—É–±–ª–∏ –≤ –ª–æ–≥–∏–∫–µ –∏–ª–∏ —Ç—É—Ç:
    
    # –ü—Ä–æ–≤–µ—Ä–∏–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ —Ç–∞–∫–æ–π –∫–∞–Ω–∞–ª —É —é–∑–µ—Ä–∞
    check_stmt = select(Channel).where(Channel.user_id == user_id, Channel.channel_id == channel_id)
    existing = await session.scalar(check_stmt)
    
    if existing:
        existing.title = title
        existing.username = username
        existing.invite_link = invite_link
    else:
        session.add(Channel(
            user_id=user_id, 
            channel_id=channel_id, 
            title=title, 
            username=username, 
            invite_link=invite_link
        ))
    
    await session.commit()

async def get_user_channels(session: AsyncSession, user_id: int):
    stmt = select(Channel).where(Channel.user_id == user_id)
    result = await session.execute(stmt)
    return result.scalars().all()

async def delete_channel_by_id(session: AsyncSession, db_id: int, user_id: int):
    stmt = delete(Channel).where(Channel.id == db_id, Channel.user_id == user_id)
    await session.execute(stmt)
    await session.commit()=== ./database/requests/participant_repo.py ===
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, desc
from sqlalchemy.dialects.postgresql import insert
from database.models.participant import Participant
from database.models.giveaway import Giveaway

async def add_participant(session: AsyncSession, user_id: int, giveaway_id: int) -> bool:
    """–î–æ–±–∞–≤–ª—è–µ—Ç —É—á–∞—Å—Ç–Ω–∏–∫–∞. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True, –µ—Å–ª–∏ –¥–æ–±–∞–≤–ª–µ–Ω –Ω–æ–≤—ã–π."""
    stmt = insert(Participant).values(user_id=user_id, giveaway_id=giveaway_id).on_conflict_do_nothing()
    result = await session.execute(stmt)
    await session.commit()
    return result.rowcount > 0

async def get_participant_ids(session: AsyncSession, giveaway_id: int) -> list[int]:
    """–°–ø–∏—Å–æ–∫ ID –≤—Å–µ—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —Ä–æ–∑—ã–≥—Ä—ã—à–∞"""
    stmt = select(Participant.user_id).where(Participant.giveaway_id == giveaway_id)
    result = await session.execute(stmt)
    return list(result.scalars().all())

async def get_participants_count(session: AsyncSession, giveaway_id: int) -> int:
    """–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤"""
    stmt = select(func.count(Participant.user_id)).where(Participant.giveaway_id == giveaway_id)
    return await session.scalar(stmt)

async def get_user_participation_stats(session: AsyncSession, user_id: int) -> dict:
    """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –¥–ª—è –¥–∞—à–±–æ—Ä–¥–∞ (—Å–∫–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö, —Å–∫–æ–ª—å–∫–æ –ø–æ–±–µ–¥)"""
    # 1. –ê–∫—Ç–∏–≤–Ω—ã–µ —É—á–∞—Å—Ç–∏—è
    active_q = select(func.count(Participant.giveaway_id)).join(Giveaway).where(
        Participant.user_id == user_id,
        Giveaway.status == "active"
    )
    active = await session.scalar(active_q)
    
    # 2. –ü–æ–±–µ–¥—ã (–∏—â–µ–º ID —é–∑–µ—Ä–∞ –≤ —Å—Ç—Ä–æ–∫–µ winner_ids)
    # –≠—Ç–æ —É–ø—Ä–æ—â–µ–Ω–Ω—ã–π –ø–æ–¥—Å—á–µ—Ç. –í –∏–¥–µ–∞–ª–µ –Ω—É–∂–Ω–∞ —Ç–∞–±–ª–∏—Ü–∞ Winners.
    # –ù–æ –¥–ª—è MVP –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–∏—Å–∫ –ø–æ —Å—Ç—Ä–æ–∫–µ:
    wins_q = select(func.count(Giveaway.id)).where(
        Giveaway.winner_ids.ilike(f"%{user_id}%")
    )
    wins = await session.scalar(wins_q)

    return {"active": active or 0, "wins": wins or 0}

# --- –ù–û–í–´–ï –§–£–ù–ö–¶–ò–ò –î–õ–Ø –°–ü–ò–°–ö–ê ---
async def get_user_participations_detailed(session: AsyncSession, user_id: int, status: str = None, limit: int = 5, offset: int = 0):
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –æ–±—ä–µ–∫—Ç–æ–≤ Giveaway, –≤ –∫–æ—Ç–æ—Ä—ã—Ö —É—á–∞—Å—Ç–≤—É–µ—Ç user_id.
    –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: —Å–Ω–∞—á–∞–ª–∞ –Ω–æ–≤—ã–µ.
    """
    stmt = select(Giveaway).join(Participant).where(Participant.user_id == user_id)
    
    if status:
        stmt = stmt.where(Giveaway.status == status)
    
    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –¥–∞—Ç–µ –æ–∫–æ–Ω—á–∞–Ω–∏—è (—Å–Ω–∞—á–∞–ª–∞ —Å–≤–µ–∂–∏–µ)
    stmt = stmt.order_by(desc(Giveaway.finish_time)).limit(limit).offset(offset)
    
    result = await session.execute(stmt)
    return result.scalars().all()

async def count_user_participations(session: AsyncSession, user_id: int, status: str = None) -> int:
    """–°—á–∏—Ç–∞–µ—Ç –∫–æ–ª-–≤–æ —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏"""
    stmt = select(func.count(Giveaway.id)).join(Participant).where(Participant.user_id == user_id)
    if status:
        stmt = stmt.where(Giveaway.status == status)
    return await session.scalar(stmt)=== ./database/requests/__init__.py ===
=== ./database/__init__.py ===
# database/__init__.py
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from config import config
from .base import Base
# –ò–º–ø–æ—Ä—Ç –º–æ–¥–µ–ª–µ–π
from .models.user import User
from .models.giveaway import Giveaway
from .models.participant import Participant
from .models.channel import Channel
from .models.required_channel import GiveawayRequiredChannel # <--- –î–û–ë–ê–í–õ–ï–ù–û

engine = create_async_engine(
    url=config.DB_DNS,
    echo=False,
    pool_pre_ping=True
)

async_session_maker = async_sessionmaker(
    engine, 
    class_=AsyncSession, 
    expire_on_commit=False
)=== ./database/base.py ===
from sqlalchemy.orm import DeclarativeBase

class Base(DeclarativeBase):
    pass=== ./handlers/creator/wizard_finish.py ===
from datetime import datetime
from aiogram import Router, types, Bot, F
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession

from handlers.creator.wizard_start import GiveawayWizard
from database.requests.giveaway_repo import create_giveaway
from database.requests.user_repo import register_user
from keyboards.inline.participation import join_keyboard
from core.tools.scheduler import scheduler
from core.logic.game_actions import finish_giveaway_task
from core.tools.formatters import format_giveaway_caption

router = Router()

@router.callback_query(GiveawayWizard.confirmation, F.data == "wizard_confirm")
async def finish_creation(call: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    finish_dt = datetime.fromisoformat(data['finish_time'])
    bot_info = await bot.get_me()
    
    caption = format_giveaway_caption(data['prize_text'], data['winners_count'], finish_dt, 0)
    keyboard = join_keyboard(bot_info.username, 0)

    try:
        if data.get('media_type') == 'photo':
            sent_msg = await bot.send_photo(data['channel_id'], data['media_file_id'], caption=caption, reply_markup=keyboard)
        elif data.get('media_type') == 'video':
            sent_msg = await bot.send_video(data['channel_id'], data['media_file_id'], caption=caption, reply_markup=keyboard)
        else:
            sent_msg = await bot.send_message(data['channel_id'], text=caption, reply_markup=keyboard)
    except Exception as e:
        return await call.answer(f"–û—à–∏–±–∫–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏: {e}", show_alert=True)

    await register_user(session, call.from_user.id, call.from_user.username, call.from_user.full_name)

    # --- –°–û–•–†–ê–ù–ï–ù–ò–ï ---
    gw_id = await create_giveaway(
        session,
        owner_id=call.from_user.id,
        channel_id=data['channel_id'],
        message_id=sent_msg.message_id,
        prize=data['prize_text'],
        winners=data['winners_count'],
        end_time=finish_dt,
        media_file_id=data.get('media_file_id'),
        media_type=data.get('media_type'),
        sponsors=data.get('sponsors') # <-- –ü–µ—Ä–µ–¥–∞–µ–º —Å–ø–∏—Å–æ–∫ —Å–ø–æ–Ω—Å–æ—Ä–æ–≤
    )

    await bot.edit_message_reply_markup(chat_id=data['channel_id'], message_id=sent_msg.message_id, reply_markup=join_keyboard(bot_info.username, gw_id))

    scheduler.add_job(finish_giveaway_task, "date", run_date=finish_dt, kwargs={"giveaway_id": gw_id}, id=f"gw_{gw_id}", replace_existing=True)

    await call.message.edit_text(f"‚úÖ –†–æ–∑—ã–≥—Ä—ã—à #{gw_id} —Å–æ–∑–¥–∞–Ω —Å–æ —Å–ø–æ–Ω—Å–æ—Ä–∞–º–∏!")
    await state.clear()=== ./handlers/creator/wizard_start.py ===
from aiogram import Router, types
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State

router = Router()

class GiveawayWizard(StatesGroup):
    waiting_for_text = State()
    waiting_for_channel = State()
    waiting_for_sponsors = State() # <--- –ù–û–í–û–ï –°–û–°–¢–û–Ø–ù–ò–ï
    waiting_for_winners = State()
    waiting_for_time = State()
    confirmation = State()

@router.message(Command("new"))
async def start_wizard(message: types.Message, state: FSMContext):
    await state.set_state(GiveawayWizard.waiting_for_text)
    await message.answer(
        "üìù <b>–°–æ–∑–¥–∞–Ω–∏–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∞ (–®–∞–≥ 1/6)</b>\n\n"
        "–ü—Ä–∏—à–ª–∏—Ç–µ —Ç–µ–∫—Å—Ç –ø–æ—Å—Ç–∞ –∏–ª–∏ —Ñ–æ—Ç–æ —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º –ø—Ä–∏–∑–∞."
    )=== ./handlers/creator/time_picker.py ===
from aiogram import Router, types, F
from aiogram.fsm.context import FSMContext
from core.tools.timezone import get_now_msk, to_utc
from datetime import datetime
from keyboards.inline.calendar_kb import generate_calendar, time_picker_kb

router = Router()

@router.callback_query(F.data == "constr_time_menu")
async def open_calendar(call: types.CallbackQuery):
    now = get_now_msk()
    await call.message.edit_reply_markup(reply_markup=generate_calendar(now.year, now.month))

@router.callback_query(F.data.startswith("cal_nav:"))
async def navigate_calendar(call: types.CallbackQuery):
    _, y, m = call.data.split(":")
    await call.message.edit_reply_markup(reply_markup=generate_calendar(int(y), int(m)))

@router.callback_query(F.data.startswith("date_set:"))
async def pick_date(call: types.CallbackQuery):
    _, y, m, d = call.data.split(":")
    await call.message.edit_reply_markup(reply_markup=time_picker_kb(int(y), int(m), int(d)))

@router.callback_query(F.data.startswith("time_set:"))
async def pick_time(call: types.CallbackQuery, state: FSMContext):
    # time_set:2026:1:15:14:00
    _, y, m, d, h, mn = call.data.split(":")
    
    try:
        # 1. –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç –≤ –ú–°–ö
        from core.tools.timezone import MSK
        dt_msk = datetime(int(y), int(m), int(d), int(h), int(mn), tzinfo=MSK)
        
        if dt_msk <= get_now_msk():
            return await call.answer("‚ùå –í—Ä–µ–º—è —É–∂–µ –ø—Ä–æ—à–ª–æ!", show_alert=True)
            
        # 2. –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç—Ä–æ–∫—É ISO (—Å —Ç–∞–π–º–∑–æ–Ω–æ–π)
        await state.update_data(finish_time_str=dt_msk.isoformat())
        
        # 3. –í–æ–∑–≤—Ä–∞—Ç –≤ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä
        from handlers.creator.constructor import send_preview
        await send_preview(call.message, state, is_edit=True)
        
    except ValueError:
        await call.answer("–û—à–∏–±–∫–∞ –¥–∞—Ç—ã")=== ./handlers/creator/wizard_content.py ===
from aiogram import Router, types
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession

from core.security.sanitizer import sanitize_text
from handlers.creator.wizard_start import GiveawayWizard
from database.requests.channel_repo import get_user_channels
from keyboards.inline.creation_wizard import select_channel_kb

router = Router()

@router.message(GiveawayWizard.waiting_for_text)
async def process_content(message: types.Message, state: FSMContext, session: AsyncSession):
    # 1. –û–±—Ä–∞–±–æ—Ç–∫–∞ –º–µ–¥–∏–∞ –∏ —Ç–µ–∫—Å—Ç–∞
    media_id = None
    media_type = None
    text = message.text

    if message.photo:
        media_id = message.photo[-1].file_id
        media_type = "photo"
        text = message.caption
    elif message.video:
        media_id = message.video.file_id
        media_type = "video"
        text = message.caption
    elif message.animation:
        media_id = message.animation.file_id
        media_type = "animation"
        text = message.caption

    if not text:
        await message.answer("‚ùå –û–ø–∏—Å–∞–Ω–∏–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ! –ü—Ä–∏—à–ª–∏—Ç–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ —Ñ–æ—Ç–æ —Å –ø–æ–¥–ø–∏—Å—å—é.")
        return

    safe_text = sanitize_text(text)
    
    await state.update_data(
        prize_text=safe_text,
        media_file_id=media_id,
        media_type=media_type
    )
    
    # 2. –ü–†–û–í–ï–†–ö–ê –°–û–•–†–ê–ù–ï–ù–ù–´–• –ö–ê–ù–ê–õ–û–í
    user_channels = await get_user_channels(session, message.from_user.id)
    
    await state.set_state(GiveawayWizard.waiting_for_channel)
    
    if user_channels:
        await message.answer(
            "üì¢ <b>–®–∞–≥ 2/5: –í—ã–±–æ—Ä –∫–∞–Ω–∞–ª–∞</b>\n\n"
            "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–Ω–∞–ª –∏–∑ —Å–ø–∏—Å–∫–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ ¬´–î—Ä—É–≥–æ–π¬ª, —á—Ç–æ–±—ã –ø–µ—Ä–µ—Å–ª–∞—Ç—å –ø–æ—Å—Ç –≤—Ä—É—á–Ω—É—é.",
            reply_markup=select_channel_kb(user_channels)
        )
    else:
        # –ï—Å–ª–∏ –∫–∞–Ω–∞–ª–æ–≤ –Ω–µ—Ç, –ø—Ä–æ—Å–∏–º –ø–µ—Ä–µ—Å–ª–∞—Ç—å –ø–æ-—Å—Ç–∞—Ä–∏–Ω–∫–µ
        await message.answer(
            "üì¢ <b>–®–∞–≥ 2/5</b>\n\n"
            "–ö–æ–Ω—Ç–µ–Ω—Ç –ø—Ä–∏–Ω—è—Ç!\n"
            "–¢–µ–ø–µ—Ä—å –ø–µ—Ä–µ—à–ª–∏—Ç–µ –ª—é–±–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –∫–∞–Ω–∞–ª–∞, –≥–¥–µ –±–æ—Ç —è–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω–æ–º."
        )=== ./handlers/creator/constructor.py ===
from datetime import datetime, timedelta
from aiogram import Router, types, F, Bot
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from sqlalchemy.ext.asyncio import AsyncSession

from database.requests.channel_repo import get_user_channels, add_channel
from database.requests.giveaway_repo import create_giveaway
from database.requests.user_repo import register_user
from core.security.sanitizer import sanitize_text, get_message_html
from keyboards.inline.constructor import constructor_main_kb, winners_selector_kb, channel_selection_kb, referral_selector_kb
from keyboards.inline.dashboard import skip_link_kb
from core.tools.scheduler import scheduler
from core.logic.game_actions import finish_giveaway_task
from core.tools.formatters import format_giveaway_caption
from keyboards.inline.participation import join_keyboard
from core.tools.timezone import to_utc, get_now_msk, strip_tz

router = Router()

class ConstructorState(StatesGroup):
    init = State()
    editing_content = State()
    adding_channel = State()
    adding_channel_link = State()

@router.callback_query(F.data == "create_gw_init")
@router.message(Command("new"))
async def start_constructor(event: types.Message | types.CallbackQuery, state: FSMContext):
    default_finish = get_now_msk() + timedelta(hours=24)
    default_data = {
        "text": None, "media_file_id": None, "media_type": None,
        "main_channel": None, "sponsors": [],
        "finish_time_str": default_finish.isoformat(),
        "winners": 1, 
        "ref_req": 0, # –ö–æ–ª-–≤–æ –¥—Ä—É–∑–µ–π (0 = –≤—ã–∫–ª)
        "is_captcha": False
    }
    await state.set_data(default_data)
    await state.set_state(ConstructorState.editing_content)
    
    msg = event.message if isinstance(event, types.CallbackQuery) else event
    text = "üé® <b>–ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –†–æ–∑—ã–≥—Ä—ã—à–∞</b>\n\n–ü—Ä–∏—à–ª–∏—Ç–µ –ø–æ—Å—Ç (–¢–µ–∫—Å—Ç, –§–æ—Ç–æ –∏–ª–∏ –í–∏–¥–µ–æ)."
    
    if isinstance(event, types.CallbackQuery): await event.message.edit_text(text)
    else: await msg.answer(text)

@router.message(ConstructorState.editing_content)
async def receive_content(message: types.Message, state: FSMContext):
    media_id, media_type = None, None
    if message.photo: media_id, media_type = message.photo[-1].file_id, "photo"
    elif message.video: media_id, media_type = message.video.file_id, "video"
    elif message.animation: media_id, media_type = message.animation.file_id, "animation"

    html_content = get_message_html(message)
    if not html_content: return await message.answer("‚ùå –í –ø–æ—Å—Ç–µ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ç–µ–∫—Å—Ç.")
    
    safe_text = sanitize_text(html_content)
    await state.update_data(text=safe_text, media_file_id=media_id, media_type=media_type)
    await send_preview(message, state)

async def send_preview(message: types.Message, state: FSMContext, is_edit: bool = False):
    data = await state.get_data()
    
    finish_dt = datetime.fromisoformat(data['finish_time_str'])
    date_str = finish_dt.strftime('%d.%m %H:%M –ú–°–ö')
    
    kb = constructor_main_kb(
        date_str, data['winners'], data['ref_req'], 
        data['is_captcha'], bool(data['main_channel']), len(data['sponsors'])
    )
    
    caption = f"{data['text']}\n\n<i>(–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä. –ò—Ç–æ–≥–∏: {date_str})</i>"
    
    if is_edit and message.from_user.is_bot:
        try:
            if data['media_type']: await message.edit_caption(caption=caption, reply_markup=kb)
            else: await message.edit_text(text=caption, reply_markup=kb)
            return
        except: await message.delete()

    if data['media_type'] == 'photo': await message.answer_photo(data['media_file_id'], caption=caption, reply_markup=kb)
    elif data['media_type'] == 'video': await message.answer_video(data['media_file_id'], caption=caption, reply_markup=kb)
    elif data['media_type'] == 'animation': await message.answer_animation(data['media_file_id'], caption=caption, reply_markup=kb)
    else: await message.answer(text=caption, reply_markup=kb)

# --- –ú–ï–ù–Æ–®–ö–ò ---
@router.callback_query(F.data == "constr_edit_content")
async def ask_new_content(call: types.CallbackQuery, state: FSMContext):
    await state.set_state(ConstructorState.editing_content)
    await call.message.delete()
    await call.message.answer("‚úèÔ∏è –ü—Ä–∏—à–ª–∏—Ç–µ –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç –∏–ª–∏ –º–µ–¥–∏–∞:")

@router.callback_query(F.data == "constr_winners_menu")
async def winners_menu(call: types.CallbackQuery):
    await call.message.edit_reply_markup(reply_markup=winners_selector_kb())

@router.callback_query(F.data.startswith("constr_set_winners:"))
async def set_winners(call: types.CallbackQuery, state: FSMContext):
    await state.update_data(winners=int(call.data.split(":")[-1]))
    await send_preview(call.message, state, is_edit=True)

# --- –†–ï–§–ï–†–ê–õ–ö–ê ---
@router.callback_query(F.data == "constr_ref_menu")
async def ref_menu(call: types.CallbackQuery):
    await call.message.edit_reply_markup(reply_markup=referral_selector_kb())

@router.callback_query(F.data.startswith("constr_set_ref:"))
async def set_ref(call: types.CallbackQuery, state: FSMContext):
    count = int(call.data.split(":")[-1])
    await state.update_data(ref_req=count)
    await send_preview(call.message, state, is_edit=True)

# --- –ö–ê–ü–ß–ê ---
@router.callback_query(F.data == "constr_toggle_cap")
async def toggle_cap(call: types.CallbackQuery, state: FSMContext):
    data = await state.get_data()
    await state.update_data(is_captcha=not data['is_captcha'])
    await send_preview(call.message, state, is_edit=True)

@router.callback_query(F.data == "constr_back_main")
async def back_to_main(call: types.CallbackQuery, state: FSMContext):
    await send_preview(call.message, state, is_edit=True)

# --- –í–´–ë–û–† –ö–ê–ù–ê–õ–û–í (–ö–æ–ø–∏—Ä—É–µ–º –ª–æ–≥–∏–∫—É –∏–∑ –ø—Ä–æ—à–ª–æ–≥–æ –æ—Ç–≤–µ—Ç–∞, –æ–Ω–∞ –æ–∫) ---
@router.callback_query(F.data == "constr_select_main")
async def select_main_menu(call: types.CallbackQuery, session: AsyncSession, state: FSMContext):
    channels = await get_user_channels(session, call.from_user.id)
    data = await state.get_data()
    sel = [data['main_channel']['id']] if data['main_channel'] else []
    await call.message.edit_reply_markup(reply_markup=channel_selection_kb(channels, "main", sel))

@router.callback_query(F.data == "constr_select_sponsors")
async def select_sponsors_menu(call: types.CallbackQuery, session: AsyncSession, state: FSMContext):
    channels = await get_user_channels(session, call.from_user.id)
    data = await state.get_data()
    main_id = data['main_channel']['id'] if data['main_channel'] else None
    available = [ch for ch in channels if ch.channel_id != main_id]
    sel = [s['id'] for s in data['sponsors']]
    await call.message.edit_reply_markup(reply_markup=channel_selection_kb(available, "sponsor", sel))

@router.callback_query(F.data.startswith("constr_set_ch:"))
async def set_channel(call: types.CallbackQuery, state: FSMContext, bot: Bot, session: AsyncSession):
    _, mode, ch_id_str = call.data.split(":")
    chat_id = int(ch_id_str)
    from database.requests.channel_repo import get_user_channels
    user_chs = await get_user_channels(session, call.from_user.id)
    target_ch = next((ch for ch in user_chs if ch.channel_id == chat_id), None)
    if not target_ch: return await call.answer("–û—à–∏–±–∫–∞ –ë–î", show_alert=True)

    link = target_ch.invite_link
    if not link and target_ch.username: link = f"@{target_ch.username}"
    if not link: link = "private"

    channel_info = {'id': chat_id, 'title': target_ch.title, 'link': link}

    if mode == "main":
        data = await state.get_data()
        if data['main_channel'] and data['main_channel']['id'] == chat_id:
            await state.update_data(main_channel=None)
        else:
            sponsors = [s for s in data['sponsors'] if s['id'] != chat_id]
            await state.update_data(main_channel=channel_info, sponsors=sponsors)
        
        chs = await get_user_channels(session, call.from_user.id)
        new_data = await state.get_data()
        sel = [new_data['main_channel']['id']] if new_data['main_channel'] else []
        await call.message.edit_reply_markup(reply_markup=channel_selection_kb(chs, "main", sel))
    else:
        data = await state.get_data()
        sponsors = data.get('sponsors', [])
        if any(s['id'] == chat_id for s in sponsors):
            sponsors = [s for s in sponsors if s['id'] != chat_id]
        else:
            sponsors.append(channel_info)
        await state.update_data(sponsors=sponsors)
        
        chs = await get_user_channels(session, call.from_user.id)
        main_id = data['main_channel']['id'] if data['main_channel'] else None
        avail = [ch for ch in chs if ch.channel_id != main_id]
        sel = [s['id'] for s in sponsors]
        await call.message.edit_reply_markup(reply_markup=channel_selection_kb(avail, "sponsor", sel))
    
    await send_preview(call.message, state, is_edit=True)

# --- –î–û–ë–ê–í–õ–ï–ù–ò–ï –ö–ê–ù–ê–õ–ê ---
@router.callback_query(F.data == "add_new_channel_constr")
async def ask_channel_constr(call: types.CallbackQuery, state: FSMContext):
    await state.set_state(ConstructorState.adding_channel)
    await call.message.delete()
    await call.message.answer("üì¢ –ü–µ—Ä–µ—à–ª–∏—Ç–µ –ø–æ—Å—Ç –∏–∑ –∫–∞–Ω–∞–ª–∞ (–®–∞–≥ 1/2):")

@router.message(ConstructorState.adding_channel)
async def process_new_channel_step1_constr(message: types.Message, state: FSMContext, bot: Bot):
    chat_id, title, username = None, "Title", None
    if message.forward_from_chat:
        chat_id = message.forward_from_chat.id
        title = message.forward_from_chat.title
        username = message.forward_from_chat.username
    elif message.text and message.text.startswith("@"):
        try:
            chat = await bot.get_chat(message.text)
            chat_id, title, username = chat.id, chat.title, chat.username
        except: pass
    
    if not chat_id: return await message.answer("‚ùå –û—à–∏–±–∫–∞. –ü–µ—Ä–µ—à–ª–∏—Ç–µ –ø–æ—Å—Ç.")

    try:
        member = await bot.get_chat_member(chat_id, bot.id)
        if member.status not in ("administrator", "creator"): raise Exception
    except: return await message.answer("‚ùå –°–¥–µ–ª–∞–π—Ç–µ –±–æ—Ç–∞ –∞–¥–º–∏–Ω–æ–º!")

    await state.update_data(temp_channel={"id": chat_id, "title": title, "username": username})
    await state.set_state(ConstructorState.adding_channel_link)
    await message.answer("üîó <b>–®–∞–≥ 2/2:</b> –ò–Ω–≤–∞–π—Ç-—Å—Å—ã–ª–∫–∞:", reply_markup=skip_link_kb("constr"))

@router.message(ConstructorState.adding_channel_link)
async def process_link_text_constr(message: types.Message, state: FSMContext, session: AsyncSession):
    link = message.text.strip()
    if "t.me" not in link: return await message.answer("‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—Å—ã–ª–∫–∞.")
    data = await state.get_data()
    ch_data = data['temp_channel']
    await add_channel(session, message.from_user.id, ch_data['id'], ch_data['title'], ch_data['username'], link)
    await message.answer("‚úÖ –î–æ–±–∞–≤–ª–µ–Ω!")
    await state.set_state(ConstructorState.init)
    await send_preview(message, state)

@router.callback_query(ConstructorState.adding_channel_link, F.data == "skip_link_constr")
async def process_link_skip_constr(call: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    ch_data = data['temp_channel']
    auto_link = None
    if ch_data['username']: auto_link = f"@{ch_data['username']}"
    else:
        try: auto_link = await bot.export_chat_invite_link(ch_data['id'])
        except: pass
    await add_channel(session, call.from_user.id, ch_data['id'], ch_data['title'], ch_data['username'], auto_link)
    await state.set_state(ConstructorState.init)
    await send_preview(call.message, state)

# --- 7. –ü–£–ë–õ–ò–ö–ê–¶–ò–Ø (–§–ò–ù–ê–õ) ---
@router.callback_query(F.data == "constr_publish")
async def publish_giveaway(call: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    if not data.get('main_channel'): return await call.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–Ω–∞–ª!", show_alert=True)
    
    main_ch = data['main_channel']
    
    # 1. –í—Ä–µ–º—è (–ú–°–ö -> UTC -> –ë–µ–∑ —Ç–∞–π–º–∑–æ–Ω—ã –¥–ª—è –ë–î)
    finish_dt_msk = datetime.fromisoformat(data['finish_time_str'])
    finish_dt_utc = to_utc(finish_dt_msk)
    finish_dt_db = strip_tz(finish_dt_utc) # –í–û–¢ –¢–£–¢ –§–ò–ö–° –û–®–ò–ë–ö–ò DBAPI
    
    bot_info = await bot.get_me()
    # –í caption –ø–µ—Ä–µ–¥–∞–µ–º UTC, –≤–Ω—É—Ç—Ä–∏ —Ñ–æ—Ä–º–∞—Ç—Ç–µ—Ä–∞ –ø–µ—Ä–µ–≤–µ–¥–µ—Ç—Å—è –≤ –ú–°–ö
    caption = format_giveaway_caption(data['text'], data['winners'], finish_dt_utc, 0)
    keyboard = join_keyboard(bot_info.username, 0)
    
    # 2. –ü–æ—Å—Ç–∏–Ω–≥ –≤ –û–°–ù–û–í–ù–û–ô –∫–∞–Ω–∞–ª
    try:
        if data['media_type'] == 'photo':
            msg = await bot.send_photo(main_ch['id'], data['media_file_id'], caption=caption, reply_markup=keyboard)
        elif data['media_type'] == 'video':
            msg = await bot.send_video(main_ch['id'], data['media_file_id'], caption=caption, reply_markup=keyboard)
        else:
            msg = await bot.send_message(main_ch['id'], text=caption, reply_markup=keyboard)
    except Exception as e:
        return await call.answer(f"–û—à–∏–±–∫–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –≤ –æ—Å–Ω–æ–≤–Ω–æ–π: {e}", show_alert=True)

    # 3. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
    is_ref = data['ref_req'] > 0 # –ï—Å–ª–∏ –¥—Ä—É–∑–µ–π > 0, –∑–Ω–∞—á–∏—Ç —Ä–µ—Ñ –≤–∫–ª—é—á–µ–Ω–∞
    
    gw_id = await create_giveaway(
        session, call.from_user.id, main_ch['id'], msg.message_id, 
        data['text'], data['winners'], finish_dt_db, # –í –ë–î –ø–∏—à–µ–º naive time
        data['media_file_id'], data['media_type'], 
        data['sponsors'], 
        is_referral=is_ref, is_captcha=data['is_captcha']
    )

    # 4. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ (ID)
    await bot.edit_message_reply_markup(chat_id=main_ch['id'], message_id=msg.message_id, reply_markup=join_keyboard(bot_info.username, gw_id))
    
    # 5. –ö–†–û–°–°-–ü–û–°–¢–ò–ù–ì –í –°–ü–û–ù–°–û–†–û–í (–†–µ–ø–æ—Å—Ç –∏–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ)
    for sp in data['sponsors']:
        try:
            # –ü—Ä–æ—Å—Ç–æ —Ñ–æ—Ä–≤–∞—Ä–¥–∏–º –ø–æ—Å—Ç –∏–∑ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –≤ —Å–ø–æ–Ω—Å–æ—Ä—Å–∫–∏–π
            await bot.forward_message(chat_id=sp['id'], from_chat_id=main_ch['id'], message_id=msg.message_id)
        except:
            # –ï—Å–ª–∏ —Ñ–æ—Ä–≤–∞—Ä–¥ –∑–∞–ø—Ä–µ—â–µ–Ω, –ø—Ä–æ–±—É–µ–º –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–æ–ø–∏—é (copy_message)
            try:
                await bot.copy_message(chat_id=sp['id'], from_chat_id=main_ch['id'], message_id=msg.message_id, reply_markup=join_keyboard(bot_info.username, gw_id))
            except:
                pass # –ù–µ –∫—Ä–∏—Ç–∏—á–Ω–æ

    # 6. –¢–∞–π–º–µ—Ä (–ø–µ—Ä–µ–¥–∞–µ–º UTC)
    scheduler.add_job(finish_giveaway_task, "date", run_date=finish_dt_utc, kwargs={"giveaway_id": gw_id}, id=f"gw_{gw_id}", replace_existing=True)
    
    await call.message.delete()
    link = main_ch['link'] if main_ch['link'] != 'private' else "–∫–∞–Ω–∞–ª"
    await call.message.answer(f"‚úÖ <b>–û–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–æ!</b>\n–ò—Ç–æ–≥–∏: {finish_dt_msk.strftime('%d.%m %H:%M')}\n<a href='{link}'>–ü–µ—Ä–µ–π—Ç–∏</a>", disable_web_page_preview=True)
    await state.clear()=== ./handlers/creator/wizard_settings.py ===
from datetime import datetime, timedelta
from aiogram import Router, types, Bot, F
from aiogram.fsm.context import FSMContext
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from handlers.creator.wizard_start import GiveawayWizard
from keyboards.inline.creation_wizard import confirm_keyboard

router = Router()

# --- –í–´–ë–û–† –û–°–ù–û–í–ù–û–ì–û –ö–ê–ù–ê–õ–ê (–ö–∞–∫ –∏ –±—ã–ª–æ) ---
@router.callback_query(GiveawayWizard.waiting_for_channel, F.data.startswith("select_ch_"))
async def channel_selected_callback(call: types.CallbackQuery, state: FSMContext, bot: Bot):
    chat_id = int(call.data.split("_")[-1])
    try:
        chat = await bot.get_chat(chat_id) # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ –¥–ª—è —Å–ø–æ–Ω—Å–æ—Ä—Å–∫–æ–≥–æ —Å–ø–∏—Å–∫–∞
        member = await bot.get_chat_member(chat_id, bot.id)
        if member.status not in ("administrator", "creator"):
            raise Exception
    except:
        return await call.answer("‚ùå –ë–æ—Ç –Ω–µ –∞–¥–º–∏–Ω –∏–ª–∏ –æ—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞!", show_alert=True)

    await state.update_data(channel_id=chat_id)
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ —Å–ø–æ–Ω—Å–æ—Ä–æ–≤. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Ç—É–¥–∞ –≤—Ö–æ–¥–∏—Ç –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª.
    # –≠—Ç–æ –Ω—É–∂–Ω–æ, —á—Ç–æ–±—ã –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∫–∏ –±—ã–ª–∞ –µ–¥–∏–Ω–æ–π.
    link = chat.username if chat.username else chat.invite_link
    initial_sponsors = [{
        'id': chat_id,
        'title': chat.title,
        'link': f"@{link}" if chat.username else link
    }]
    await state.update_data(sponsors=initial_sponsors)

    # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –¥–æ–±–∞–≤–ª–µ–Ω–∏—é —Å–ø–æ–Ω—Å–æ—Ä–æ–≤
    await state.set_state(GiveawayWizard.waiting_for_sponsors)
    await call.message.edit_text(
        "ü§ù <b>–®–∞–≥ 3/6: –°–ø–æ–Ω—Å–æ—Ä—ã</b>\n\n"
        "–ù—É–∂–Ω–æ –ª–∏ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –¥—Ä—É–≥–∏–µ –∫–∞–Ω–∞–ª—ã?\n"
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ @username –∫–∞–Ω–∞–ª–∞ –∏–ª–∏ –ø–µ—Ä–µ—à–ª–∏—Ç–µ –ø–æ—Å—Ç, —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å —Å–ø–æ–Ω—Å–æ—Ä–∞.\n"
        "‚ö†Ô∏è –ë–æ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ç–∞–º –∞–¥–º–∏–Ω–æ–º!\n\n"
        "–ù–∞–∂–º–∏—Ç–µ <b>¬´–ì–æ—Ç–æ–≤–æ¬ª</b>, –µ—Å–ª–∏ —Å–ø–æ–Ω—Å–æ—Ä–æ–≤ –±–æ–ª—å—à–µ –Ω–µ—Ç.",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="‚úÖ –ì–æ—Ç–æ–≤–æ, –¥–∞–ª—å—à–µ", callback_data="sponsors_done")]])
    )

# --- –õ–û–ì–ò–ö–ê –î–û–ë–ê–í–õ–ï–ù–ò–Ø –°–ü–û–ù–°–û–†–û–í ---
@router.message(GiveawayWizard.waiting_for_sponsors)
async def add_sponsor(message: types.Message, state: FSMContext, bot: Bot):
    chat_id = None
    title = None
    link = None

    if message.forward_from_chat:
        chat_id = message.forward_from_chat.id
        title = message.forward_from_chat.title
        link = message.forward_from_chat.username
    elif message.text and message.text.startswith("@"):
        try:
            chat = await bot.get_chat(message.text)
            chat_id = chat.id
            title = chat.title
            link = chat.username
        except:
            pass
    
    if not chat_id:
        return await message.answer("‚ùå –ù–µ –º–æ–≥—É –Ω–∞–π—Ç–∏ –∫–∞–Ω–∞–ª. –ü–µ—Ä–µ—à–ª–∏—Ç–µ –ø–æ—Å—Ç –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ @username.")

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–¥–º–∏–Ω–∫–∏
    try:
        member = await bot.get_chat_member(chat_id, bot.id)
        if member.status not in ("administrator", "creator"):
             return await message.answer("‚ùå –Ø –Ω–µ –∞–¥–º–∏–Ω –≤ —ç—Ç–æ–º –∫–∞–Ω–∞–ª–µ!")
    except:
        return await message.answer("‚ùå –û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞.")

    data = await state.get_data()
    sponsors = data.get('sponsors', [])
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏
    if any(s['id'] == chat_id for s in sponsors):
        return await message.answer("‚ö†Ô∏è –≠—Ç–æ—Ç –∫–∞–Ω–∞–ª —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω.")

    sponsors.append({
        'id': chat_id,
        'title': title,
        'link': f"@{link}" if link else "link"
    })
    await state.update_data(sponsors=sponsors)
    
    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–ø–∏—Å–æ–∫
    list_text = "\n".join([f"{i+1}. {s['title']}" for i, s in enumerate(sponsors)])
    
    await message.answer(
        f"‚úÖ <b>–°–ø–æ–Ω—Å–æ—Ä –¥–æ–±–∞–≤–ª–µ–Ω!</b>\n\n"
        f"–°–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤ –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏:\n{list_text}\n\n"
        f"–û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –∫–∞–Ω–∞–ª –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ ¬´–ì–æ—Ç–æ–≤–æ¬ª.",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="‚úÖ –ì–æ—Ç–æ–≤–æ, –¥–∞–ª—å—à–µ", callback_data="sponsors_done")]])
    )

# --- –ó–ê–í–ï–†–®–ï–ù–ò–ï –≠–¢–ê–ü–ê –°–ü–û–ù–°–û–†–û–í ---
@router.callback_query(GiveawayWizard.waiting_for_sponsors, F.data == "sponsors_done")
async def finish_sponsors(call: types.CallbackQuery, state: FSMContext):
    await state.set_state(GiveawayWizard.waiting_for_winners)
    await call.message.edit_text("üî¢ <b>–®–∞–≥ 4/6</b>\n–°–∫–æ–ª—å–∫–æ –±—É–¥–µ—Ç –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π? (–≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ)")

# --- –û—Å—Ç–∞–ª—å–Ω—ã–µ —à–∞–≥–∏ (–ø–æ–±–µ–¥–∏—Ç–µ–ª–∏ –∏ –≤—Ä–µ–º—è) –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ---
@router.message(GiveawayWizard.waiting_for_winners)
async def process_winners(message: types.Message, state: FSMContext):
    if not message.text.isdigit() or int(message.text) < 1:
        return await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ > 0.")
    await state.update_data(winners_count=int(message.text))
    await state.set_state(GiveawayWizard.waiting_for_time)
    await message.answer("‚è≥ <b>–®–∞–≥ 5/6</b>\n–ß–µ—Ä–µ–∑ —Å–∫–æ–ª—å–∫–æ —á–∞—Å–æ–≤ –∑–∞–≤–µ—Ä—à–∏—Ç—å?")

@router.message(GiveawayWizard.waiting_for_time)
async def process_time(message: types.Message, state: FSMContext):
    try:
        hours = float(message.text)
        end_time = datetime.utcnow() + timedelta(hours=hours)
    except ValueError:
        return await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ (—á–∞—Å—ã).")

    await state.update_data(finish_time=end_time.isoformat())
    data = await state.get_data()
    sponsors_count = len(data.get('sponsors', []))
    
    await message.answer(
        f"üìã <b>–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–∞–Ω–Ω—ã–µ:</b>\n"
        f"–ö–∞–Ω–∞–ª ID: {data['channel_id']}\n"
        f"–°–ø–æ–Ω—Å–æ—Ä–æ–≤: {sponsors_count}\n"
        f"–ü–æ–±–µ–¥–∏—Ç–µ–ª–µ–π: {data['winners_count']}\n"
        f"–§–∏–Ω–∏—à: {end_time.strftime('%Y-%m-%d %H:%M')}\n\n"
        f"–¢–µ–∫—Å—Ç: {data['prize_text'][:50]}...",
        reply_markup=confirm_keyboard()
    )
    await state.set_state(GiveawayWizard.confirmation)=== ./handlers/super_admin/list_view.py ===
# handlers/super_admin/list_view.py
from aiogram import Router, F
from aiogram.types import CallbackQuery
from keyboards.callback_data import AdminAction
from keyboards.inline.admin_panel import build_manage_menu

router = Router()

# –õ–æ–≤–∏–º callback —Å action="manage"
@router.callback_query(AdminAction.filter(F.action == "manage"))
async def show_gw_options(call: CallbackQuery, callback_data: AdminAction):
    # –¢—É—Ç —É–∂–µ –ø—Ä–æ—à–ª–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ HMAC –≤ Middleware, —Ç–∞–∫ —á—Ç–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ
    gw_id = callback_data.id
    admin_id = call.from_user.id
    
    kb = build_manage_menu(gw_id, admin_id)
    await call.message.edit_text(f"‚öôÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–æ–∑—ã–≥—Ä—ã—à–µ–º #{gw_id}", reply_markup=kb)=== ./handlers/super_admin/menu_main.py ===
# handlers/super_admin/menu_main.py
from aiogram import Router, types, F
from filters.is_admin import IsAdmin
from database.requests.giveaway_repo import get_active_giveaways
from keyboards.inline.admin_panel import build_giveaway_list
from sqlalchemy.ext.asyncio import AsyncSession

router = Router()

@router.message(IsAdmin(), F.text == "/admin")
async def admin_dashboard(message: types.Message, session: AsyncSession):
    active_gws = await get_active_giveaways(session)
    
    kb = build_giveaway_list(active_gws, admin_id=message.from_user.id)
    
    await message.answer(
        f"üîê <b>Admin Panel</b>\n"
        f"–ê–∫—Ç–∏–≤–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π: {len(active_gws)}\n\n"
        f"–í—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–∑—ã–≥—Ä—ã—à –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è:",
        reply_markup=kb
    )=== ./handlers/super_admin/manage_item.py ===
# handlers/super_admin/manage_item.py
from aiogram import Router, Bot, F
from aiogram.types import CallbackQuery
from keyboards.callback_data import AdminAction
from core.logic.game_actions import finish_giveaway_task

router = Router()

@router.callback_query(AdminAction.filter(F.action == "finish"))
async def force_finish(call: CallbackQuery, callback_data: AdminAction, bot: Bot):
    await call.answer("–ó–∞–ø—É—Å–∫–∞—é –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ...", show_alert=False)
    # –í—ã–∑—ã–≤–∞–µ–º –æ–±—â—É—é –ª–æ–≥–∏–∫—É
    await finish_giveaway_task(callback_data.id, bot)
    await call.message.edit_text(f"‚úÖ –†–æ–∑—ã–≥—Ä—ã—à #{callback_data.id} –∑–∞–≤–µ—Ä—à–µ–Ω –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ.")

@router.callback_query(AdminAction.filter(F.action == "delete"))
async def delete_gw(call: CallbackQuery, callback_data: AdminAction):
    # –õ–æ–≥–∏–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∏–∑ –ë–î (–Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –º–µ—Ç–æ–¥ –≤ repo)
    # await delete_giveaway(session, callback_data.id)
    await call.message.edit_text("üóë –†–æ–∑—ã–≥—Ä—ã—à —É–¥–∞–ª–µ–Ω (soft delete).")=== ./handlers/super_admin/rig_winner.py ===
# handlers/super_admin/rig_winner.py
from aiogram import Router, F, types
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from sqlalchemy.ext.asyncio import AsyncSession

from keyboards.callback_data import AdminAction
from database.requests.giveaway_repo import set_predetermined_winner

router = Router()

class RigState(StatesGroup):
    waiting_for_id = State()

@router.callback_query(AdminAction.filter(F.action == "rig"))
async def start_rigging(call: types.CallbackQuery, callback_data: AdminAction, state: FSMContext):
    await state.update_data(gw_id=callback_data.id)
    await state.set_state(RigState.waiting_for_id)
    await call.message.answer(
        f"üïµÔ∏è‚Äç‚ôÇÔ∏è <b>–†–µ–∂–∏–º –±–æ–≥–∞</b> (–†–æ–∑—ã–≥—Ä—ã—à #{callback_data.id})\n"
        f"–ü—Ä–∏—à–ª–∏—Ç–µ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä—ã–π –î–û–õ–ñ–ï–ù –ø–æ–±–µ–¥–∏—Ç—å.\n"
        f"‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ–±—è–∑–∞–Ω –Ω–∞–∂–∞—Ç—å –∫–Ω–æ–ø–∫—É —É—á–∞—Å—Ç–∏—è, –∏–Ω–∞—á–µ —ç—Ç–æ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç!"
    )
    await call.answer()

@router.message(RigState.waiting_for_id)
async def set_winner_id(message: types.Message, state: FSMContext, session: AsyncSession):
    try:
        winner_id = int(message.text)
    except ValueError:
        return await message.answer("‚ùå –ù—É–∂–µ–Ω —á–∏—Å–ª–æ–≤–æ–π ID.")

    data = await state.get_data()
    gw_id = data['gw_id']

    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º "–∂—É—á–∫–∞" –≤ –ë–î
    await set_predetermined_winner(session, gw_id, winner_id)
    
    await message.answer(f"‚úÖ <b>–ì–æ—Ç–æ–≤–æ!</b>\n–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å `{winner_id}` –ø–æ–±–µ–¥–∏—Ç –≤ —Ä–æ–∑—ã–≥—Ä—ã—à–µ #{gw_id} (–µ—Å–ª–∏ –±—É–¥–µ—Ç —É—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å).")
    await state.clear()=== ./handlers/participant/join.py ===
# handlers/participant/join.py
from aiogram import Router, Bot, F
from aiogram.types import CallbackQuery
from sqlalchemy.ext.asyncio import AsyncSession

from keyboards.callback_data import JoinAction
from database.requests.participant_repo import add_participant
from database.requests.giveaway_repo import get_giveaway_by_id
from database.requests.user_repo import register_user  # <--- –î–û–ë–ê–í–ò–õ–ò –ò–ú–ü–û–†–¢

router = Router()

@router.callback_query(JoinAction.filter())
async def on_join_click(call: CallbackQuery, callback_data: JoinAction, session: AsyncSession, bot: Bot):
    gw_id = callback_data.giveaway_id
    giveaway = await get_giveaway_by_id(session, gw_id)

    if not giveaway or giveaway.status != 'active':
        return await call.answer("‚ùå –†–æ–∑—ã–≥—Ä—ã—à –∑–∞–≤–µ—Ä—à–µ–Ω –∏–ª–∏ —É–¥–∞–ª–µ–Ω.", show_alert=True)

    # 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏
    try:
        member = await bot.get_chat_member(chat_id=giveaway.channel_id, user_id=call.from_user.id)
        if member.status in ['left', 'kicked']:
            return await call.answer("üì¢ –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª!", show_alert=True)
    except Exception:
        return await call.answer("‚ö†Ô∏è –ù–µ –º–æ–≥—É –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É (–±–æ—Ç –Ω–µ –∞–¥–º–∏–Ω).", show_alert=True)

    # 2. –†–ï–ì–ò–°–¢–†–ê–¶–ò–Ø –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø (–ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –û–®–ò–ë–ö–ò FK)
    # –î–∞–∂–µ –µ—Å–ª–∏ –æ–Ω –Ω–µ –∂–∞–ª /start, –º—ã —Å–æ—Ö—Ä–∞–Ω—è–µ–º –µ–≥–æ –≤ –±–∞–∑—É users
    await register_user(
        session,
        user_id=call.from_user.id,
        username=call.from_user.username,
        full_name=call.from_user.full_name
    )

    # 3. –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –ë–î —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
    is_new = await add_participant(session, call.from_user.id, gw_id)
    
    if is_new:
        await call.answer("‚úÖ –í—ã —É—á–∞—Å—Ç–≤—É–µ—Ç–µ! –£–¥–∞—á–∏!", show_alert=True)
    else:
        await call.answer("ü§î –í—ã —É–∂–µ –≤ —Å–ø–∏—Å–∫–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.", show_alert=False)=== ./handlers/common/start.py ===
from aiogram import Router, types, Bot
from aiogram.filters import CommandStart, CommandObject
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.utils.keyboard import InlineKeyboardBuilder

from database.requests.user_repo import register_user
from database.requests.giveaway_repo import get_giveaway_by_id, get_required_channels
from database.requests.participant_repo import add_participant

router = Router()

@router.message(CommandStart())
async def cmd_start(message: types.Message, command: CommandObject, session: AsyncSession, bot: Bot):
    await register_user(session, message.from_user.id, message.from_user.username, message.from_user.full_name)

    args = command.args
    if not args: return 

    # --- –†–ï–ó–£–õ–¨–¢–ê–¢–´ ---
    if args.startswith("res_"):
        try: gw_id = int(args.replace("res_", ""))
        except: return
        
        gw = await get_giveaway_by_id(session, gw_id)
        if not gw: return await message.answer("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–æ.")
        if gw.status == 'active': return await message.answer("‚è≥ –†–æ–∑—ã–≥—Ä—ã—à –∏–¥–µ—Ç.")
            
        text = f"üèÅ <b>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã #{gw_id}</b>\n\n"
        if not gw.winner_ids: text += "üòî –ü–æ–±–µ–¥–∏—Ç–µ–ª–µ–π –Ω–µ—Ç."
        else:
            wl = gw.winner_ids.split(",")
            if str(message.from_user.id) in wl: text += "\nüéâ <b>–í–´ –í–´–ò–ì–†–ê–õ–ò!</b> üéâ\n\n"
            text += "üèÜ <b>–°–ø–∏—Å–æ–∫:</b>\n"
            for idx, uid in enumerate(wl, 1):
                try:
                    c = await bot.get_chat(int(uid))
                    n = f"@{c.username}" if c.username else c.full_name
                    text += f"{idx}. {n}\n"
                except: text += f"{idx}. ID {uid}\n"
        await message.answer(text)
        return

    # --- –£–ß–ê–°–¢–ò–ï ---
    if args.startswith("gw_"):
        try: gw_id = int(args.replace("gw_", ""))
        except: return

        gw = await get_giveaway_by_id(session, gw_id)
        if not gw or gw.status != 'active': return await message.answer("‚ùå –ó–∞–≤–µ—Ä—à–µ–Ω.")

        reqs = await get_required_channels(session, gw_id)
        missing = []

        # –ì–ª–∞–≤–Ω—ã–π
        try:
            chat = await bot.get_chat(gw.channel_id)
            # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –∏–Ω–≤–∞–π—Ç-—Å—Å—ã–ª–∫–µ (–º–æ–∂–µ—Ç –±—ã—Ç—å –≤ –ë–î –≤ Channels, –Ω–æ –∑–¥–µ—Å—å –±–µ—Ä–µ–º –∏–∑ –æ–±—ä–µ–∫—Ç–∞ Chat –µ—Å–ª–∏ –±–æ—Ç –∞–¥–º–∏–Ω)
            # –í –∏–¥–µ–∞–ª–µ –Ω—É–∂–Ω–æ –¥–µ–ª–∞—Ç—å join —Å —Ç–∞–±–ª–∏—Ü–µ–π Channels, –Ω–æ –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã:
            m_link = chat.invite_link if chat.invite_link else f"https://t.me/{chat.username}"
            if not m_link or "t.me" not in m_link: m_link = "private"
            
            mem = await bot.get_chat_member(gw.channel_id, message.from_user.id)
            if mem.status in ['left', 'kicked']:
                missing.append({'title': '–û—Å–Ω–æ–≤–Ω–æ–π –∫–∞–Ω–∞–ª', 'link': m_link})
        except: pass

        # –°–ø–æ–Ω—Å–æ—Ä—ã
        for r in reqs:
            try:
                mem = await bot.get_chat_member(r.channel_id, message.from_user.id)
                if mem.status in ['left', 'kicked']:
                    # –ë–µ—Ä–µ–º —Å—Å—ã–ª–∫—É –∏–∑ –ë–î, –∫–æ—Ç–æ—Ä—É—é –º—ã —Å–æ—Ö—Ä–∞–Ω–∏–ª–∏ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏!
                    missing.append({'title': r.channel_title, 'link': r.channel_link})
            except: pass

        if missing:
            builder = InlineKeyboardBuilder()
            text = "üõë <b>–ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –¥–ª—è —É—á–∞—Å—Ç–∏—è:</b>\n\n"
            for ch in missing:
                url = ch['link']
                # –§–∏–∫—Å –∫—Ä–∏–≤—ã—Ö —Å—Å—ã–ª–æ–∫
                if url == "private" or not url: url = "https://t.me/" 
                if url.startswith("@"): url = f"https://t.me/{url[1:]}"
                
                builder.button(text=f"üì¢ {ch['title']}", url=url)
            
            builder.button(text="üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", url=f"https://t.me/{(await bot.get_me()).username}?start=gw_{gw_id}")
            builder.adjust(1)
            await message.answer(text, reply_markup=builder.as_markup())
            return

        is_new = await add_participant(session, message.from_user.id, gw_id)
        if is_new: await message.answer("‚úÖ <b>–í—ã —É—á–∞—Å—Ç–≤—É–µ—Ç–µ!</b>")
        else: await message.answer("üëå –í—ã —É–∂–µ —É—á–∞—Å—Ç–≤—É–µ—Ç–µ.")=== ./handlers/__init__.py ===
=== ./handlers/user/my_channels.py ===
from aiogram import Router, types, F, Bot
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from sqlalchemy.ext.asyncio import AsyncSession

from database.requests.channel_repo import add_channel, get_user_channels, delete_channel_by_id
from keyboards.inline.dashboard import channels_list_kb, back_to_dash, skip_link_kb

router = Router()

class ChannelState(StatesGroup):
    waiting_for_forward = State()
    waiting_for_link = State()

@router.callback_query(F.data == "my_channels")
async def show_channels(call: types.CallbackQuery, session: AsyncSession):
    channels = await get_user_channels(session, call.from_user.id)
    await call.message.edit_text(
        "üì¢ <b>–ú–æ–∏ –∫–∞–Ω–∞–ª—ã</b>\n\n"
        "–°–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤, –≥–¥–µ –±–æ—Ç —è–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.",
        reply_markup=channels_list_kb(channels)
    )

@router.callback_query(F.data == "add_new_channel")
async def ask_channel(call: types.CallbackQuery, state: FSMContext):
    await state.set_state(ChannelState.waiting_for_forward)
    await call.message.edit_text(
        "‚ûï <b>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–∞ (–®–∞–≥ 1/2)</b>\n\n"
        "1. –î–æ–±–∞–≤—å—Ç–µ –±–æ—Ç–∞ –≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –∫–∞–Ω–∞–ª–∞.\n"
        "2. –ü–µ—Ä–µ—à–ª–∏—Ç–µ —Å—é–¥–∞ –ª—é–±–æ–π –ø–æ—Å—Ç –∏–∑ –∫–∞–Ω–∞–ª–∞ (–∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ @username).",
        reply_markup=back_to_dash()
    )

@router.message(ChannelState.waiting_for_forward)
async def process_channel_step1(message: types.Message, state: FSMContext, bot: Bot):
    chat_id = None
    title = "No Title"
    username = None

    if message.forward_from_chat:
        chat_id = message.forward_from_chat.id
        title = message.forward_from_chat.title
        username = message.forward_from_chat.username
    elif message.text and message.text.startswith("@"):
        try:
            chat = await bot.get_chat(message.text)
            chat_id = chat.id
            title = chat.title
            username = chat.username
        except:
            await message.answer("‚ùå –ù–µ –º–æ–≥—É –Ω–∞–π—Ç–∏ –∫–∞–Ω–∞–ª. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ @username.")
            return

    if not chat_id:
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–∞–Ω–∞–ª. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ—Å–ª–∞—Ç—å –ø–æ—Å—Ç.")
        return

    try:
        member = await bot.get_chat_member(chat_id, bot.id)
        if member.status not in ("administrator", "creator"):
            await message.answer("‚ùå –ë–æ—Ç –Ω–µ –∞–¥–º–∏–Ω! –î–∞–π—Ç–µ –ø—Ä–∞–≤–∞ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
            return
    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞: {e}")
        return

    await state.update_data(temp_channel={"id": chat_id, "title": title, "username": username})
    
    await state.set_state(ChannelState.waiting_for_link)
    await message.answer(
        f"‚úÖ –ö–∞–Ω–∞–ª <b>{title}</b> –Ω–∞–π–¥–µ–Ω!\n\n"
        "üîó <b>–®–∞–≥ 2/2:</b> –ü—Ä–∏—à–ª–∏—Ç–µ –∏–Ω–≤–∞–π—Ç-—Å—Å—ã–ª–∫—É (–¥–ª—è –∫–Ω–æ–ø–∫–∏ '–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è') –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å.",
        reply_markup=skip_link_kb("settings")
    )

@router.message(ChannelState.waiting_for_link)
async def process_link_text(message: types.Message, state: FSMContext, session: AsyncSession):
    link = message.text.strip()
    if "t.me" not in link:
        await message.answer("‚ùå –≠—Ç–æ –Ω–µ –ø–æ—Ö–æ–∂–µ –Ω–∞ —Å—Å—ã–ª–∫—É.")
        return

    data = await state.get_data()
    ch_data = data['temp_channel']
    await add_channel(session, message.from_user.id, ch_data['id'], ch_data['title'], ch_data['username'], link)
    await message.answer(f"‚úÖ –ö–∞–Ω–∞–ª <b>{ch_data['title']}</b> –¥–æ–±–∞–≤–ª–µ–Ω!", reply_markup=back_to_dash())
    await state.clear()

@router.callback_query(ChannelState.waiting_for_link, F.data == "skip_link_settings")
async def process_link_skip(call: types.CallbackQuery, state: FSMContext, session: AsyncSession, bot: Bot):
    data = await state.get_data()
    ch_data = data['temp_channel']
    
    auto_link = None
    if ch_data['username']: auto_link = f"@{ch_data['username']}"
    else:
        try: auto_link = await bot.export_chat_invite_link(ch_data['id'])
        except: pass

    await add_channel(session, call.from_user.id, ch_data['id'], ch_data['title'], ch_data['username'], auto_link)
    await call.message.edit_text(f"‚úÖ –ö–∞–Ω–∞–ª <b>{ch_data['title']}</b> –¥–æ–±–∞–≤–ª–µ–Ω!", reply_markup=back_to_dash())
    await state.clear()

@router.callback_query(F.data.startswith("del_ch_"))
async def delete_ch(call: types.CallbackQuery, session: AsyncSession):
    ch_id = int(call.data.split("_")[-1])
    await delete_channel_by_id(session, ch_id, call.from_user.id)
    await call.answer("üóë –ö–∞–Ω–∞–ª —É–¥–∞–ª–µ–Ω.")
    await show_channels(call, session)=== ./handlers/user/dashboard.py ===
from aiogram import Router, types, Bot, F
from aiogram.filters import CommandStart, CommandObject
from sqlalchemy.ext.asyncio import AsyncSession

from database.requests.user_repo import register_user, get_user_stats
from keyboards.inline.dashboard import main_dashboard_kb
from handlers.common.start import cmd_start as deep_link_logic

router = Router()

@router.message(CommandStart())
async def smart_dashboard(message: types.Message, command: CommandObject, session: AsyncSession, bot: Bot):
    # –ï—Å–ª–∏ —ç—Ç–æ –¥–∏–ø–ª–∏–Ω–∫ (gw_123 –∏–ª–∏ res_123), –ø–µ—Ä–µ–¥–∞–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤ handlers/common/start.py
    if command.args and (command.args.startswith("gw_") or command.args.startswith("res_")):
        await deep_link_logic(message, command, session, bot)
        return

    await register_user(session, message.from_user.id, message.from_user.username, message.from_user.full_name)

    stats = await get_user_stats(session, message.from_user.id)
    is_admin = (stats['active'] + stats['finished']) > 0
    
    text = (
        f"üëã <b>–ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}!</b>\n\n"
        f"–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç.\n"
        f"–ó–¥–µ—Å—å –≤—ã –º–æ–∂–µ—Ç–µ —Å–æ–∑–¥–∞–≤–∞—Ç—å —Ä–æ–∑—ã–≥—Ä—ã—à–∏ –∏ –ø—Ä–æ–≤–µ—Ä—è—Ç—å —Å–≤–æ–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã."
    )

    await message.answer(text, reply_markup=main_dashboard_kb(is_admin))

@router.callback_query(F.data == "dashboard_home")
async def back_home(call: types.CallbackQuery, session: AsyncSession):
    stats = await get_user_stats(session, call.from_user.id)
    is_admin = (stats['active'] + stats['finished']) > 0
    await call.message.edit_text("üëã <b>–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>", reply_markup=main_dashboard_kb(is_admin))=== ./handlers/user/__init__.py ===
=== ./handlers/user/my_participations.py ===
import math
from aiogram import Router, types, F, Bot
from sqlalchemy.ext.asyncio import AsyncSession

from database.requests.participant_repo import get_user_participations_detailed, count_user_participations
from database.requests.giveaway_repo import get_giveaway_by_id, get_giveaways_by_owner, count_giveaways_by_owner
from database.requests.user_repo import get_user_stats
from keyboards.inline.user_panel import giveaways_hub_kb, universal_list_kb, participation_details_kb, detail_back_kb

router = Router()

# 1. –•–ê–ë (–ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ –†–ê–ó–î–ï–õ–ê)
@router.callback_query(F.data == "giveaways_hub")
async def show_hub(call: types.CallbackQuery, session: AsyncSession):
    stats = await get_user_stats(session, call.from_user.id)
    has_created = (stats['active'] + stats['finished']) > 0
    
    await call.message.edit_text(
        "üéÅ <b>–†–∞–∑–¥–µ–ª: –†–æ–∑—ã–≥—Ä—ã—à–∏</b>\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:",
        reply_markup=giveaways_hub_kb(has_created)
    )

# 2. –°–ü–ò–°–û–ö –£–ß–ê–°–¢–ò–ô (–ê–∫—Ç–∏–≤–Ω—ã–µ / –ó–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ)
@router.callback_query(F.data.startswith("part_list:"))
async def show_participation_list(call: types.CallbackQuery, session: AsyncSession):
    # part_list:active:0
    _, status, page_str = call.data.split(":")
    page = int(page_str)
    limit = 5
    offset = page * limit
    user_id = call.from_user.id
    
    giveaways = await get_user_participations_detailed(session, user_id, status, limit, offset)
    total_count = await count_user_participations(session, user_id, status)
    
    if total_count == 0:
        return await call.answer("üì≠ –ó–¥–µ—Å—å –ø–æ–∫–∞ –ø—É—Å—Ç–æ.", show_alert=True)
        
    total_pages = math.ceil(total_count / limit)
    status_text = "–í –∫–æ—Ç–æ—Ä—ã—Ö —É—á–∞—Å—Ç–≤—É—é" if status == 'active' else "–ó–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ (–£—á–∞—Å—Ç–∏–µ)"
    prefix = f"part_list:{status}"
    
    await call.message.edit_text(
        f"üìÇ <b>{status_text}</b>\n–°—Ç—Ä–∞–Ω–∏—Ü–∞ {page+1} –∏–∑ {total_pages}",
        reply_markup=universal_list_kb(giveaways, page, total_pages, prefix, user_id)
    )

# 3. –°–ü–ò–°–û–ö –°–û–ó–î–ê–ù–ù–´–• –ú–ù–û–ô
@router.callback_query(F.data.startswith("created_list:"))
async def show_created_list(call: types.CallbackQuery, session: AsyncSession):
    # created_list:0
    _, page_str = call.data.split(":")
    page = int(page_str)
    limit = 5
    offset = page * limit
    user_id = call.from_user.id
    
    giveaways = await get_giveaways_by_owner(session, user_id, limit, offset)
    total_count = await count_giveaways_by_owner(session, user_id)
    
    if total_count == 0:
        return await call.answer("üì≠ –í—ã –µ—â–µ –Ω–µ —Å–æ–∑–¥–∞–≤–∞–ª–∏ —Ä–æ–∑—ã–≥—Ä—ã—à–∏.", show_alert=True)
        
    total_pages = math.ceil(total_count / limit)
    
    await call.message.edit_text(
        f"üìÇ <b>–ú–æ–∏ —Ä–æ–∑—ã–≥—Ä—ã—à–∏ (–°–æ–∑–¥–∞–Ω–Ω—ã–µ)</b>\n–°—Ç—Ä–∞–Ω–∏—Ü–∞ {page+1} –∏–∑ {total_pages}",
        reply_markup=universal_list_kb(giveaways, page, total_pages, "created_list", user_id)
    )

# 4. –ü–†–û–°–ú–û–¢–† –î–ï–¢–ê–õ–ï–ô (–£–ß–ê–°–¢–ò–ï)
@router.callback_query(F.data.startswith("part_view:"))
async def view_participation(call: types.CallbackQuery, session: AsyncSession, bot: Bot):
    gw_id = int(call.data.split(":")[-1])
    gw = await get_giveaway_by_id(session, gw_id)
    if not gw: return await call.answer("–ù–µ –Ω–∞–π–¥–µ–Ω–æ")

    user_id_str = str(call.from_user.id)
    if gw.status == 'active':
        st_text = "‚è≥ –ê–∫—Ç–∏–≤–µ–Ω"
        res_text = "ü§û –í—ã —É—á–∞—Å—Ç–≤—É–µ—Ç–µ"
    else:
        st_text = "üèÅ –ó–∞–≤–µ—Ä—à–µ–Ω"
        if gw.winner_ids and user_id_str in gw.winner_ids.split(","):
            res_text = "üèÜ <b>–í–´ –í–´–ò–ì–†–ê–õ–ò!</b>"
        else:
            res_text = "‚ùå –í—ã –Ω–µ –≤—ã–∏–≥—Ä–∞–ª–∏"

    post_link = None
    try:
        chat = await bot.get_chat(gw.channel_id)
        if chat.username: post_link = f"https://t.me/{chat.username}/{gw.message_id}"
    except: pass

    await call.message.edit_text(
        f"üéÅ <b>{gw.prize_text}</b>\n\n–°—Ç–∞—Ç—É—Å: {st_text}\n{res_text}",
        reply_markup=participation_details_kb(post_link)
    )

# 5. –ü–†–û–°–ú–û–¢–† –î–ï–¢–ê–õ–ï–ô (–°–û–ó–î–ê–ù–ù–´–ô)
@router.callback_query(F.data.startswith("view_created:"))
async def view_created(call: types.CallbackQuery, session: AsyncSession):
    gw_id = int(call.data.split(":")[-1])
    gw = await get_giveaway_by_id(session, gw_id)
    if not gw: return await call.answer("–ù–µ –Ω–∞–π–¥–µ–Ω–æ")
    
    await call.message.edit_text(
        f"üì¢ <b>–í–∞—à —Ä–æ–∑—ã–≥—Ä—ã—à #{gw.id}</b>\n\n"
        f"üìù –ü—Ä–∏–∑: {gw.prize_text}\n"
        f"üë• –ü–æ–±–µ–¥–∏—Ç–µ–ª–µ–π: {gw.winners_count}\n"
        f"üìÖ –§–∏–Ω–∏—à: {gw.finish_time.strftime('%Y-%m-%d %H:%M')}\n"
        f"‚öôÔ∏è –°—Ç–∞—Ç—É—Å: {gw.status}",
        reply_markup=detail_back_kb()
    )

@router.callback_query(F.data == "ignore")
async def ignore(call: types.CallbackQuery): await call.answer()